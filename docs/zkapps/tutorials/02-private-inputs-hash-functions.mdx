---
title: "Tutorial 2: Private Inputs and Hash Functions"
hide_title: true
sidebar_label: "Tutorial 2: Private Inputs and Hash Functions"
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

# Tutorial 2: Private Inputs and Hash Functions

## Overview

In our last tutorial, [Hello World](hello-world), we saw how to build a basic zkApp smart contract in SnarkyJS, with a single state variable, that could be updated if a user knew the square of that number.

In this example, we will discuss private inputs, and hash functions.

In a zkApp, local devices generate proofs, which are then verified on chain. Each method in a SnarkyJS Smart contract corresponds to constructing a proof.

As such, *all inputs to a smart contract are by default, private*, unless they are revealed as part of changing zkApp state.

We will build a smart contract with a piece of private state, that can be modified if a user knows the private state.

You can find the complete source code of this project [here](https://github.com/es92/zkApp-examples/tree/main/02-private-inputs-and-hash-functions).

## Setup

The following steps assume you've installed dependencies to your machine as described in the previous tutorial - if not, please do that [here](hello-world).

Now, setup a new project with 
```sh
$ zk project 02-private-inputs-and-hash-functions
```


To start, delete the default generated files by running:

```sh
rm src/Add.ts
rm src/Add.test.ts
```

And create new files:

```sh
$ zk file src/IncrementSecret
$ touch src/main.ts
```

And lastly, change `index.ts` to 
```ts
import { IncrementSecret } from './IncrementSecret.js';

export { IncrementSecret };
```

## IncrementSecret smart contract

Now we'll build the smart contract for our application.

Start out our smart contract by entering:

```ts
  1 import {
  2   Field,
  3   SmartContract,
  4   state,
  5   State,
  6   method,
  7   DeployArgs,
  8   Poseidon,
  9   Permissions,
 10 } from 'snarkyjs';
 11
 12 export class IncrementSecret extends SmartContract {
 13   @state(Field) x = State<Field>();
 14
 15   deploy(args: DeployArgs) {
 16     super.deploy(args);
 17     this.setPermissions({
 18       ...Permissions.default(),
 19       editState: Permissions.proofOrSignature(),
 20     });
 21   }
 22 }
```

This just completes basic setup for our smart contract - see Tutorial 01 Hello World for more on this.

Now we will add our initializer function.

```ts
...
 22
 23   @method init(salt: Field, firstSecret: Field) {
 24     this.x.set(Poseidon.hash([ salt, firstSecret ]));
 25   }
 26 }
```

Note in this case, the initializer of the smart contract sets the secret, and a value called a "salt", which we will discuss later. 

The initializer setting these values ensures that anybody looking at the smart contract code cannot figure out the value of the secret - this is private to whoever initializes the contract.

Next we will add our state update function:
```ts
...
 26
 27   @method incrementSecret(salt: Field, secret: Field) {
 28     const x = this.x.get();
 29     this.x.assertEquals(x);
 30
 31     Poseidon.hash([ salt, secret ]).assertEquals(x);
 32     this.x.set(Poseidon.hash([ salt, secret.add(1) ]));
 33   }
 34 }
 ```

Mina uses the poseidon hash function, which has been optimized inside its proof system for fast performance. The poseidon hash function takes in an array of Fields, and returns a single Field as output.

In this smart contract, we use both a secret number, and a second field, known as a "salt".

In the `incrementSecret` function, we check that the hash of the salt and our secret is equal to the current state x. If this is the case, we add 1 to the secret and set x to the hash of the salt and the new secret. SnarkyJS creates a proof of this fact, which can be transmitted over the network to update the smart contract.

Because zkApp smart contracts are run offchain, and only a proof is set over the network, both the salt and secret themselves remain private. Only the result, updating x to hash([ salt, secret + 1]) are revealed. Because the salt and secret can't be deduced from their hash, they remain private.

### But why the extra `salt` argument?

The extra `salt` argument is added to avoid a possible attack on our smart contract. If we were to just use `secret`, it would be vulnerable to discovery by an attacker. To do this, our attacker could try hashing likely secrets, and check if the hash matches the hash stored in the smart contract. If the hash were to match, then the attacker would have known they had discovered the secret. This is particularly concerning if the secret is likely to be in a particular range of the field, say between 1 and 10,000. In that case, with just 10,000 hashes, the attacker could discover our secret.

What we can do to fix this, is add a second value, chosen uniformly over the field. This second value ensures that there are too many possibilities for an attacker to try for it to be possible to use this brute force method. This second value is commonly known as a "salt", and is the added field we've added to our smart contract.

## Main

Our `src/main.ts` is similar to our last tutorial - for a full version of `src/main.ts`, see [here](https://github.com/es92/zkApp-examples/blob/main/02-private-inputs-and-hash-functions/src/main.ts).

Key parts to discuss though, are initializing our contract, and using the poseidon hash.

Our smart contract initialization this time will be:
```ts
...
 22  const salt = Field.random();
...
 32   const deploy_txn = await Mina.transaction(deployerAccount, () => {
 33     AccountUpdate.fundNewAccount(deployerAccount);
 34     zkAppInstance.deploy({ zkappKey: zkAppPrivateKey });
 35     zkAppInstance.init(salt, Field.fromNumber(750));
 36     zkAppInstance.sign(zkAppPrivateKey);
 37   });
 ...
```

Note the init function taking the salt and our secret, in this case the number 750.

And here is how one can send a transaction:
```ts
...
 46   const txn1 = await Mina.transaction(deployerAccount, () => {
 47     zkAppInstance.incrementSecret(salt, Field.fromNumber(750));
 48     zkAppInstance.sign(zkAppPrivateKey);
 49   });
...
```

We call the zkApp smart contract with both the salt and the secret itself, the number 750. Because in zkApps smart contracts are executed locally, neither the secret nor the salt will make it into the transaction. 

Instead, the transaction will include only the proof that the update was called in such a way that all asserts passed, and the update to the hash `x`. After the transcation is executed on chain, `x` will be `Poseidon.hash([ salt, Field.fromNumber(750).add(1) ])`, but the underlying salt and secret will not be revealed.

## Conclusion

Congrats! We have finished building a smart contract that uses privacy and hash functions

Now let's move to the [next tutorial](deploying-to-a-network), where we will see how to deploy a Smart Contract to a live network and interact with it.
