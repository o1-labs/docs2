---
title: "Tutorial 2: Private Inputs and Hash Functions"
hide_title: true
sidebar_label: "Tutorial 2: Private Inputs and Hash Functions"
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

# Tutorial 2: Private Inputs and Hash Functions

## Overview

In our last tutorial, [Hello World](hello-world), we saw how to build a basic zkApp smart contract in SnarkyJS, with a single state variable, that could be updated if a user knew the square of that number.

In this example, we will discuss private inputs, and hash functions.

In a zkApp, local devices generate proofs, which are then verified on chain. Each method in a SnarkyJS Smart contract corresponds to constructing a proof.

As such, *all inputs to a smart contract are by default, private*, unless they are revealed as part of changing zkApp state.

We will build a smart contract with a piece of private state, that can be modified if a user knows the private state.

You can find the complete source code of this project [here](https://github.com/es92/zkApp-examples/tree/main/02-private-inputs-and-hash-functions).

## Setup

The following steps assume you've installed dependencies to your machine as described in the previous tutorial - if not, please do that [here](hello-world).

Now, setup a new project with 
```sh
$ zk project 02-private-inputs-and-hash-functions
```


To start, delete the default generated files by running:

```sh
rm src/Add.ts
rm src/Add.test.ts
```

And create new files:

```sh
$ zk file src/IncrementSecret
$ touch src/main.ts
```

And lastly, change `index.ts` to 
```ts
import { IncrementSecret } from './IncrementSecret.js';

export { IncrementSecret };
```

### IncrementSecret smart contract

Now we'll build the smart contract for our application.

Start out our smart contract by entering:

```ts
  1 import {
  2   Field,
  3   SmartContract,
  4   state,
  5   State,
  6   method,
  7   DeployArgs,
  8   Poseidon,
  9   Permissions,
 10 } from 'snarkyjs';
 11
 12 export class IncrementSecret extends SmartContract {
 13   @state(Field) x = State<Field>();
 14
 15   deploy(args: DeployArgs) {
 16     super.deploy(args);
 17     this.setPermissions({
 18       ...Permissions.default(),
 19       editState: Permissions.proofOrSignature(),
 20     });
 21   }
 22 }
```

This just completes basic setup for our smart contract - see Tutorial 01 Hello World for more on this.

Now we will add our initializer function.

```ts
...
 22
 23   @method init(salt: Field, firstSecret: Field) {
 24     this.x.set(Poseidon.hash([ salt, firstSecret ]));
 25   }
 26 }
```

Note in this case, the initializer of the smart contract sets the secret. This ensures that anybody looking at the smart contract code cannot figure out the value of the secret - this is private to whoever initializes the contract.

Next we will add our state update function:
```ts
...
 26
 27   @method incrementSecret(salt: Field, secret: Field) {
 28     const x = this.x.get();
 29     this.x.assertEquals(x);
 30
 31     Poseidon.hash([ salt, secret ]).assertEquals(x);
 32     this.x.set(Poseidon.hash([ salt, secret.add(1) ]));
 33   }
 34 }
 ```

Mina uses the poseidon hash function, which has been optimized inside its proof system for fast performance. The poseidon hash function takes in an array of Fields, and returns a single Field as output.

In this function, we use both a secret (a number), and a value known as a "salt". The salt ensures no onlooker can figure out the value of the secret by bruteforcing possible numbers. If for example it was known that the secret is likely between 1 and 10,000, an attacker could try hashing all of these possibilities and so discover our secret. The salt, by being uniformly random over the field, ensures this isn't possible.

First in the function, we check that the hash of the salt and our secret is equal to the current state x. If this is the case, we add 1 to the secret and set x to the hash of the salt and the new secret. SnarkyJS creates a proof of this fact, which can be transmitted over the network to update the smart contract.

Because zkApp smart contracts are run offchain, and only a proof is set over the network, both the salt and secret themselves remain private. Only the result, updating x to hash([ salt, secret + 1]) are revealed. Because the salt and secret can't be deduced from their hash, they remain private.

### Main

Our `src/main.ts` is similar to our last tutorial - for a full version of `src/main.ts`, see [here](https://github.com/es92/zkApp-examples/blob/main/02-private-inputs-and-hash-functions/src/main.ts).

Key parts to discuss though, are initializing our contract, and using the poseidon hash.

Our smart contract initialization this time will be:
```ts
...
 22  const salt = Field.random();
...
 32   const deploy_txn = await Mina.transaction(deployerAccount, () => {
 33     AccountUpdate.fundNewAccount(deployerAccount);
 34     zkAppInstance.deploy({ zkappKey: zkAppPrivateKey });
 35     zkAppInstance.init(salt, Field.fromNumber(750));
 36     zkAppInstance.sign(zkAppPrivateKey);
 37   });
 ...
```

Note the init function taking the salt and our secret, in this case the number 750.

And here is how one can send a transaction:
```ts
...
 46   const txn1 = await Mina.transaction(deployerAccount, () => {
 47     zkAppInstance.incrementSecret(salt, Field.fromNumber(750));
 48     zkAppInstance.sign(zkAppPrivateKey);
 49   });
...
```

We call the zkApp smart contract with both the salt and the secret itself, the number 750. Because in zkApps smart contracts are executed locally, neither the secret nor the salt will make it into the transaction. 

Instead, the transaction will include only the proof that the update was called in such a way that all asserts passed, and the update to the hash `x`. After the transcation is executed on chain, `x` will be `Poseidon.hash([ salt, Field.fromNumber(750).add(1) ])`, but the underlying salt and secret will not be revealed.

## Conclusion

Congrats! We have finished building a smart contract that uses privacy and hash functions

Checkout out our other tutorials to keep going!
