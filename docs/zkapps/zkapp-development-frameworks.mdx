---
title: zkApps Development Frameworks
sidebar_label: zkApps Development Frameworks
hide_title: true
description: zkApps (zero knowledge apps) are Mina Protocol smart contracts powered by zero knowledge proofs, specifically using zk-SNARKs.
keywords:
  - zkapps
  - mina protocol
  - smart contracts
  - zero knowledge proofs
  - off-chain execution
  - typescript
  - quickstart zkapps
  - o1js
  - protokit
---


#  zkApp Development Frameworks

Applications on Mina are called zkApps, and they come in a wide range of forms, including DeFi, games, state bridges, and more. However, due to Minaâ€™s client-side execution model, the developer experience differs somewhat from that of other blockchain networks, such as Ethereum.

Developers build zkApps with **o1js**. Developers can either use o1js directly or use o1js with **Protokit**, a framework built on top of o1js. Both options offer the full benefits of Minaâ€™s verifiable, privacy-preserving zero knowledge proofs, but offer different tradeoffs between developer experience, performance, and decentralization.

<table>
  <tr>
   <td>Info
   </td>
  </tr>
  <tr>
   <td>Please note that Protokit is in alpha, and settlement support with reorgs is still in progress.
   </td>
  </tr>
</table>


This page provides a guide to choosing the best approach for your zkApp development - o1js directly or Protokit on top of o1js.

If you are unsure about any of the information presented here and need guidance on choosing the most suitable framework for you, drop by [Discord](https://discord.gg/minaprotocol) and let us help!


## Choosing a framework

Developers can build zkApps either directly with **o1js**, or with **o1js** + **Protokit**.

Protokit is built on top of o1js and simplifies the development of **zkApps with concurrent users requiring a shared state**, such as DEXes or games. Protokit is recommended for most developers.

o1js is the best way to write **custom zero knowledge circuits** and construct low-level primitives on Mina, such as an NFT standard or a zkML library.


<table>
  <tr>
   <td>Info
   </td>
  </tr>
  <tr>
   <td>For developers coming from the Ethereum ecosystem, think of zkApps like smart contracts that can be verified off-chain. 
<p>
This enables Mina to employ a client-side execution model, which gives Mina its scalability and privacy properties, but it can make it difficult to develop applications with concurrent users requiring a shared state. Protokit builds on top of o1js to solve these concurrency challenges.
   </td>
  </tr>
</table>



## [Protokit](https://docs.minaprotocol.com/zkapps/zkapp-development-frameworks#protokit)

Protokit is designed for **zkApps with concurrent users requiring a shared state**, for example, DEXes and most games. In addition to this Protokit provides an integrated verifiable data storage solution that further simplifies the developer experience compared to o1js. 

Protokit can operate in two modes: Based Sequencing and Hybrid Sequencing.

In **Based Sequencing mode**, Protokit sends all transactions to the Mina L1, providing the decentralization guarantees of the L1, but limited to the L1â€™s throughput and latency. Based Sequencing mode is best for zkApps where censorship resistance and liveness are more important than the additional performance benefits.

In **Hybrid Sequencing mode**, Protokit runs an off-chain sequencer with off-chain data availability, providing higher throughput and lower latency than the Mina L1 but at the expense of decentralization. Hybrid Sequencing mode is best for zkApps where performance is critical.

**Important:** Users of a zkApp in Hybrid Sequencing mode can always **submit transactions directly to the L1**, for example, to withdraw funds (in case the zkApp sequencer is unavailable) but it does rely on the Protokitâ€™s data availability (DA). Solutions are in the works for DA guarantees even in Hybrid Sequencing mode so that developers can get higher throughput and latency while retaining censorship resistance and liveness guarantees.

Start developing zkApps with Protokit here:



* [Developer documentation](https://protokit.dev/docs/what-is-protokit)
* [Protokit repository](https://github.com/proto-kit)
* [Starter Kit](https://github.com/proto-kit/starter-kit)


## o1js[â€‹](https://docs.minaprotocol.com/zkapps/zkapp-development-frameworks#o1js)

[o1js](https://docs.minaprotocol.com/zkapps/o1js) is the best way to author **highly-optimized ZK circuits and primitives**, but it does not provide an easy-to-use solution for managing a shared global state.

o1js can be used directly on the Mina L1, and is thus limited by the L1â€™s throughput and latency, but maintains strong decentralization guarantees.


<table>
  <tr>
   <td>Info
   </td>
  </tr>
  <tr>
   <td><strong>Did you know?</strong> zkApps written directly with o1js can orchestrate concurrent users requiring shared state using Mina L1â€™s <a href="https://docs.minaprotocol.com/zkapps/writing-a-zkapp/feature-overview/actions-and-reducer">Actions & Reducer</a>, but it requires significant development to orchestrate Action & Reducers. At its core, Protokit is a framework for orchestrating the Mina L1 Actions & Reducers out of the box.
   </td>
  </tr>
</table>


Start developing zkApps with o1js here:



* [Developer documentation](https://docs.minaprotocol.com/zkapps/o1js)
* [o1js repository](https://github.com/o1-labs/o1js)
* [Discord](https://discord.gg/minaprotocol)


## Choosing between Protokit and o1js

**Still canâ€™t decide between Protokit and o1js?** 

This section provides a comparison table to help zkApp developers choose which framework to use.


<table>
  <tr>
   <td>
   </td>
   <td><strong>Protokit Hybrid</strong>
   </td>
   <td><strong>Protokit Based</strong>
   </td>
   <td><strong>o1js</strong>
   </td>
  </tr>
  <tr>
   <td><strong>Concurrency</strong>
   </td>
   <td>âœ…
   </td>
   <td>âœ…
   </td>
   <td>ðŸŸ¡
   </td>
  </tr>
  <tr>
   <td><strong>Shared State</strong>
   </td>
   <td>âœ…
   </td>
   <td>âœ…
   </td>
   <td>ðŸŸ¡
   </td>
  </tr>
  <tr>
   <td><strong>Throughput</strong>
   </td>
   <td>âœ…
   </td>
   <td>ðŸŸ¡
   </td>
   <td>ðŸŸ¡
   </td>
  </tr>
  <tr>
   <td><strong>Latency</strong>
   </td>
   <td>âœ…
   </td>
   <td>ðŸŸ¡
   </td>
   <td>ðŸŸ¡
   </td>
  </tr>
  <tr>
   <td><strong>Censorship Resistance</strong>
   </td>
   <td>ðŸŸ¡
   </td>
   <td>âœ…
   </td>
   <td>âœ…
   </td>
  </tr>
  <tr>
   <td><strong>Liveness</strong>
   </td>
   <td>ðŸŸ¡
   </td>
   <td>âœ…
   </td>
   <td>âœ…
   </td>
  </tr>
  <tr>
   <td><strong>Security</strong>
   </td>
   <td>âœ…
   </td>
   <td>âœ…
   </td>
   <td>âœ…
   </td>
  </tr>
</table>


**Understanding the performance vs. centralization tradeoff**

Protokit includes an off-chain sequencer and off-chain storage. If one or the other becomes inaccessible, users may find they can no longer access the zkApp including any tokens they may have in the zkApp.

If the Protokit instanceâ€™s sequencer is unavailable but the storage is still accessible, users may submit transactions (e.g. withdrawals) directly to the Mina L1.

If the Protokit instanceâ€™s storage is inaccessible, users will not be able to submit transactions to the Mina L1 and their tokens may be locked until the storage can be recovered.

Solutions are in the works for DA guarantees even in Hybrid Sequencing mode so that developers can get higher throughput and latency while retaining censorship resistance and liveness guarantees.



