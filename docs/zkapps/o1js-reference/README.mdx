---
title: o1js API Reference
keywords:
  - o1js
  - API
  - Reference
---

---
title: o1js API Reference
keywords:
  - o1js
  - API
  - Reference
---

---
title: o1js API Reference
keywords:
  - o1js
  - API
  - Reference
---

# o1js &nbsp; [![npm version](https://img.shields.io/npm/v/o1js.svg?style=flat)](https://www.npmjs.com/package/o1js) [![npm](https://img.shields.io/npm/dm/o1js)](https://www.npmjs.com/package/o1js) [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](https://github.com/o1-labs/o1js/blob/main/CONTRIBUTING.md)

ℹ️ **o1js** is an evolution of [SnarkyJS](https://www.npmjs.com/package/snarkyjs) which saw
49 updated versions over two years of development with 43,141 downloads.

This name change to o1js reflects the evolution of our vision for the premiere toolkit used by developers to build zero knowledge-enabled applications, while paying homage to our technology's recursive proof generation capabilities.

Your favorite functionality stays the same and transitioning to o1js is a quick and easy process:

- To update zkApp-cli, run the following command:

  `npm i -g zkapp-cli@latest`

- To remove the now-deprecated SnarkyJS package and install o1js, run the following command:

  `npm remove snarkyjs && npm install o1js`

- For existing zkApps, make sure to update your imports from `snarkyjs` to `o1js`
- No need to redeploy, you are good to go!

## o1js

o1js helps developers build apps powered by zero knowledge (zk) cryptography.

The easiest way to write zk programs is using o1js.

o1js is a TypeScript library for [zk-SNARKs](https://minaprotocol.com/blog/what-are-zk-snarks) and zkApps. You can use o1js to write zk smart contracts based on zero-knowledge proofs for the Mina Protocol.

o1js is automatically included when you create a project using the [zkApp CLI](https://www.npmjs.com/package/zkapp-cli).

## Learn More

- To learn more about developing zkApps, see the [zkApp Developers](https://docs.minaprotocol.com/zkapps) docs.

- For guided steps building and using zkApps, see the [zkApp Developers Tutorials](https://docs.minaprotocol.com/zkapps/tutorials/hello-world).

- To meet other developers building zkApps with o1js, participate in the [#zkapps-developers](https://discord.com/channels/484437221055922177/915745847692636181) channel on Mina Protocol Discord.

- For a list of changes between versions, see the [CHANGELOG](https://github.com/o1-labs/o1js/blob/main/CHANGELOG.md).

- To stay up to date with o1js, see the [O(1) Labs Blog](https://www.o1labs.org/blog?topics=o1js).

## Contributing

o1js is an open source project. We appreciate all community contributions to o1js!

See the [Contributing guidelines](https://github.com/o1-labs/o1js/blob/main/CONTRIBUTING.md) for ways you can contribute.

## Development Workflow

For guidance on building o1js from source and understanding the development workflow, see [o1js README-dev](https://github.com/o1-labs/o1js/blob/main/README-dev.md).

## Community Packages

High-quality community packages from open source developers are available for your project.

- **o1js-elgamal** A partially homomorphic encryption library for o1js based on Elgamal encryption: [GitHub](https://github.com/Trivo25/o1js-elgamal) and [npm](https://www.npmjs.com/package/o1js-elgamal)
- **o1js-pack** A library for o1js that allows a zkApp developer to pack extra data into a single Field. [GitHub](https://github.com/45930/o1js-pack) and [npm](https://www.npmjs.com/package/o1js-pack)
- **zk-regex-o1js** A CLI tool for compiling ZK Regex circuits in o1js. [Github](https://github.com/Shigoto-dev19/zk-regex-o1js) and [npm](https://www.npmjs.com/package/zk-regex-o1js)

To include your package, see [Creating high-quality community packages](https://github.com/o1-labs/o1js/blob/main/CONTRIBUTING.md#creating-high-quality-community-packages).

| Member | Description |
| :------ | :------ |
| [Crypto](namespaces/Crypto/README.mdx) | - |
| [Encryption](namespaces/Encryption/README.mdx) | - |
| [Experimental](namespaces/Experimental/README.mdx) | This module exposes APIs that are unstable, in the sense that the API surface is expected to change. |
| [Lightnet](namespaces/Lightnet/README.mdx) | - |
| [Mina](namespaces/Mina/README.mdx) | - |
| [AccountUpdate](classes/AccountUpdate.mdx) | An [AccountUpdate](classes/AccountUpdate.mdx) is a set of instructions for the Mina network. |
| [AccountUpdateForest](classes/AccountUpdateForest.mdx) | Class which represents a forest (list of trees) of account updates, |
| [AccountUpdateTree](classes/AccountUpdateTree.mdx) | Class which represents a tree of account updates, |
| [AlmostForeignField](classes/AlmostForeignField.mdx) | - |
| [BaseMerkleWitness](classes/BaseMerkleWitness.mdx) | The [BaseMerkleWitness](classes/BaseMerkleWitness.mdx) class defines a circuit-compatible base class for [Merkle Witness](https://computersciencewiki.org/index.php/Merkle_proof). |
| [Bool](classes/Bool.mdx) | A boolean value. You can use it like this: |
| [CanonicalForeignField](classes/CanonicalForeignField.mdx) | - |
| [Character](classes/Character.mdx) | - |
| [Circuit](classes/Circuit.mdx) | - |
| [CircuitString](classes/CircuitString.mdx) | - |
| [DynamicProof](classes/DynamicProof.mdx) | The `DynamicProof` class enables circuits to verify proofs using in-ciruit verfication keys. |
| [EcdsaSignature](classes/EcdsaSignature.mdx) | - |
| [Field](classes/Field.mdx) | A [Field](classes/Field.mdx) is an element of a prime order [finite field](https://en.wikipedia.org/wiki/Finite_field). |
| [ForeignCurve](classes/ForeignCurve.mdx) | - |
| [ForeignField](classes/ForeignField.mdx) | - |
| [Group](classes/Group.mdx) | An element of a Group. |
| [Hashed](classes/Hashed.mdx) | `Hashed<T>` represents a type `T` by its hash. |
| [Int64](classes/Int64.mdx) | A 64 bit signed integer with values ranging from -18,446,744,073,709,551,615 to 18,446,744,073,709,551,615. |
| [Keypair](classes/Keypair.mdx) | - |
| [Ledger](classes/Ledger.mdx) | Represents the Mina ledger. |
| [MerkleList](classes/MerkleList.mdx) | Dynamic-length list which is represented as a single hash |
| [MerkleListIterator](classes/MerkleListIterator.mdx) | MerkleListIterator helps iterating through a Merkle list. |
| [MerkleMap](classes/MerkleMap.mdx) | - |
| [MerkleMapWitness](classes/MerkleMapWitness.mdx) | - |
| [MerkleTree](classes/MerkleTree.mdx) | A [Merkle Tree](https://en.wikipedia.org/wiki/Merkle_tree) is a binary tree in which every leaf is the cryptography hash of a piece of data, |
| [Nullifier](classes/Nullifier.mdx) | Nullifiers are used as a public commitment to a specific anonymous account, |
| [Packed](classes/Packed.mdx) | `Packed<T>` is a "packed" representation of any type `T`. |
| [PrivateKey](classes/PrivateKey.mdx) | A signing key. You can generate one via [PrivateKey.random](classes/PrivateKey.mdx#random). |
| [Proof](classes/Proof.mdx) | - |
| [ProofBase](classes/ProofBase.mdx) | - |
| [PublicKey](classes/PublicKey.mdx) | A public key, which is also an address on the Mina network. |
| [Scalar](classes/Scalar.mdx) | Represents a [Scalar](classes/Scalar.mdx). |
| [ScalarField](classes/ScalarField.mdx) | ForeignField representing the scalar field of Pallas and the base field of Vesta |
| [SelfProof](classes/SelfProof.mdx) | - |
| [Sign](classes/Sign.mdx) | - |
| [Signature](classes/Signature.mdx) | A Schnorr [Signature](classes/Signature.mdx) over the Pasta Curves. |
| [SmartContract](classes/SmartContract.mdx) | The main zkapp class. To write a zkapp, extend this class as such: |
| [TokenAccountUpdateIterator](classes/TokenAccountUpdateIterator.mdx) | Data structure to represent a forest of account updates that is being iterated over, |
| [TokenContract](classes/TokenContract.mdx) | Base token contract which |
| [TokenSymbol](classes/TokenSymbol.mdx) | - |
| [UInt32](classes/UInt32.mdx) | A 32 bit unsigned integer with values ranging from 0 to 4,294,967,295. |
| [UInt64](classes/UInt64.mdx) | A 64 bit unsigned integer with values ranging from 0 to 18,446,744,073,709,551,615. |
| [UInt8](classes/UInt8.mdx) | A 8 bit unsigned integer with values ranging from 0 to 255. |
| [Unconstrained](classes/Unconstrained.mdx) | Container which holds an unconstrained value. This can be used to pass values |
| [VerificationKey](classes/VerificationKey.mdx) | - |
| [Permissions](interfaces/Permissions.mdx) | Permissions specify how specific aspects of the zkapp account are allowed |
| [Account](type-aliases/Account.mdx) | - |
| [Bool](type-aliases/Bool.mdx) | - |
| [BoolVar](type-aliases/BoolVar.mdx) | - |
| [Bytes](type-aliases/Bytes.mdx) | - |
| [Cache](type-aliases/Cache.mdx) | Interface for storing and retrieving values, for caching. |
| [CacheHeader](type-aliases/CacheHeader.mdx) | A header that is passed to the caching layer, to support rich caching strategies. |
| [ConstantField](type-aliases/ConstantField.mdx) | - |
| [DeployArgs](type-aliases/DeployArgs.mdx) | - |
| [Empty](type-aliases/Empty.mdx) | - |
| [FeatureFlags](type-aliases/FeatureFlags.mdx) | - |
| [Field](type-aliases/Field.mdx) | - |
| [FlexibleProvable](type-aliases/FlexibleProvable.mdx) | - |
| [FlexibleProvablePure](type-aliases/FlexibleProvablePure.mdx) | - |
| [Group](type-aliases/Group.mdx) | - |
| [InferProvable](type-aliases/InferProvable.mdx) | - |
| [JsonProof](type-aliases/JsonProof.mdx) | - |
| [MerkleListBase](type-aliases/MerkleListBase.mdx) | Common base type for [MerkleList](classes/MerkleList.mdx) and [MerkleListIterator](classes/MerkleListIterator.mdx) |
| [MerkleListIteratorBase](type-aliases/MerkleListIteratorBase.mdx) | - |
| [Option](type-aliases/Option.mdx) | - |
| [Provable](type-aliases/Provable.mdx) | `Provable<T>` is the general interface for provable types in o1js. |
| [ProvableExtended](type-aliases/ProvableExtended.mdx) | - |
| [ProvableHashable](type-aliases/ProvableHashable.mdx) | - |
| [ProvableHashable](type-aliases/ProvableHashable-1.mdx) | - |
| [ProvablePure](type-aliases/ProvablePure.mdx) | `ProvablePure<T>` is a special kind of [Provable](type-aliases/Provable.mdx) interface, where the "auxiliary" (non-provable) data is empty. |
| [ProvableType](type-aliases/ProvableType.mdx) | - |
| [ProvableTypePure](type-aliases/ProvableTypePure.mdx) | - |
| [ProvableWithEmpty](type-aliases/ProvableWithEmpty.mdx) | - |
| [Reducer](type-aliases/Reducer.mdx) | - |
| [ScalarConst](type-aliases/ScalarConst.mdx) | - |
| [State](type-aliases/State.mdx) | Gettable and settable state that can be checked for equality. |
| [Struct](type-aliases/Struct.mdx) | - |
| [ToProvable](type-aliases/ToProvable.mdx) | - |
| [TransactionPromise](type-aliases/TransactionPromise.mdx) | A `Promise<Transaction>` with some additional methods for making chained method calls |
| [TransactionStatus](type-aliases/TransactionStatus.mdx) | INCLUDED: A transaction that is on the longest chain |
| [TupleN](type-aliases/TupleN.mdx) | tuple type that has the length as generic parameter |
| [Undefined](type-aliases/Undefined.mdx) | - |
| [VarField](type-aliases/VarField.mdx) | - |
| [Void](type-aliases/Void.mdx) | - |
| [WithHash](type-aliases/WithHash.mdx) | - |
| [WithProvable](type-aliases/WithProvable.mdx) | - |
| [Witness](type-aliases/Witness.mdx) | - |
| [ZkProgram](type-aliases/ZkProgram.mdx) | - |
| [ZkappPublicInput](type-aliases/ZkappPublicInput.mdx) | The public input for zkApps consists of certain hashes of the proving |
| [Account](variables/Account.mdx) | - |
| [Bool](variables/Bool.mdx) | A boolean value. You can create it like this: |
| [Cache](variables/Cache.mdx) | - |
| [Crypto](variables/Crypto.mdx) | - |
| [Empty](variables/Empty.mdx) | - |
| [FeatureFlags](variables/FeatureFlags.mdx) | Feature flags indicate what custom gates are used in a proof of circuit. |
| [Field](variables/Field.mdx) | A [Field](variables/Field.mdx) is an element of a prime order [finite field](https://en.wikipedia.org/wiki/Finite_field). |
| [Gadgets](variables/Gadgets.mdx) | - |
| [Group](variables/Group.mdx) | An element of a Group. |
| [Hash](variables/Hash.mdx) | A collection of hash functions which can be used in provable code. |
| [Keccak](variables/Keccak.mdx) | - |
| [Permissions](variables/Permissions.mdx) | - |
| [Poseidon](variables/Poseidon.mdx) | - |
| [ProvableType](variables/ProvableType.mdx) | - |
| [TokenId](variables/TokenId.mdx) | - |
| [TransactionVersion](variables/TransactionVersion.mdx) | - |
| [TupleN](variables/TupleN.mdx) | - |
| [Undefined](variables/Undefined.mdx) | - |
| [Void](variables/Void.mdx) | - |
| [ZkappPublicInput](variables/ZkappPublicInput.mdx) | - |
| [emptyHash](variables/emptyHash.mdx) | - |
| [Bytes](functions/Bytes.mdx) | A provable type representing an array of bytes. |
| [ConstantField](functions/ConstantField.mdx) | - |
| [MerkleListBase](functions/MerkleListBase.mdx) | - |
| [MerkleWitness](functions/MerkleWitness.mdx) | Returns a circuit-compatible Witness for a specific Tree height. |
| [Option](functions/Option.mdx) | Define an optional version of a provable type. |
| [Reducer](functions/Reducer.mdx) | - |
| [State](functions/State.mdx) | - |
| [Struct](functions/Struct.mdx) | `Struct` lets you declare composite types for use in o1js circuits. |
| [VarField](functions/VarField.mdx) | - |
| [WithHash](functions/WithHash.mdx) | - |
| [ZkProgram](functions/ZkProgram.mdx) | - |
| [addCachedAccount](functions/addCachedAccount.mdx) | Adds an account to the local cache, indexed by a GraphQL endpoint. |
| [assert](functions/assert.mdx) | Assert that a statement is true. If the statement is false, throws an error with the given message. |
| [checkBitLength](functions/checkBitLength.mdx) | - |
| [checkZkappTransaction](functions/checkZkappTransaction.mdx) | - |
| [circuitMain](functions/circuitMain.mdx) | - |
| [conditionalSwap](functions/conditionalSwap.mdx) | - |
| [createEcdsa](functions/createEcdsa.mdx) | Create a class [EcdsaSignature](classes/EcdsaSignature.mdx) for verifying ECDSA signatures on the given curve. |
| [createForeignCurve](functions/createForeignCurve.mdx) | Create a class representing an elliptic curve group, which is different from the native [Group](classes/Group.mdx). |
| [createForeignField](functions/createForeignField.mdx) | Create a class representing a prime order finite field, which is different from the native [Field](classes/Field.mdx). |
| [declareMethods](functions/declareMethods.mdx) | `declareMethods` can be used in place of the `@method` decorator |
| [declareState](functions/declareState.mdx) | `declareState` can be used in place of the `@state` decorator to declare on-chain state on a SmartContract. |
| [fetchAccount](functions/fetchAccount.mdx) | Gets account information on the specified publicKey by performing a GraphQL query |
| [fetchEvents](functions/fetchEvents.mdx) | Asynchronously fetches event data for an account from the Mina Archive Node GraphQL API. |
| [fetchLastBlock](functions/fetchLastBlock.mdx) | Fetches the last block on the Mina network. |
| [fetchTransactionStatus](functions/fetchTransactionStatus.mdx) | Fetches the status of a transaction. |
| [genericHash](functions/genericHash.mdx) | - |
| [initializeBindings](functions/initializeBindings.mdx) | A function that has to finish before any bindings exports can be used. |
| [merkleListHash](functions/merkleListHash.mdx) | - |
| [method](functions/method.mdx) | A decorator to use in a zkApp to mark a method as provable. |
| [provable](functions/provable.mdx) | - |
| [provablePure](functions/provablePure.mdx) | - |
| [public\_](functions/public.mdx) | - |
| [readVarMessage](functions/readVarMessage.mdx) | - |
| [sendZkapp](functions/sendZkapp.mdx) | Sends a zkApp command (transaction) to the specified GraphQL endpoint. |
| [setArchiveGraphqlEndpoint](functions/setArchiveGraphqlEndpoint.mdx) | Sets up a GraphQL endpoint to be used for fetching information from an Archive Node. |
| [setGraphqlEndpoint](functions/setGraphqlEndpoint.mdx) | - |
| [setGraphqlEndpoints](functions/setGraphqlEndpoints.mdx) | - |
| [setNumberOfWorkers](functions/setNumberOfWorkers.mdx) | Set the number of workers to use for parallelizing the proof generation. By default the number of workers is set to the number of physical CPU cores on your machine, but there may be some instances where you want to set the number of workers manually. Some machines may have a large number of cores, but not enough memory to support that many workers. In that case, you can set the number of workers to a lower number to avoid running out of memory. On the other hand, some machines with heterogeneous cores may benefit from setting the number of workers to a lower number to avoid contention between core types if load-link/store-conditional multithreading is used. Feel free to experiment and see what works best for your use case. Maybe you can squeeze slightly more performance out by tweaking this value :) |
| [state](functions/state-1.mdx) | A decorator to use within a zkapp to indicate what will be stored on-chain. |
| [toConstantField](functions/toConstantField.mdx) | - |
| [toFp](functions/toFp.mdx) | - |
| [verify](functions/verify.mdx) | - |
| [withHashes](functions/withHashes.mdx) | - |
| [withMessage](functions/withMessage.mdx) | - |
