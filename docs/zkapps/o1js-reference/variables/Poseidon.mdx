```ts
const Poseidon: {
  "Sponge": typeof Sponge;
  "Unsafe": {
     "hashToGroup": Group;
    };
  "hash": Field;
  "hashPacked": Field;
  "hashToGroup": Group;
  "hashWithPrefix": Field;
  "initialState": [Field, Field, Field];
  "update": [Field, Field, Field];
};
```

## Type declaration

### Sponge

```ts
Sponge: typeof Sponge;
```

### Unsafe

```ts
Unsafe: {
  "hashToGroup": Group;
};
```

### Unsafe.hashToGroup()

Low-level version of `Poseidon.hashToGroup()`.

**Warning**: This function is marked unsafe because its output is not deterministic.
It returns the square root of a value without constraining which of the two possible
square roots is chosen. This allows the prover to choose between two different hashes,
which can be a vulnerability if consuming code treats the output as unique.

#### Parameters

• **input**: [`Field`](../classes/Field.mdx)[]

#### Returns

[`Group`](../classes/Group.mdx)

### hash()

#### Parameters

• **input**: [`Field`](../classes/Field.mdx)[]

#### Returns

[`Field`](../classes/Field.mdx)

### hashPacked()

Hashes a provable type efficiently.

```ts
let skHash = Poseidon.hashPacked(PrivateKey, secretKey);
```

Note: Instead of just doing `Poseidon.hash(value.toFields())`, this
uses the `toInput()` method on the provable type to pack the input into as few
field elements as possible. This saves constraints because packing has a much
lower per-field element cost than hashing.

#### Type parameters

• **T**

#### Parameters

• **type**: [`WithProvable`](../type-aliases/WithProvable.mdx)\<`Hashable`\<`T`\>\>

• **value**: `T`

#### Returns

[`Field`](../classes/Field.mdx)

### hashToGroup()

Hashes a list of field elements to a point on the Pallas curve.

The output point is deterministic and its discrete log is not efficiently computable.

#### Parameters

• **input**: [`Field`](../classes/Field.mdx)[]

#### Returns

[`Group`](../classes/Group.mdx)

### hashWithPrefix()

#### Parameters

• **prefix**: `string`

• **input**: [`Field`](../classes/Field.mdx)[]

#### Returns

[`Field`](../classes/Field.mdx)

### initialState()

#### Returns

[[`Field`](../classes/Field.mdx), [`Field`](../classes/Field.mdx), [`Field`](../classes/Field.mdx)]

### update()

#### Parameters

• **state**: [[`Field`](../classes/Field.mdx), [`Field`](../classes/Field.mdx), [`Field`](../classes/Field.mdx)]

• **input**: [`Field`](../classes/Field.mdx)[]

#### Returns

[[`Field`](../classes/Field.mdx), [`Field`](../classes/Field.mdx), [`Field`](../classes/Field.mdx)]

## Source

[lib/provable/crypto/poseidon.ts:56](https://github.com/o1-labs/o1js/blob/6ebbc23710f6de023fea6d83dc93c5a914c571f2/src/lib/provable/crypto/poseidon.ts#L56)
