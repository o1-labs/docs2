```ts
const Hash: {
  "BLAKE2B": {
     "hash": Bytes;
    };
  "Keccak256": {
     "hash": Bytes;
    };
  "Keccak384": {
     "hash": Bytes;
    };
  "Keccak512": {
     "hash": Bytes;
    };
  "Poseidon": {
     "Sponge": typeof Sponge;
     "Unsafe": {
        "hashToGroup": Group;
       };
     "hash": Field;
     "hashPacked": Field;
     "hashToGroup": Group;
     "hashWithPrefix": Field;
     "initialState": [Field, Field, Field];
     "update": [Field, Field, Field];
    };
  "SHA2_256": {
     "hash": Gadgets.SHA256.hash;
    };
  "SHA3_256": {
     "hash": Bytes;
    };
  "SHA3_384": {
     "hash": Bytes;
    };
  "SHA3_512": {
     "hash": Bytes;
    };
  "hash": Poseidon.hash;
};
```

A collection of hash functions which can be used in provable code.

## Type declaration

### BLAKE2B

```ts
BLAKE2B: {
  "hash": Bytes;
};
```

### BLAKE2B.hash()

#### Parameters

• **bytes**: `Bytes`

#### Returns

`Bytes`

### Keccak256

```ts
Keccak256: {
  "hash": Bytes;
};
```

The pre-NIST Keccak hash function with an output length of 256 bits.

### Keccak256.hash()

Hashes the given bytes using Keccak-256.

This is an alias for `Keccak.preNist(256, bytes)`.\
See Keccak.preNist for details and usage examples.

#### Parameters

• **bytes**: `Bytes`

#### Returns

`Bytes`

### Keccak384

```ts
Keccak384: {
  "hash": Bytes;
};
```

The pre-NIST Keccak hash function with an output length of 384 bits.

### Keccak384.hash()

Hashes the given bytes using Keccak-384.

This is an alias for `Keccak.preNist(384, bytes)`.\
See Keccak.preNist for details and usage examples.

#### Parameters

• **bytes**: `Bytes`

#### Returns

`Bytes`

### Keccak512

```ts
Keccak512: {
  "hash": Bytes;
};
```

The pre-NIST Keccak hash function with an output length of 512 bits.

### Keccak512.hash()

Hashes the given bytes using Keccak-512.

This is an alias for `Keccak.preNist(512, bytes)`.\
See Keccak.preNist for details and usage examples.

#### Parameters

• **bytes**: `Bytes`

#### Returns

`Bytes`

### Poseidon

```ts
Poseidon: {
  "Sponge": typeof Sponge;
  "Unsafe": {
     "hashToGroup": Group;
    };
  "hash": Field;
  "hashPacked": Field;
  "hashToGroup": Group;
  "hashWithPrefix": Field;
  "initialState": [Field, Field, Field];
  "update": [Field, Field, Field];
};
```

### Poseidon.Sponge

```ts
Sponge: typeof Sponge;
```

### Poseidon.Unsafe

```ts
Unsafe: {
  "hashToGroup": Group;
};
```

### Poseidon.Unsafe.hashToGroup()

Low-level version of `Poseidon.hashToGroup()`.

**Warning**: This function is marked unsafe because its output is not deterministic.
It returns the square root of a value without constraining which of the two possible
square roots is chosen. This allows the prover to choose between two different hashes,
which can be a vulnerability if consuming code treats the output as unique.

#### Parameters

• **input**: [`Field`](../classes/Field.mdx)[]

#### Returns

[`Group`](../classes/Group.mdx)

### Poseidon.hash()

#### Parameters

• **input**: [`Field`](../classes/Field.mdx)[]

#### Returns

[`Field`](../classes/Field.mdx)

### Poseidon.hashPacked()

Hashes a provable type efficiently.

```ts
let skHash = Poseidon.hashPacked(PrivateKey, secretKey);
```

Note: Instead of just doing `Poseidon.hash(value.toFields())`, this
uses the `toInput()` method on the provable type to pack the input into as few
field elements as possible. This saves constraints because packing has a much
lower per-field element cost than hashing.

#### Type parameters

• **T**

#### Parameters

• **type**: [`WithProvable`](../type-aliases/WithProvable.mdx)\<`Hashable`\<`T`\>\>

• **value**: `T`

#### Returns

[`Field`](../classes/Field.mdx)

### Poseidon.hashToGroup()

Hashes a list of field elements to a point on the Pallas curve.

The output point is deterministic and its discrete log is not efficiently computable.

#### Parameters

• **input**: [`Field`](../classes/Field.mdx)[]

#### Returns

[`Group`](../classes/Group.mdx)

### Poseidon.hashWithPrefix()

#### Parameters

• **prefix**: `string`

• **input**: [`Field`](../classes/Field.mdx)[]

#### Returns

[`Field`](../classes/Field.mdx)

### Poseidon.initialState()

#### Returns

[[`Field`](../classes/Field.mdx), [`Field`](../classes/Field.mdx), [`Field`](../classes/Field.mdx)]

### Poseidon.update()

#### Parameters

• **state**: [[`Field`](../classes/Field.mdx), [`Field`](../classes/Field.mdx), [`Field`](../classes/Field.mdx)]

• **input**: [`Field`](../classes/Field.mdx)[]

#### Returns

[[`Field`](../classes/Field.mdx), [`Field`](../classes/Field.mdx), [`Field`](../classes/Field.mdx)]

### SHA2\_256

```ts
SHA2_256: {
  "hash": Gadgets.SHA256.hash;
};
```

The SHA2 hash function with an output length of 256 bits.

### SHA2\_256.hash()

```ts
hash: (data: FlexibleBytes) => Bytes = Gadgets.SHA256.hash;
```

Hashes the given bytes using SHA2-256.

This is an alias for `Gadgets.SHA256.hash(bytes)`.\
See Gadgets.SHA256.hash for details and usage examples.

#### Parameters

• **data**: `FlexibleBytes`

#### Returns

`Bytes`

### SHA3\_256

```ts
SHA3_256: {
  "hash": Bytes;
};
```

The SHA3 hash function with an output length of 256 bits.

### SHA3\_256.hash()

Hashes the given bytes using SHA3-256.

This is an alias for `Keccak.nistSha3(256, bytes)`.\
See Keccak.nistSha3 for details and usage examples.

#### Parameters

• **bytes**: `Bytes`

#### Returns

`Bytes`

### SHA3\_384

```ts
SHA3_384: {
  "hash": Bytes;
};
```

The SHA3 hash function with an output length of 384 bits.

### SHA3\_384.hash()

Hashes the given bytes using SHA3-384.

This is an alias for `Keccak.nistSha3(384, bytes)`.\
See Keccak.nistSha3 for details and usage examples.

#### Parameters

• **bytes**: `Bytes`

#### Returns

`Bytes`

### SHA3\_512

```ts
SHA3_512: {
  "hash": Bytes;
};
```

The SHA3 hash function with an output length of 512 bits.

### SHA3\_512.hash()

Hashes the given bytes using SHA3-512.

This is an alias for `Keccak.nistSha3(512, bytes)`.\
See Keccak.nistSha3 for details and usage examples.

#### Parameters

• **bytes**: `Bytes`

#### Returns

`Bytes`

### hash()

```ts
hash: (input: Field[]) => Field = Poseidon.hash;
```

Hashes the given field elements using [Poseidon](https://eprint.iacr.org/2019/458.pdf). Alias for `Poseidon.hash()`.

```ts
let hash = Hash.hash([a, b, c]);
```

**Important:** This is by far the most efficient hash function o1js has available in provable code.
Use it by default, if no compatibility concerns require you to use a different hash function.

The Poseidon implementation operates over the native [Pallas base field](https://electriccoin.co/blog/the-pasta-curves-for-halo-2-and-beyond/)
and uses parameters generated specifically for the [Mina](https://minaprotocol.com) blockchain.

We use a `rate` of 2, which means that 2 field elements are hashed per permutation.
A permutation causes 11 rows in the constraint system.

You can find the full set of Poseidon parameters [here](https://github.com/o1-labs/o1js-bindings/blob/main/crypto/constants.ts).

#### Parameters

• **input**: [`Field`](../classes/Field.mdx)[]

#### Returns

[`Field`](../classes/Field.mdx)

## Source

[lib/provable/crypto/hash.ts:11](https://github.com/o1-labs/o1js/blob/6ebbc23710f6de023fea6d83dc93c5a914c571f2/src/lib/provable/crypto/hash.ts#L11)
