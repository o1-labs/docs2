---
title: FAQ
---

## Does SnarkyJS compile my JavaScript code to an arithmetic circuit?

No, SnarkyJS **does NOT compile into anything else**. In contrast to other zk ecosystems, SnarkyJS is just a JS library. It creates zk circuits from user code by _executing_ that code. If you have a smart contract with a `@method myMethod()`, for example, we will simply call `myMethod();` during proof generation.

This works because SnarkyJS sets up some global state - a "circuit" - where it collects variables and constraints. The use of functions like `Field.mul` or `Bool.assertEquals` inside your smart contract methods will add corresponding variables and constraints to the global circuit.

This has some implications:

- In order to turn your logic into a proof, you'll need to use SnarkyJS built-in datatypes such as `Field`. You'll also need to use the SnarkyJS functions that operate on them, like `Field.mul()`.
  - A statement like `x.mul(y)` will add a generic PLONK gate to your circuit. It will also return a variable that you can use in further statements, which will get wired to the multiplication gate.
  - Some SnarkyJS functions allow you to turn normal JS datatypes into `Field` elements and back, such as `Encoding.stringToFields()`. These functions don't add anything to your circuit. They will typically clarify this in a doc-comment.
- Conventional JS code such as `'hello world'.split('').join(' ')` that doesn't use SnarkyJS built-ins will not be included in your zk proof in any way since it will not add anything to your circuit.
  - Why? Because it doesn't call any of the functions that build the circuit.
  - There's nothing wrong with having non-circuit code like the above inside your method, as long as you're aware of what it's (not) doing.
- It's fine to use if-statements, for-loops, arrays, objects, and any other JS language constructs, to facilitate writing circuits. But beware: these flexible constructs don't allow you to overcome the static nature of circuits.

Let's look at some examples. Here we assert that a Field element `x` is not equal to `5`, `10` or `15`:

```ts
// good
for (let y of [5, 10, 15]) {
  x.equals(y).assertFalse();
}
```

The for-loop above just stitches together a fixed number of SnarkyJS commands, which is fine. However, the following snippet, where the loop's length is determined from user input, won't work:

```ts
// bad
@method myMethod(x: Field, n: Field) {
  let n0 = Number(n.toString()); // nope
  for (let y = 0; y < n0; y += 5) {
    x.equals(y).assertFalse();
  }
}
```

This example fails for two reasons:

1. `n.toString()` can't be used in circuit code at all - it will throw an error during `SmartContract.compile()`. This is because during `compile()`, variables like `n` don't have any JS values attached to them; they represent abstract variables used to build up an abstract arithmetic circuit. So, in general, you can't use any of the methods that read out the JS value of your Field elements: `Field.toString()`, `Field.toBigInt()`, `Bool.toBoolean()` etc.
2. More subtly, your methods must create the same constraints every time because a proof cannot be verified against a verification key for a differing set of constraints. The code above adds `x.equals(y).assertFalse()` _on condition of_ the value of `n`. This would lead to constraints varying between executions of the proof.


---
title: How to Deploy a zkApp
hide_title: true
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but zkApps can now be deployed to Berkeley Testnet.

:::

# How to Deploy a zkApp

## Add a deploy alias to config.json

Before deploying, we must first define a few settings, such as which network we are deploying to. We do this by creating a "deploy alias" within your smart contract project's
`config.json`.

First, change into the directory containing your smart contract and then run the
following command:

```sh
zk config
```

It will ask you to specify a name (can be anything), URL to deploy to, & fee (in
MINA) to be used when sending your deploy transaction. The URL is the Mina GraphQL API
that will receive your deploy transaction and broadcast it to the Mina network.
Note that this URL is significant because it also determines which network you're
be deploying to (e.g. QANet, Testnet, Mainnet, etc).

For Berkeley Testnet, let's use the following values:

- **Name**: `berkeley`
- **URL**: `https://proxy.berkeley.minaexplorer.com/graphql` or `https://berkeley.minascan.io/graphql`
- **Fee**: `0.1`

:::tip
  If your project contains multiple smart contracts (e.g. `Foo` and `Bar`) that
  you intend to deploy to the same network, we recommend following a naming
  pattern such as `berkeley-foo` and `berkeley-bar` when naming your deploy
  aliases. You can change their names at anytime within `config.json`.
:::

<br/>

You will see the following output:

```sh
$ zk config

Add a new network:
âœ” Choose a name (can be anything): Â· berkeley
âœ” Set URL to deploy to: Â· https://proxy.berkeley.minaexplorer.com/graphql
âœ” Set transaction fee to use when deploying (in MINA): Â· 0.1
âœ” Create key pair at keys/berkeley.json
âœ” Add network to config.json

Success!

Next steps:

- If this is a testnet, request tMINA at:
  https://faucet.minaprotocol.com/?address=<YOUR-ADDRESS>
- To deploy, run: `zk deploy berkeley`
```

## Request funds from the faucet

To deploy your zkApp, you will need some funds to pay for transaction fees.

To get funds on the Berkeley Testnet, use the URL that was shown from the CLI output. Visit `https://faucet.minaprotocol.com/?address=<YOUR-ADDRESS>` and click **Request**.

You will have to wait a few minutes for the next block to include your transaction, so you'll have tMINA before proceeding to the next step.

## Deploy your smart contract

To deploy your smart contract to the network, run the following command:

```sh
zk deploy berkeley
```

When running the deploy command, the zkApp CLI will compute a verification key for your zkApp CLI. Computing the verification key can take 1-2 minutes, so please be patient. The zkApp CLI will show you the details of the transaction such as the network name, the URL, and the smart contract that will be deployed..

Finally, enter `yes` or `y` when prompted, to confirm and send the transaction.

You will see the following output:

```sh
$ zk deploy berkeley
âœ” Build project
âœ” Generate build.json
âœ” Choose smart contract
  Only one smart contract exists in the project: Add
  Your config.json was updated to always use this
  smart contract when deploying to this network.
âœ” Generate verification key (takes 1-2 min)
âœ” Build transaction
âœ” Confirm to send transaction
  Are you sure you want to send (yes/no)? Â· y
âœ” Send to network

Success! Deploy transaction sent.

Next step:
  Your smart contract will be live (or updated)
  as soon as the transaction is included in a block:
  https://berkeley.minaexplorer.com/transaction/<txn-hash>
```

After a few minutes, the transaction will be included in the next block. To see your changes, search for the address that you used on [berkeley.minaexplorer.com](https://berkeley.minaexplorer.com).

## Next Steps

Now that you've learn how to deploy a smart contract, you can now learn [how to write a UI for your zkApp](how-to-write-a-zkapp-ui).


---
title: How to Test a zkApp
hide_title: true
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

# How to Test a zkApp

Writing automated tests for your smart contract is of crucial importance. The <a href="https://jestjs.io/">Jest testing framework</a> is included in all projects created by the Mina zkApp CLI via `zk project <name>` and `zk example <name`. We recommend Jest, but any testing framework can be used.

## Running tests

To run all test files within your project, run `npm run test` or `npm run testw` (for watch mode) from your projectâ€™s root directory.

To generate a test coverage report for your project, run `npm run coverage`. Coverage reports show the % of your code that is tested. The result will be output in your terminal. This can be helpful to ensure your code is well tested.

## Writing tests

Creating tests for your smart contract is easy using the Mina zkApp CLI. To scaffold a TypeScript file with a corresponding test file, simply run the command `zk file foo`. This will generate two files, named `foo.ts` and `foo.test.ts`. `foo.test.ts` is a great place to start writing all your smart contract test code. To write good unit tests, it's vital that you concretely understand the functionality your smart contract provides. An example is shown below of a basic test written in Jest:

```ts
describe('foo.test.ts', () => {
  describe('test()', () => {
    // your test here
  });
});
```

Because we are using Jest, it's helpful to break down all functionality of your smart contract into `describe` blocks. Mapping out your unit tests like this is also a good way of providing documentation to other developers reading your smart contract. An excellent place to start testing your smart contract is in the areas your smart contract modifies its state. Make sure to verify that your state updates in the way you expect.

For examples of existing tests, we recommend creating a template example using the Mina zkApp CLI via `zk project <name>` and examining the test file there. [You will see a basic example of a few tests](https://github.com/o1-labs/zkapp-cli/blob/main/templates/project-ts/src/Add.test.ts) that deploy and update the state on a smart contract using Jest.

#### Creating a local blockchain

It's helpful to run your smart contract locally on a mock blockchain to quickly test it.
The `Mina.LocalBlockchain()` method specifies a mock Mina ledger of accounts that runs locally on your machine. It contains logic for updating the ledger that can be used to test your smart contract.

:::tip

`Mina.LocalBlockchain()` takes an optional parameter `{ proofsEnabled: true }` with default value `true`, which lets you specify whether or not you want to generate and verify proofs.
If you set `proofsEnabled: false`, the local instance will behave exactly the same as before, but it won't generate proofs or verify them.
This can be very useful when you want to run tests in the CI or quickly debug your smart contract without having to wait for proofs to be generated.

You can also programmatically enable and disable the `proofsEnabled` flag within your test flow by calling `Local.setProofsEnabled(x: boolean)`.
:::

```ts
let Local = Mina.LocalBlockchain();
Mina.setActiveInstance(Local);
```

#### Deploying a contract locally

The mock Mina local blockchain contains test accounts that can be used to deploy smart contracts and pay transaction fees.

First, access a test account provided by the local blockchain.

```ts
// Local.testAccounts is an array of 10 test accounts that have been pre-filled with Mina
let feePayer = Local.testAccounts[0].privateKey;
```

Next, generate a zkApp account and a new instance of the smart contract to deploy locally for testing.

```ts
// zkapp account
let zkAppPrivateKey = PrivateKey.random();
let zkAppAddress = zkAppPrivateKey.toPublicKey();
let zkAppInstance = new Add(zkAppAddress);
```

Then, use the test account and zkApp keys to construct a transaction to pay account creation fees and deploy your smart contract. This transaction is sent to the local blockchain.

```ts
let txn = await Mina.transaction(feePayer, () => {
  Party.fundNewAccount(feePayer);
  zkAppInstance.deploy({ zkappKey: zkAppPrivateKey });
});

const txPromise = await  txn.send();
/*
`txn.send()` returns a promise with two closures - `.wait()` and `.hash()`
`.hash()` returns the transaction hash, as the name might indicate
`.wait()` automatically resolves once the transaction has been included in a block. this is redundant for the LocalBlockchain, but very helpful for live testnets
*/

await txPromise.wait();

```

#### Writing integration tests

Jest can be used to write both unit and integration tests. A well written integration test tests the flow of your smart contracts expected behavior, and verifies correctness of state updates. After you test the expected behavior, it's benifical to verify the preconditions of your methods and test edge cases of your smart contract. Below is an example of a basic integration test script.

```ts
describe('Add smart contract integration test', () => {
  let feePayer: PrivateKey,
    zkAppAddress: PublicKey,
    zkAppPrivateKey: PrivateKey,
    zkAppInstance: Add,
    currentState: Field,
    txn;

  beforeAll(async () => {
    await isReady;
    // setup local blockchain
    let Local = Mina.LocalBlockchain();
    Mina.setActiveInstance(Local);

    // Local.testAccounts is an array of 10 test accounts that have been pre-filled with Mina
    feePayer = Local.testAccounts[0].privateKey;

    // zkapp account
    zkAppPrivateKey = PrivateKey.random();
    zkAppAddress = zkAppPrivateKey.toPublicKey();
    zkAppInstance = new Add(zkAppAddress);

    // deploy zkapp
    txn = await Mina.transaction(feePayer, () => {
      Party.fundNewAccount(feePayer);
      zkAppInstance.deploy({ zkappKey: zkAppPrivateKey });
    });
    await txn.send();
  });

  afterAll(async () => {
    setTimeout(shutdown, 0);
  });

  it('sets intitial state of num to 1', async () => {
    currentState = zkAppInstance.num.get();
    expect(currentState).toEqual(Field(1));
  });

  it('correctly updates num from intial state to 3', async () => {
    txn = await Mina.transaction(feePayer, () => {
      zkAppInstance.update();
      zkAppInstance.sign(zkAppPrivateKey);
    });
    txn.send();

    currentState = zkAppInstance.num.get();
    expect(currentState).toEqual(Field(3));
  });
});
```

## Learn more

Please see the <a href="https://jestjs.io/docs/getting-started">Jest docs</a> for further information on how to use Jest.

We will be adding blockchain-specific testing functionality in the future. Keep an eye on this section for updates.

## Next Steps

Now that you've learn how to test a smart contract, you can now learn [how to deploy a zkApp](how-to-deploy-a-zkapp).


---
title: How to Write a zkApp UI
hide_title: true
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

# How to Write a zkApp UI

To allow users to interact with your smart contract, youâ€™ll typically want to build a website UI.

This UI can be written with any framework (e.g. React, Vue, Svelte, etc.) or plain HTML and JavaScript.

## Using one of the provided UI framework scaffolds

When creating a new project with the zkApp CLI, you can directly choose one of three frameworks to be scaffolded as a part of your new zkApp project.
At the moment, we support NuxtJS, Svelte Kit and NextJS. 

You can do so by adding the `--ui=<framework>` flag to the `zk project <myproj>` command: `zk project <myproj> --ui=<framework>`, where `<framework>` stands for one of the three currently supported frameworks `nuxt`, `svelte` and `next`.

## Adding your smart contract as a dependency of the UI

If you want to use one of the scaffolding options that we provide and you want to add your smart contract to an already existing frontend, a different UI framework or simply a plain HTML and JavaScript website, you can do so as well. 


#### Setup

The `index.ts` file is the entry point of your project. This file only imports all smart contract classes you want access to, and exports them. This pattern allows you to specify which smart contracts are available to import when consuming your project from npm within your UI.

```ts
import { YourSmartContract } from './YourSmartContract.js';

export { YourSmartContract };
```

#### Local development

The `npm link` command allows to use your smart contract within your UI project during local development without needing to publish it npm. This allows for rapid development.

1. Using a command line, change into your smart contract project directory using `cd <your-project>`, type `npm link`, and hit enter.
2. Using a command line, change into your UI project directory using `cd <your-ui-project>`, type `npm link <your-package-name>`, and hit enter. `your-package-name` is the `name` property used within your _smart contract's_ `package.json`.
3. Import into your UI project like normal, using `import { YourSmartContract } from â€˜your-package-nameâ€™;`.

Remember to run `npm run build` in your smart contract directory after making any changes in order for changes to be reflected in the smart contract consumed by your UI project.

:::tip

For additional details about `npm link`, see the full npm <a href="https://docs.npmjs.com/cli/v8/commands/npm-link">reference docs</a>.

:::

#### Publish to npm for production

1. **Create an npm account:** Create one <a href="https://www.npmjs.com/signup">here</a> if you don't have one yet.
2. **Login:** To sign in, enter `npm login` on the command line. You will be prompted to enter your username, password, and email address.
3. **Publish:** To publish your package, enter `npm publish` on the command line at the root of your smart contract project directory. If the package name already exists on npm, you will get an error. You can change the package name by changing the name property in your `package.json`.

:::tip

You can check if a package name already exists on npm using the <a href="https://docs.npmjs.com/cli/v7/commands/npm-search">npm search</a>
terminal command. To avoid naming collisions, npm allows to publish scoped packages:
`@your-username/your-package-name`. For additional details about publishing packages including scoped packages, see the full npm <a href="https://docs.npmjs.com/packages-and-modules/introduction-to-packages-and-modules">reference docs</a>.

:::

#### Consuming your smart contract in your UI

Once you have published your smart contract to npm, you can easily add it to any UI framework of your choosing by importing the package.

1. **Install your smart contract package:** To install your package, run the following npm command: `npm install your-package-name` from the root of your UI project directory. Or if you published a scoped npm package, run `npm install @your-username/your-project-name`.
2. **Import your smart contract package into the UI using:** `import { YourSmartContract } from â€˜your-package-nameâ€™;` , where `YourSmartContract` is the named export that you chose in your smart contract.

:::tip

For a more performant UI, you may want to render your UI before importing and loading your smart contract. This allows the SnarkyJS wasm workers to perform initialization without blocking the UI.

For example, if your UI is built using React, loading the smart contract in a `useEffect`,
instead of a top level import, will give the UI time to render its components before
loading SnarkyJS.

:::

**Loading your contract with React**

```ts
useEffect(() => {
  (async () => {
    const { YourSmartContract } = await import('your-package-name');
  })();
}, []);
```

**Loading your contract with Svelte**

```ts
onMount(async () => {
  const { YourSmartContract } = await import('your-package-name');
});
```

**Loading your contract with Vue**

```ts
onMounted(async () => {
  const { YourSmartContract } = await import('your-package-name');
});
```

#### Enabling COOP and COEP headers

To load SnarkyJS code in your UI, you must set the [COOP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy)
and [COEP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy) headers as described below. These enable SnarkyJS' use of [SharedArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer), which SnarkyJS relies on to enable important WebAssembly features.

- `Cross-Origin-Opener-Policy` must be set to `same-origin`.
- `Cross-Origin-Embedder-Policy` must be set to `require-corp`.

You can enable these headers a number of different ways. If you deploy your UI to a host such as [Vercel](https://vercel.com/) or [Cloudflare Pages](https://pages.cloudflare.com/), you can set these headers in a custom configuration file (see below). Otherwise, you can set these headers in the server framework of your choice (e.g. Express for JavaScript).

**Vercel**

If your app will be hosted on Vercel, you can set these headers via [`vercel.json`](https://vercel.com/docs/project-configuration).

```json
{
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        { "key": "Cross-Origin-Opener-Policy", "value": "same-origin" },
        { "key": "Cross-Origin-Embedder-Policy", "value": "require-corp" }
      ]
    }
  ]
}
```

**Cloudflare Pages**

If your app will be hosted on Cloudflare Pages, you can set these headers via a [`_headers` file](https://developers.cloudflare.com/pages/platform/headers/).

```
/*
  Cross-Origin-Opener-Policy: same-origin
  Cross-Origin-Embedder-Policy: require-corp
```

### Connecting your zkApp with a user's wallet

:::info

Currently, only Auro Wallet's Chrome extension supports zkApp transactions. We
anticipate other wallets to add support over time, which they can do by using
the <a
href="https://www.npmjs.com/package/@aurowallet/mina-provider">`mina-provider`</a>
from NPM within their browser-extension wallet.

:::

1. Install <a
   href="https://chrome.google.com/webstore/detail/auro-walletmina-protocol/cnmamaachppnkjgnildpdmkaakejnhae">Auro
   Wallet for Chrome</a>. Users of your zkApp will need to have this wallet
   installed in order to interact with your zkApp. Once installed, `window.mina`
   will automatically become available in the user's browser environment. Your
   zkApp will then use this object to interact with the wallet.

2. Get accounts - To fetch a user's list of Mina accounts, you can use the
   `requestAccounts()` method. It can be useful to indicate if the user's wallet is successfully connected to your zkApp, such as in the screenshot below.

```ts
let accounts;

try {
  // Accounts is an array of string Mina addresses.
  accounts = await window.mina.requestAccounts();

  // Show first 6 and last 4 characters of user's Mina account.
  const display = `${accounts[0].slice(0, 6)}...${accounts[0].slice(-4)}`;
} catch (err) {
  // If the user has a wallet installed but has not created an account, an
  // exception will be thrown. Consider showing "not connected" in your UI.
  console.log(err.message);
}
```

<img src={require('@site/static/img/Mina_Provider_Header.png').default} />

3. Sending a transaction - After your user interacts with your zkApp, you can
   sign and send the transaction using `sendTransaction()`. You will receive a transaction ID as soon as the Mina network has received the
   proposed transaction. But keep in mind that this does not guarantee that
   the network will accept the transaction into an upcoming block.

```ts
try {
  // This is the public key of the deployed zkapp you want to interact with.
  const zkAppAddress = 'B62qq8sm7JdsED6VuDKNWKLAi1Tvz1jrnffuud5gXMq3mgtd';

  const tx = await Mina.transaction(() => {
    const YourSmartContractInstance = new YourSmartContract(zkAppAddress);
    YourSmartContractInstance.foo();
  });

  await tx.prove();

  const { hash } = await window.mina.sendTransaction({
    transaction: tx.toJSON(),
    feePayer: {
      fee: '',
      memo: 'zk',
    },
  });

  console.log(hash);
} catch (err) {
  // You may want to show the error message in your UI to the user if the transaction fails.
  console.log(err.message);
}
```

:::tip

If an error occurs when sending the transaction, you may want to show the error
message in your UI to the user.

:::

:::info

For additional details about the Mina Provider, see the full <a
href="https://docs.aurowallet.com/general/reference/api-reference/mina-provider-api
">reference docs</a>.

:::

### Displaying assertion exceptions in your UI

If an assertion exception occurs while a user interacts with any of your smart contract methods, you will want to capture this and display a helpful message for the user in your UI.

1. Use a try-catch statement to catch exceptions when a user invokes a method on your smart contract.
2. Use a switch-case statement to identify which exception was thrown. You will want a matching case for each unique assertion within your method. To assist with this, you may consider setting custom error messages for your assertions while writing the smart contract--for example: `INSUFFICIENT_BALANCE`.
3. Display a helpful error message for the user within your UI.

```ts
try {
  YourSmartContract.yourMethod();
} catch (err) {
  let uiErrorMessage;
  switch (err.message) {
    // A custom error thrown within YourSmartContract.yourMethod()
    // when there is an insufficient balance.
    case 'INSUFFICIENT_BALANCE':
      // Set a helpful message to show the user in the UI.
      uiErrorMessage =
        'Your account has an insufficient balance for this transaction';
      break;
    // etc
  }
}
```


---
title: How to Write a zkApp
hide_title: true
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

# How to Write a zkApp

A zkApp consists of a smart contract and a UI to interact with it. First, weâ€™ll install the Mina zkApp CLI and write a smart contract.

## Write a smart contract

Your smart contract will be written using [Mina zkApp CLI](https://www.npmjs.com/package/zkapp-cli/).

Mina zkApp CLI makes it easy to follow recommended best practices by providing project scaffolding including dependencies such as SnarkyJS, a test framework (<a href="https://jestjs.io/">Jest</a>), code auto-formatting (<a href="https://prettier.io/
">Prettier</a>), linting (<a href="https://eslint.org/">ES Lint</a>), & more.

### Install Mina zkApp CLI

```sh
npm install -g zkapp-cli
```

#### Dependencies:

- NodeJS 16+ (or 14 using `node --experimental-wasm-threads`)
- NPM 6+
- Git 2+

:::tip

If you have an older version installed, we suggest installing a newer version using the package manager for your system: <a href="https://brew.sh/">Homebrew</a> (Mac), <a href="https://chocolatey.org/">Chocolatey</a> (Windows), or apt/yum/etc (Linux). On Linux, you may need to install a recent NodeJS version via NodeSource (<a href="https://github.com/nodesource/distributions#debinstall">deb</a> or <a href="https://github.com/nodesource/distributions#rpminstall">rpm</a>), as recommended by the NodeJS Project.

:::

### Start a project

Now that you have Mina zkApp CLI installed, you can start with an example or start your own project.

#### Option A: Start with an example (recommended)

Examples are based on the standard project structure, but with additional files in the `/src` directory as the only difference.

1. **Install:** Run `zk example sudoku`. This creates a new project and includes
   the example files (i.e. the smart contract) inside the projectâ€™s `src/`
   directory. Type `ls` & hit enter to see the files that were created or open
   the directory in a code editor such as VS Code.
2. **Run tests:** Run `npm run test`. Tests are written using <a
   href="https://jestjs.io/">Jest</a>. After running this command, you should
   see all tests pass. You can also run `npm run testw` to run tests in watch
   mode, so it will automatically re-run tests when saving changes to your code.
3. **Build the example:** Run `npm run build`. This will compile your TypeScript
   into JavaScript inside the projectâ€™s `/build` directory.
4. **Deploy to Testnet:** Run `zk config`, which will walk you through adding a
   network alias to your projectâ€™s `config.json`. For Berkeley Testnet, we recommend
   using `berkeley` as the name, `0.1` for the fee, and
   `https://proxy.berkeley.minaexplorer.com/graphql` for the url. Then run `zk deploy` and follow the prompts. See the [how to deploy a zkApp](how-to-deploy-a-zkapp) page for further details.

You can view a list of <a href="https://github.com/o1-labs/zkapp-cli/tree/main/examples/">all available examples here</a>.

#### Option B: Start your own project

1. **Install:** Run `zk project <myproj>`. Type `ls` and hit enter to see the
   newly created project structure. _Note_: If you want to directly scaffold an UI with your new zkApp, you can do so by adding the `--ui` flag to the previous command, like `zk project <myproj> --ui=<framework>`. You can currently choose from the following frameworks: `svelte`, `next` or `nuxt` 
2. **Run tests:** Run `npm run test`. Tests are written using <a
   href="https://jestjs.io/">Jest</a>. After running this command, you should
   see all tests pass. You can also run `npm run testw` to run tests in watch
   mode, so it will automatically re-run tests when saving changes to your code.
3. **Build:** Run `npm run build`. This will compile your TypeScript code into
   JavaScript inside the projectâ€™s `/build`.
4. **Deploy to Testnet:** Run `zk config`, which will walk you through adding a
   network alias to your projectâ€™s `config.json`. For Berkeley Testnet, we
   recommend using `berkeley` as the name, `0.1` for the fee, and
   `https://proxy.berkeley.minaexplorer.com/graphql` for the url. Then run `zk deploy` and follow the prompts. See the [how to deploy a zkApp](how-to-deploy-a-zkapp) page for further details.
5. **Deploy to Mainnet:** (Coming soon.)

### Writing your smart contract

The goal of this section is to explain the concepts that you will need to understand to write a zero-knowledge-based smart contract.

If you havenâ€™t yet read the [how zkApps work](how-zkapps-work) pages, please read it first so that this section makes sense.

##### SnarkyJS

zkApps are written in TypeScript using SnarkyJS. SnarkyJS is a TypeScript library for writing smart contracts based on zero-knowledge proofs for the Mina Protocol. It is included automatically when creating a new project using the Mina zkApp CLI.

To view the full SnarkyJS reference, please see the [snarkyJS reference](snarkyjs-reference).

##### Concepts

Field elements are the basic unit of data in zero-knowledge proof programming. Each field element can store a number up to almost 256 bits in size. You can think of it as a uint256 in Solidity.

:::note

For the cryptography inclined, the exact max value that a field can store is: 28,948,022,309,329,048,855,892,746,252,171,976,963,363,056,481,941,560,715,954,676,764,349,967,630,336

:::

For example, in typical programming, you might use:

`const sum = 1 + 3`.

In SnarkyJS, you would write this as:

`const sum = new Field(1).add(new Field(3))`

This can be simplified as:

`const sum = new Field(1).add(3)`

Note that the 3 is auto-promoted to a field type to make this cleaner.

##### Built-in data types

Some common data types you may use are:

<!-- prettier-ignore -->
```ts
new Bool(x);   // accepts true or false
new Field(x);  // accepts an integer, or a numeric string if you want to represent a number greater than JavaScript can represent but within the max value that a field can store.
new UInt64(x); // accepts a Field - useful for constraining numbers to 64 bits
new UInt32(x); // accepts a Field - useful for constraining numbers to 32 bits

PrivateKey, PublicKey, Signature; // useful for accounts and signing
new Group(x, y); // a point on our elliptic curve, accepts two Fields/numbers/strings
Scalar; // the corresponding scalar field (different than Field)

CircuitString.from('some string'); // string of max length 128
```

In the case of `Field` and `Bool`, you can also call the constructor without `new`:

```ts
let x = Field(10);
let b = Bool(true);
```

##### Conditionals

Traditional conditional statements are not yet supported by SnarkyJS:

```ts
// this will NOT work
if (foo) {
  x.assertEquals(y);
}
```

Instead, use SnarkyJSâ€™ built-in `Circuit.if()` method, which is a ternary operator:

```ts
const x = Circuit.if(new Bool(foo), a, b); // behaves like `foo ? a : b`
```

##### Functions

Functions work as you would expect in TypeScript. For example:

```ts
function addOneAndDouble(x: Field): Field {
  return x.add(1).mul(2);
}
```

##### Common methods

Some common methods you will use often are:

```ts
let x = new Field(4); // x = 4
x = x.add(3); // x = 7
x = x.sub(1); // x = 6
x = x.mul(3); // x = 18
x = x.div(2); // x = 9
x = x.square(); // x = 81
x = x.sqrt(); // x = 9

let b = x.equals(8); // b = Bool(false)
b = x.greaterThan(8); // b = Bool(true)
b = b.not().or(b).and(b); // b = Bool(true)
b.toBoolean(); // true

let hash = Poseidon.hash([x]); // takes array of Fields, returns Field

let privKey = PrivateKey.random(); // create a private key
let pubKey = PublicKey.fromPrivateKey(privKey); // derive public key
let msg = [hash];
let sig = Signature.create(privKey, msg); // sign a message
sig.verify(pubKey, msg); // Bool(true)
```

For a full list, see the [SnarkyJS reference](snarkyjs-reference).

##### Smart Contract

<!-- TODOs
  IMO, needs to be fleshed out a bit more before sending users to "test your zkApp" or "advanced topics".
  Basics that are missing:
  * payments
  * Mina.transaction / at least hinting at the basic mechanics of how to compile / prove
  * the general notion of a transaction / of an account update (party)?
  * permissions? (probably an advanced topic)
 -->

Now that we have covered the basics of writing SnarkyJS programs, let's see how to create a smart contract.

Smart contracts are written by extending the base class `SmartContract`:

```ts
class HelloWorld extends SmartContract {}
```

The `constructor` of a `SmartContract` is inherited from the base class and should not be overriden.
It takes the zkApp account address (a public key) as its only argument:

```ts
let zkAppKey = PrivateKey.random();
let zkAppAddress = PublicKey.fromPrivateKey(zkAppKey);

let zkApp = new HelloWorld(zkAppAddress);
```

Later, we show you how you can deploy a smart contract to an on-chain account.

:::note
On Mina, there is no strong distinction between normal "user accounts" and
"zkApp accounts". A zkApp account is just a normal account that has a smart
contract deployed to it â€“ which essentially just means there's a verification
key stored on the account, which can verify zero-knowledge proofs generated
with the smart contract.
:::

##### Methods

Interaction with a smart contract happens by calling one or more of its _methods_. You declare methods using the `@method` decorator:

```ts
class HelloWorld extends SmartContract {
  @method myMethod(x: Field) {
    x.mul(2).assertEquals(5);
  }
}
```

Within a method, you can use SnarkyJS' data types and methods to define your custom logic.

Later, we'll show how you can...

- run a method (off-chain)
- create a proof that it executed successfully
- send that proof to the Mina network, to trigger actions like a state change or payment

To get an idea what "successful execution" means, look at this line in our example above:

```ts
x.mul(2).assertEquals(5);
```

Creating a proof for this method will only be possible if the input `x` satisfies the equation `x * 2 === 5`. This is what we call a "constraint".
Magically, the proof can be checked without seeing `x` â€“ it's a _private input_.

The method above is not very meaningful yet. To make it more interesting, we need a way to interact with accounts, and record state on-chain.
Check out the next section for more on that!

One more note about private inputs: The method above has one input parameter, `x` of type `Field`. In general, arguments can be any of the built-in SnarkyJS type that you saw: `Bool`, `UInt64`, `PrivateKey`, etc. From now on, we will refer to those types as [structs`](how-to-write-a-zkapp#custom-data-types).

<!-- TODO Gregor's note on the below alert box: too much? too early? I think little "deep dives" like this can be useful to answer questions that more advanced users often have after reading our docs, and spread more understanding of Mina to the internet
-->

:::info

Under the hood, every `@method` defines a zk-SNARK circuit. From the cryptography standpoint, a smart contract is a collection of circuits, all of which are compiled into a single prover & verification key. The proof says something to the effect of "I ran one of these methods, with some private input, and it produced this particular set of account updates". In ZKP terms, the account updates are the _public input_. The proof will only be accepted on the network if it verifies against the verification key stored in the account. This ensures that indeed, the same code that the zkApp developer wrote also ran on the user's device â€“ thus, the account updates conform to the smart contract's rules.

:::

<!-- TODO: create at least a basic section about zk circuits below this subsection which contains (among other things) a more thourough explanation of what this tip hints at -->

:::tip

You will find that inside a `@method`, things sometimes behave a little differently. For example, the following code can't be used in a method where `x: Field` is an input parameter:

```ts
console.log(x.toString()); // don't do this inside a `@method`! ðŸ˜¬
```

This doesn't work because, when we compile the SmartContract into prover and verification keys, we will run your method in an environment where the method inputs don't have any concrete values attached to them. They are like mathematical variables `x`, `y`, `z` which are used to build up abstract computations like `x^2 + y^2`, just by running your method code.

Therefore, when executing your code and trying to read the value of `x` to turn it into a string via `x.toString()`, it will blow up because such a value can't be found. On the other hand, during proof generation all the variables _have_ actual values attached to them (cryptographers call them "witnesses"); and it makes perfect sense to want to log these values for debugging.
This is why we have a special function for logging stuff from inside your method:

```ts
Circuit.log(x);
```

The API is like that of `console.log`, but it will automatically handle printing SnarkyJS data types in a nice format. During SmartContract compilation, it will simply do nothing.
:::

##### On-chain state

A smart contract can contain **on-chain state**, which is declared as a property
on the class with the `@state` decorator:

```ts
class HelloWorld extends SmartContract {
  @state(Field) x = State<Field>();

  // ...
}
```

Here, `x` is of type `Field`. Like with method inputs, only SnarkyJS structs can be used for state variables.
In the current design, the state can consist of at most 8 Fields of 32 bytes each. These states are stored on the zkApp account.
Some structs take up more than one Field: for example, a `PublicKey` needs 2 of the 8 Fields.
States are initialized with the `State()` function.

A method can modify on-chain state by using `this.<state>.set()`:

```ts
class HelloWorld extends SmartContract {
  @state(Field) x = State<Field>();

  @method setX(x: Field) {
    this.x.set(x);
  }
}
```

As a zkApp developer, if you add this method to your smart contract, you are saying: "Anyone can call this method, to set `x` on the account to any value they want."

##### Reading state

Often, we also want to _read_ state â€“ check out this example:

```ts
class HelloWorld extends SmartContract {
  @state(Field) x = State<Field>();

  @method increment() {
    // read state
    const x = this.x.get();
    this.x.assertEquals(x);

    // write state
    this.x.set(x.add(1));
  }
}
```

The `increment()` method fetches the current on-chain state `x` with `this.x.get()`.
Later, it sets the new state to `x + 1` using `this.x.set()`. Simple!

There's another line though, which looks weird at first:

```ts
this.x.assertEquals(x);
```

To understand it, we have to take a step back, and understand what it means to "use an on-chain value" during off-chain execution.

For sure, when we use an on-chain value, we have to _prove_ that this is the on-chain value. Verification has to fail if it's a different value! Otherwise, a malicious user could modify SnarkyJS and make it just use any other value than the current on-chain state â€“ breaking our zkApp.

To prevent that, we link "`x` at proving time" to be the same as "`x` at verification time". We call this a _precondition_ â€“ a condition that is checked by the verifier (a Mina node) when it receives the proof in a transaction. This is what `this.x.assertEquals(x)` does: it adds the precondition that `this.x` â€“ the on-chain state at verification time â€“ has to equal `x` â€“ the value we fetched from the chain on the client-side. In zkSNARK language, `x` becomes part of the public input.

Side note: `this.<state>.assertEquals` is more flexible than equating with the current value. For example, `this.x.assertEquals(10)` fixes the on-chain `x` to the number `10`.

:::note

Why didn't we just make `this.x.get()` add the precondition, automatically, so that you didn't have to write `this.x.assertEquals(x)`?
Well, we like to keep things explicit. The assertion reminds us that we add logic which can make the proof fail: If `x` isn't the same at verification time, the transaction will be rejected. So, reading on-chain values has to be done with care if many users are supposed to read and update state concurrently. It is applicable in some situations, but might cause races, and call for workarounds, in other situations.
One such workaround is the use of actions â€“ see [Actions and Reducer](advanced-snarkyjs/actions-and-reducer).

:::

##### Assertions

<!-- TODO: this is _slightly_ misplaced now, because I already had assertEquals earlier -->

Let's modify the `increment()` method to accept a parameter:

```ts
class HelloWorld extends SmartContract {
  @state(Field) x = State<Field>();

  @method increment(xPlus1: Field) {
    const x = this.x.get();
    this.x.assertEquals(x);

    x.add(1).assertEquals(xPlus1);

    this.x.set(xPlus1);
  }
}
```

Here, after obtaining the current state `x` and asserting that it equals the on-chain value, we make another assertion:

```ts
x.add(1).assertEquals(xPlus1);
```

If the assertion fails, SnarkyJS will throw an error and not submit the transaction.
On the other hand, if it succeeds, it becomes part of the proof that is verified on-chain.

Because of this, our new version of `increment()` is _guaranteed_ to behave like the previous version: It can only ever
update the state `x` to `x + 1`.

:::tip
You can add optional failure messages to assertions, to make debugging easier. For example, the above example could be written as:

```ts
x.add(1).assertEquals(xPlus1, 'x + 1 should equal xPlus1');
```

:::

Assertions can be incredibly useful to constrain state updates. Common assertions you may use are:

<!-- prettier-ignore -->
```ts
x.assertEquals(y); // x = y
x.assertBoolean(); // x = 0 or x = 1
x.assertLt(y);     // x < y
x.assertLte(y);    // x <= y
x.assertGt(y);     // x > y
x.assertGte(y);    // x >= y
```

For a full list, see the [SnarkyJS reference](snarkyjs-reference).

##### Public and private inputs

We touched on this already, but it's good to cover it in more depth:

While the state of a zkApp is **public**, method parameters are **private**.

When a smart contract method is called, the proof it produces uses zero-knowledge to hide inputs and details of the computation.

The only way method parameters can be exposed is when the computation explicitly exposes them, as
in our last example where the input was directly stored in the public state: `this.x.set(xPlus1);`

Let's show an example where this is not the case, by defining a new method called `incrementSecret()`:

```ts
class HelloWorld extends SmartContract {
  @state(Field) x = State<Field>();

  // ...

  @method incrementSecret(secret: Field) {
    const x = this.x.get();
    this.x.assertEquals(x);

    Poseidon.hash(secret).assertEquals(x);
    this.x.set(Poseidon.hash(secret.add(1)));
  }
}
```

This time, our input is called `secret`. We check that the hash of our secret is equal to the current state `x`.
If this is the case, we add 1 to the secret and set `x` to the hash of that.

When running this successfully, it just proves that the code was run with _some_ input `secret` whose hash is `x`,
and that the new `x` will be set to `hash(secret + 1)`.
However, the secret itself remains private, because it can't be deduced from its hash.

##### Initializing state

We didn't cover how to initialize on-chain state yet. This can be done in the `init()` method.

Like the constructor, `init()` is predefined on the base `SmartContract` class.
It will be called when you deploy your zkApp with the zkApp CLI, for the first time. It won't be called if you upgrade your contract and deploy a second time.
You can override this method to add initialization of your on-chain state:

```ts
class HelloWorld extends SmartContract {
  @state(Field) x = State<Field>();

  init() {
    super.init();
    this.x.set(Field(10)); // initial state
  }
}
```

Note that we have to call `super.init()`, which sets your entire state to 0.

If you don't have any state to initialize to values other than 0, then there's no need to override `init()`, you can just leave it out.
In the example above however, we are setting our state `x` to `Field(10)`.

##### Composing zkApps

A powerful feature of zkApps is that they are composable, just like Ethereum smart contracts. You can simply call smart contract methods from other smart contract methods:

```ts
class HelloWorld extends SmartContract {
  @method myMethod(otherAddress: PublicKey) {
    const calledContract = new OtherContract(otherAddress);
    calledContract.otherMethod();
  }
}

class OtherContract extends SmartContract {
  @method otherMethod() {}
}
```

When a user calls `HelloWorld.myMethod()`, SnarkyJS will create two separate proofs â€” one for the execution of `myMethod()` as usual, and a _separate_ one for the execution of `OtherContract.otherMethod()`. The `myMethod()` proof will compute an appropriate hash of the function signature of `otherMethod()` plus any arguments and return values of that function call, and guarantee that this hash matches the `callData` field on the account update produced by `otherMethod()`, which is made part of `myMethod()`'s public input. Therefore, when calling another zkApp method, you effectively prove: "I called a method with this name, on this zkApp account, with this particular arguments and return value."

To ensure other methods can use a return value of your `@method`, you must annotate the return value in your TypeScript function signature. Here's an example of returning a `Bool` called `isSuccess`:

```ts
@method otherMethod(): Bool { // annotated return type
  // ...
  return isSuccess;
}
```

##### Custom data types

As mentioned previously, smart contract method arguments can be any of the built-in SnarkyJS types.

However, what if you want to define your own data type?

You can create a custom data type for your smart contract using the `Struct` function that SnarkyJS exposes. To do this, create a class that extends `Struct({ })`.
Then, inside the object `{ }`, define the fields that you want to use in your custom data type.

For example, let us say you want to create a custom data type called `Point` representing a 2D point on a grid. The `Point` struct has no instance methods and is only used to hold information about the `x` and `y` points.
You can create a such a Point class by creating a new class that extends the `Struct` class:

```ts
class Point extends Struct({
  x: Field,
  y: Field,
}) {}
```

Now that you have defined your Struct, you can use it in your smart contract for any SnarkyJS built-in types.

For example, the following smart contract uses the `Point` Struct defined above as state and as a method argument:

```ts
export class Grid extends SmartContract {
  @state(Point) p = State<Point>();

  @method init() {
    this.p.set(new Point({ x: Field(1), y: Field(2) }));
  }

  @method move(newPoint: Point) {
    const point = this.p.get();
    this.p.assertEquals(point);

    const newX = point.x.add(newPoint.x);
    const newY = point.y.add(newPoint.y);

    this.p.set(new Point({ x: newX, y: newY }));
  }
}
```

Note that your Structs can contain SnarkyJS built-in types like `Field`, `Bool`, `UInt64`, etc or even other custom types that you've defined which are based on the `Struct` class.
This allows for great composability and reusability of structs.

##### Transactions and account updates

Now that we've got an idea about writing zkApp methods, we need to discuss how users can call these methods. Recall that smart contracts execute off-chain. The result of such an off-chain execution is a _transaction_, which can be sent to the Mina network to apply the changes made by the smart contract. In this section we'll learn what a transaction looks like, and how you can create one.

The fundamental data structure that Mina transactions are built from is called an _account update_. An account update always contains updates to one specific on-chain account. For example, if you transfer MINA from one account to another, that will update the balance on two accounts â€“ the sender and the receiver. Therefore, sending MINA requires two account updates. As you'll see later, account updates are a flexible and powerful data structure, which can express all kinds of updates, events and preconditions that you'll need for developing smart contracts.

A _transaction_ is a JSON object of the form `{ feePayer, accountUpdates: [...], memo }`. Here, the `feePayer` is a special account update of slightly simpler structure. In particular, it contains a `fee` field which has to be used to specify the transaction fee. The `accountUpdates` array, on the other hand, is a list of normal account updates, which make up the bulk of the transaction. Finally, `memo` is an encoded string which can be used to attach an arbitrary short message â€“ we'll ignore it for now.

We create transactions in SnarkyJS by calling `Mina.transaction(...)`, which takes the sender (a public key) and a callback that contains your transaction's logic.

```ts
const sender = PublicKey.fromBase58('B62..'); // the user address
const zkapp = new MyContract(address); // MyContract is a SmartContract

const tx = await Mina.transaction(sender, () => {
  zkapp.myMethod(someArgument);
});
```

In this example, the transaction consists of calling a single `SmartContract` method, called `myMethod`. You can inspect the transaction yourself by printing it out as JSON:

```ts
console.log(tx.toJSON());
```

If you try this, you'll see a massive JSON object with lots of fields, most of which are set to their default value. There's also a way to pretty-print transactions in a more human-readable, condensed format:

```ts
console.log(tx.toPretty());
```

Depending on the logic of `myMethod()`, this could print something like the following:

```ts
[
  {
    publicKey: '..VeLh',
    fee: '0',
    nonce: '0',
    authorization: '..EzRQ',
  },
  {
    label: 'MyContract.myMethod()',
    publicKey: '..Nq6w',
    update: { appState: '["1",null,null,null,null,null,null,null]' },
    preconditions: {
      account: '{"state":["0",null,null,null,null,null,null,null]}',
    },
    authorizationKind: 'Proof',
    authorization: undefined,
  },
];
```

From this output, there are several important things we can learn about transactions.

First of all, this is an array with two entries: the account updates that make up this transaction. The first one is always the fee payer, whose public key we passed in as `sender`. For the `fee`, which we didn't specify, SnarkyJS filled in 0; the `authorization` was filled with a dummy signature. In a user-facing zkApp, you typically wouldn't care about setting those values â€“ instead, you'd create a transaction like this, in the browser, and pass it on to the user's wallet. The wallet would replace your fee payer with one that represents the user account, with the user's settings for the fee. It would also fill the `authorization` field with a signature created from the user's private key. See our section about [connecting your zkApp with a user's wallet](how-to-write-a-zkapp-ui#connecting-your-zkapp-with-a-users-wallet).

The second account update in our list has a label: `'MyContract.myMethod()'`. This tells us that it corresponds to the method call we performed. A `@method` call always results in the creation of an account update â€“ namely, an update to the zkApp account itself. Let's see what the other fields in this account update mean:

- `publicKey` â€“ the zkApp address (like other non-human-readable strings, this is truncated by `tx.toPretty()`)
- `update: { appState: [...] }` â€“ shows how your method wants to update on-chain state, using `this.<state>.set()`. The names and pretty types you defined using `@state` are removed in this representation; instead, you see a raw list of 8 field elements, or `null` for state fields that aren't updated.
- `preconditions: { account: { state: [...] } }` â€“ similar to the `update`, this has one entry per field of on-chain state. These are the preconditions that you created with `this.<state>.assertEquals()`. In this example, your transaction will only be accepted if the first of the 8 state fields equals 0. The `null` values mean that there's no condition on the other 7 state fields.
- `authorizationKind: 'Proof'` â€“ this means that this account update needs to be authorized with a proof. This is the default when you call a zkApp method, but not necessarily for other account updates, as we'll explain below.
- `authorization: undefined` â€“ the proof that's needed on this update isn't there yet! We'll show how to add it in a minute.

Note that there a many more fields that account updates can have, but `tx.toPretty()` only prints the ones that have actual content. Also, the ones above may be missing: For example, if our zkApp doesn't set any state, the `update` field might be missing. In that case, strictly speaking it wouldn't always be an "update" in the sense that the account is modified. We still use the term "account update" for simplicity.

As you might have noticed, these account updates weren't created in a very explicit manner. Instead, SnarkyJS gives you an imperative API, with "commands" like `state.set()`. Under the hood, these commands create and modify account updates in a transaction, like you saw above. In the end, the entire transaction will be sent to the network, as one atomic update. If something fails â€“ for example, one of the account updates has insufficient authorization â€“ the _entire_ transaction is rejected and doesn't get applied. This is in contrast to an EVM contract, where the initial steps of a method call could succeed even if the method fails at a later step.

##### Creating proofs, and what they mean

Let's finally see how to create zero-knowledge proofs!

```ts
await MyContract.compile(); // this might take a while

// ...

const tx = await Mina.transaction(sender, () => {
  zkapp.myMethod(someArgument);
});
await tx.prove(); // this might take a while
```

There are two new operations here:

- `MyContract.compile()` creates prover & verification keys from your smart contract.[^1] You need to do this before you can create any proofs!
- `tx.prove()` goes through your transaction, and creates proofs for all the account updates that came from method calls.

[^1]: The name `compile()` is a metaphor for what this function does: creating prover and verifier functions from your code. It doesn't refer to literal "compilation" of JS into a circuit representation. The circuit representation of your code is created by _executing_ it, not by compiling it. Also, the prover function still includes the execution of your JS code as one step.

Both of these are heavy cryptographic operations, and they might take between a few seconds and a few minutes, depending on the amount of logic you're proving and on how fast your machine is. If you print the transaction again with `tx.toPretty()`, you'll find that it now has the proof as a base64 string inside the `authorization` field:

```ts
[
  // ...
  {
    label: 'MyContract.myMethod()',
    // ...
    authorization: { proof: '..KSkp' },
  },
];
```

You might wonder: what, exactly, is proved here? How is the proof linked to the account update it is part of?

The proof attests to two different things:

- The execution of `myMethod()`
- The public input of that execution

Recall that all method arguments are _private inputs_. So, the verifier doesn't get to see them, and the proof doesn't say anything about them (it only says that there were _some_ private inputs that satisfied all constraints). However, a zk proof can also have a public input. In the case of zkApps, **the public input is the account update**. It is passed in implicitly when you do `tx.prove()`. The prover function (i.e., your smart contract logic) creates its own account update and constrains it to equal the public input.

You can think of the public input as data that is shared between the prover and verifier. The verifier passes in the public input when verifying it, and the proof will only be valid if it was created with _the same public input_. For us, this means that this proof attests to the validity of exactly this account update. If you change the account update before sending it to the Mina network, the proof won't be valid for it anymore. In other words: The only valid account updates for a zkApp account are the ones created according to the logic of your `SmartContract`. This is the core of why we can have smart contracts that execute on the client side.

##### Payments, and more on public inputs

Let's continue our discussion of account updates from the preceding sections, at the hand of an example that is important on its own: Paying out MINA from a zkApp. To send MINA, you can use `this.send()` from your smart contract method:

```ts
class MyContract extends SmartContract {
  @method payout(amount: UInt64) {
    // TODO: logic that determines whether the user is allowed to claim this amount

    this.send({ to: this.sender, amount });
  }
}
```

This simple example `@method payout()` can be called by anyone to send a given amount of nanoMINA to themselves. Note that we get the sender of the transaction with `this.sender`. In a real zkApp, you'd probably want to add some conditions that are checked in this method, determining who can call it with which amounts. Let's call this method in a transaction, and print out the result:

```ts
const MINA = 1e9;

const tx = await Mina.transaction(sender, () => {
  zkapp.payout(UInt64.from(5 * MINA));
});
await tx.prove();
console.log(tx.toPretty());
```

:::info

MINA amounts, in all SnarkyJS APIs and elsewhere in the protocol, are always denominated in nanoMINA = `10^(-9)` MINA. This is why we set `const MINA = 1e9`.

:::

What's interesting for us is that our transaction now has 3 account updates:

```ts
[
  {
    // fee payer
  },
  {
    label: 'MyContract.payout()',
    publicKey: '..Nq6w',
    balanceChange: { magnitude: '5000000000', sgn: 'Negative' },
    authorizationKind: 'Proof',
    authorization: { proof: '..KSkp' },
  },
  {
    publicKey: '..VeLh',
    balanceChange: { magnitude: '5000000000', sgn: 'Positive' },
    callDepth: 1,
    caller: '..umxw',
    authorizationKind: 'None_given',
  },
];
```

The zkApp update with label `'MyContract.payout()'` has a negative `balanceChange` of 5 billion (= 5 MINA). This makes sense, because we are sending MINA away from the zkApp account.
Then, there's an additional account update, with a corresponding positive balance change â€“ the user account that receives MINA.

Two quick observations:

- We didn't create the receiver account update explicitly. It was created, and attached to the transaction, by calling `this.send()`. You'll find that SnarkyJS tries to abstract away the low-level language of account updates where possible, and to give you intuitive commands to create the right ones. However, you'll sometimes also create account updates explicitly (see next section).
- The user update has `authorizationKind: 'None_given'`. That means it's not authorized. This is possible because it doesn't include any changes that require authorization: It just receives MINA, and you're able to send someone MINA without their permission.

In general, there are three kinds of authorization that an account update can have: a proof, a signature, or none. We'll learn about signatures in the next section.

<!-- TODO: link to permission section when it exists -->

Next, we observe that the user account update has a `callDepth: 1` and a non-default `caller` field. We won't explain this in detail, but it has to do with the fact that it was created from within a zkApp call. Account updates, even though displayed as a flat list here, are implicitly structured as a _list of trees_. Updates with a call depth of 1 or higher are child nodes of another update in that list of trees. In our case, the zkApp (sender) account update is at the top level (`callDepth: 0`) and the user (receiver) account update is a child of it.

So, what is the meaning of this tree structure? Recall that in the last section, we explained how the zkApp account update is public input to its proof. Now, the fully general version of that statement is:
**In a tree of account updates, all nodes are public inputs to the proof of the root node.** (If there is such a proof. This also holds for sub-trees of each tree.)

<!-- TODO: _ideal_ here would be a little picture of a tree, with a parent and a child node -->

Concretely, in our example, both the zkApp account update and the user account update are public input to the zkApp method call. Intuitively, being public input means that the zkApp can "see" and constrain the update as part of its proof. Here, it means that nobody could change the public key of the receiver, or amount they receive, without making the proof invalid. The update can only contain what the method specified.

All of this is true because `this.send()`, under the hood, placed the receiver update at call depth 1, under the zkApp update. As a counter-example: The fee payer is never part of the public input. It can be anything without affecting the validity of the proof.

A key takeaway is: If you want something to become part of your proof, you have to put it inside your `@method`.

<!-- TODO: This section got a bit long, so I commented out the content below. It educates about a frequent gotcha, but it's too much at this point and could live in some tutorial / deep-dive later -->

<!--
Let's try to mess around a bit, and see what happens if we move `.send()` _outside_ the `payout()` method, into the `Mina.transaction` callback:

```ts
class MyContract extends SmartContract {
  @method payout(amount: UInt64) {
    // this.send({ to: this.sender, amount }); // commented this out, placed it below
  }
}

// ...

const tx = await Mina.transaction(sender, () => {
  let amount = UInt64.from(5n * MINA);
  zkapp.payout(amount);
  zkapp.send({ to: sender, amount }); // here
});
await tx.prove();
```

If you run this, you'll see an error:

```
Error when proving MyContract.payout()
...
```

This error comes about as follows:

- The logic that's proven is what's contained in your method -- `payout()`
- The method doesn't contain the `this.send()` command, which is therefore not reflected in the account updates the method creates
- The actual account updates in your transaction do reflect the `send()` command
- The actual account updates are passed into your method prover as public input
- The method prover compares that public input to the account updates it itself creates (which makes them sort of a "public output")
- That comparison check fails, because the two sets of account updates are different
-->

##### Signing transactions, and explicit account updates

Let's recap: We have explained how to write a SmartContract. We've seen how to create a transaction which calls that contract, and how the transaction consists of account updates which were created by SnarkyJS under the hood. Now, we'll see an example of creating an account update explicitly. We'll also learn how to use signatures, for authorizing updates to user accounts.

We continue the payment topic of last section, where we paid out MINA from a zkApp. This time, we go the other direction: make a deposit from the user into the zkApp. Payments made from a user account will require a signature by the user. Here's the smart contract code:

```ts
class MyContract extends SmartContract {
  @method deposit(amount: UInt64) {
    let senderUpdate = AccountUpdate.create(this.sender);
    senderUpdate.requireSignature();
    senderUpdate.send({ to: this, amount });

    // TODO: logic that gives the user something in return for the deposit
  }
}
```

Let's unpack what happens here. The first line of our method creates a new, empty account update for the sender account:

```ts
let senderUpdate = AccountUpdate.create(this.sender);
```

`AccountUpdate` is the class in SnarkyJS that represents account udpates. `AccountUpdate.create()` not only instantiates this class, but also attaches the update to the current transaction, at the same level where `create` is called. If it is called inside a `@method`, the `AccountUpdate` is created as a child (public input) of the zkApp update.

The next line tells SnarkyJS that this update will be authorized with a signature:

```ts
senderUpdate.requireSignature();
```

We'll get into this later. We also could've used a shortcut which does both `AccountUpdate.create()` and `requireSignature()` in one command:

```ts
let senderUpdate = AccountUpdate.createSigned(this.sender); // create + requireSignature
```

Finally, we use `.send()` on the sender `AccountUpdate` to deposit into the zkApp, which has the same API as `this.send()`:

```ts
senderUpdate.send({ to: this, amount });
```

Note that instead of an address as the `to` field, we pass in `this`, which is a `SmartContract`. This is done so that `.send()` doesn't create an additional update, but uses the one that's already created for our zkApp.

If we create a transaction for calling this method like before, it looks like this:

```ts
[
  {
    // fee payer
  },
  {
    label: 'MyContract.deposit()',
    balanceChange: { magnitude: '5000000000', sgn: 'Positive' },
    // ...
  },
  {
    publicKey: '..VeLh',
    balanceChange: { magnitude: '5000000000', sgn: 'Negative' },
    callDepth: 1,
    useFullCommitment: true,
    caller: '..umxw',
    authorizationKind: 'Signature',
    authorization: undefined,
  },
];
```

The third account update is the one we created with `AccountUpdate.create()`. Two changes to it were caused by calling `requireSignature()`:

- `useFullCommitment: true`, which we won't explain here but has to do with replay protection if you're using signatures.
- `authorizationKind: 'Signature'`

Finally, `authorization: undefined` indicates that we didn't provide the signature yet.

In a user-facing zkApp, user signatures will typically be added by a wallet, not within SnarkyJS. In that case, the missing signature is fine. However, for testing and calling zkApps via node, you need to add the signatures yourself. The command to do that is `tx.sign([...privateKeys])`, called after `Mina.transaction` on the finished transaction. Here's an example:

```ts
const sender = senderPrivateKey.toPublicKey(); // public key from sender's private key

const tx = await Mina.transaction(sender, () => {
  zkapp.deposit(UInt64.from(5 * MINA));
});
await tx.prove();

tx.sign([senderPrivateKey]); // senderKey is a PrivateKey
```

The example first shows us how we can derive the sender's public key `sender` from its private key `senderPrivateKey`.

Note that `.sign()` takes an array, so you could provide multiple private keys for signing. `.sign()` will go through the transaction and add signatures on all account updates which 1) need a signature and 2) whose public key matches one of the private keys that were provided. In the example above, two account updates are signed with `tx.sign()`: The fee payer and the depositor account update. Both have the `sender` public key on them, which matches `senderPrivateKey.toPublicKey()`.

:::note

SnarkyJS allows you to load and store private and public keys in base58 format. Here's how the sender private key might be created in a script:

```ts
const senderPrivateKey = PrivateKey.fromBase58('EKEQc95...');
```

In a real server-side deployment, you probably want to load keys from a file or environment variable, instead of hard-coding them in your source code.
:::

To summarize, there are three types of authorization that account updates can have, which are typically used in different circumstances:

- Proof authorization â€“ used for zkApp accounts when you do a `@method` call. Proofs are verified against the on-chain verification key.
- Signature authorization â€“ used to update user accounts. Signatures are verified against the account's public key.
- No authorization â€“ used on updates which don't require authorization, for example positive balance changes.

The list above just reflects common defaults. The full source of truth is given by the _account permissions_, see [Permissions](snarkyjs-reference/Interfaces/Permissions). Using permissions, account owners can decide on a fine-grained level which type of authorization is required on which kinds of updates - take a look at the [Advanced SnarkyJS Permission](advanced-snarkyjs/permissions) section that goes into detail!.



##### Sending transactions

The final step of creating a transaction is sending it to the network. Like signing, in a user-facing zkApp this is usually handled by a wallet. But you need to know how to do it yourself for testing and scripting.

To send a transaction, we need to specify what network we're interacting with. This is done by specifying a "Mina instance" at the beginning of your script:

```ts
const Network = Mina.Network('https://example.com/graphql');
Mina.setActiveInstance(Network);
```

The network URL has to be a GraphQL endpoint which exposes a compatible GraphQL API. This URL will not only determine where transactions are sent, but also where SnarkyJS gets account information from, when _creating_ transactions. For example, when you do something like `this.<state>.get()` in your smart contract, the Mina instance is asked for the account using `Mina.getAccount`, which in turn will cause the account to be fetched from the GraphQL endpoint.

To send a transaction, create it as before and then use `tx.send()`:

```ts
// set Mina instance
const Network = Mina.Network('https://example.com/graphql');
Mina.setActiveInstance(Network);

// create the transaction, add proofs and signatures
const tx = await Mina.transaction(sender, () => {
  // ...
});
await tx.prove();
tx.sign([senderPrivateKey]);

// send transaction
await tx.send();
```

The output of `tx.send()` can be used to wait for inclusion of this transaction in a block, and to get the transaction hash (which lets you look up the pending transaction on a block explorer):

```ts
// send transaction, log transaction hash
let pendingTx = await tx.send();
console.log(`Got pending transaction with hash ${pendingTx.hash()}`);

// wait until transaction is included in a block
await pendingTx.wait();

// our account updates are applied on chain!
```

Apart from `Mina.Metwork`, you can also use a mocked "Mina instance" for local testing:

```ts
const Local = Mina.LocalBlockchain();
Mina.setActiveInstance(Local);
```

Doing this means setting up a fresh, local ledger, which is pre-filled with a couple of accounts with funds on them that you have access to. "Sending" a transaction here just means applying your account updates to that local Mina instance. This is helpful for testing, especially because account updates go through the same validation logic locally that they would on-chain.[^2]

<!-- TODO commenting this out as it overlaps with the testing section

Everything else works the same locally as it would when interaction with a real network. You still need to properly sign your transactions and attach proofs, and then send them with `tx.send()` to apply them locally.

To help you iterate quicker when testing, there's an option to disable proof creation: `Mina.LocalBlockchain({ proofsEnabled: false })`. You can use it like this:

```ts
// local mock Mina instance
const proofsEnabled = false;
const Local = Mina.LocalBlockchain({ proofsEnabled });
Mina.setActiveInstance(Local);

// only need to compile smart contract when proofs are enabled
if (proofsEnabled) await MyContract.compile();

const tx = await Mina.transaction(sender, () => {
  // ...
});
await tx.prove();
tx.sign([senderKey]);

await tx.send();

// our accounts updates are applied locally!
```

Note that with `proofsEnabled: false`, you still need to call `await tx.prove()`. The only change is that `.prove()` creates a dummy proof instead of a real one, and runs in 0 seconds. Also, `tx.send()` will skip the usual step of verifying your proof. -->

You can learn more about testing in [How to test your zkApp](how-to-test-a-zkapp).

[^2]: Fun fact: `LocalBlockchain` literally uses the same OCaml code for transaction validation and application that the Mina node uses; it's compiled to JS with [js_of_ocaml](https://github.com/ocsigen/js_of_ocaml).

## Next Steps

Now that you've learned how to write and operate a basic smart contract, you can learn [how to test your zkApp](how-to-test-a-zkapp).


---
title: How zkApps Work
hide_title: true
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

# How zkApps Work

:::note
zkApps run in the latest versions of <a href="https://www.google.com/chrome/index.html">Chrome</a>, <a href="https://www.mozilla.org/en-US/firefox/new/">Firefox</a>, <a href="https://www.microsoft.com/edge">Edge</a>, and <a href="https://brave.com/">Brave</a> currently. We intend to add support for Safari in the future.

:::

<br />

zkApps are written in TypeScript using the Mina zkApp CLI. In the upcoming section [how to write a zkApp](how-to-write-a-zkapp), weâ€™ll go into detail about writing your first zkApp. For now, weâ€™ll discuss how zkApps work.

A â€œzkAppâ€ consists of two parts: 1) a smart contract and 2) an UI (user interface) for users to interact with it.

<figure>
  <img src="/img/3_zkApps_Structure.jpg" width="100%" />
  <figcaption>zkApps consists of two parts: 1) a smart contract and 2) an UI (user interface) for users to interact with it.</figcaption>
</figure>

<br />

:::note

We use the term <b>â€œsmart contractâ€</b> to refer to the code written with SnarkyJS (which will be introduced below).

We use the term <b>â€œzkAppâ€</b> to refer to the UI + the smart contract.

:::

### Zero-knowledge based smart contracts

Because zkApps are based on **zero-knowledge proofs (zk-SNARKs)**, a zkApp developer writes what is called a **â€œcircuitâ€**, which is the method from which a **prover function** and a corresponding **verifier function** are derived during the build process.

The **prover function** is the function which executes a smart contractâ€™s custom logic.

The **prover function** runs in a userâ€™s web browser as part of the zkApp. When interacting with a zkApp's UI, users will enter any data (e.g. â€œbuy ABC for y priceâ€) required as input to the prover function, which will then generate a zero-knowledge proof.

<figure>
<img src="/img/4_zkApps_Prover_Function.jpg" width="90%" />
  <figcaption>The prover function is the function which executes a smart contractâ€™s custom logic.</figcaption>
</figure>

Both **private inputs** and **public inputs** represent data that must be provided to the prover function when it runs in the userâ€™s web browser.

**Private inputs** are not needed again after that point. But **public inputs** must be also provided to the verifier function (to be introduced soon) when it runs on the Mina network, and as such should never be used for data that you want to remain private.

The **verifier function** is the function that validates whether a zero-knowledge proof successfully passes all the constraints defined in the prover function. This _always_ runs quickly and efficiently _irrespective of the prover functionâ€™s complexity_.

Within the Mina network, Mina acts as the verifier and runs the verifier function. Weâ€™ll describe how this works soon.

<figure>
  <img src="/img/5_zkApps_Verifier_Function.jpg" width="90%" />
  <figcaption>The verifier function is the function that validates whether a zero-knowledge proof successfully passes all the constraints defined in the prover function.</figcaption>
</figure>

### Prover Function & Verification Key

When a zkApp developer writes their smart contract and runs `npm run build`, the build process outputs `smart_contract.js`. From this, you can run your prover function or generate a verification key, which you will need to run or deploy your smart contract, respectively.

The **prover function** runs in a userâ€™s web browser.

The **verification key** lives on chain for a given zkApp account and is used by the Mina network to verify that a zero-knowledge proof has met all constraints defined in the prover. A verification key is required in order to create a zkApp account. We will describe this more below.

The next two sections will go into more detail about how the prover and verifier functions are used when a zkApp is deployed and when users interact with a zkApp.

### Deploying a smart contract

<figure>
  <img src="/img/6_zkApps_DeploySmartContract.jpg" width="75%" alt="Diagram showing deployment of a Mina zkApp smart contract" />
</figure>

<br/>

To deploy a smart contract to the Mina network, the developer uses the Mina zkApp CLI. The deployment process sends a transaction containing the verification key to an address on the Mina blockchain.

When a Mina address contains a verification key, it acts as a **zkApp account**.
Whereas a regular Mina account can receive any transactions, a zkApp account can only successfully receive transactions containing a proof that satisfies the verifier function. Any transactions that do not pass the verifier function will be rejected by the Mina network.

:::info

When you deploy to a new Mina address, the Mina Protocol will charge a 1 MINA fee for account creation. This is unrelated to zkapps and is to help prevent sybil or denial of service attacks.

:::note

### Deploying a zkApp UI

<img src="/img/7_zkApps_DeploySmartContract.jpg" width="95%" />
<br></br>

Developers usually build a UI to allow users to interact with the smart contract.

Typically, this is a static website deployed to a host of the developerâ€™s choosing. We recommend web hosts that offer a global CDN to ensure the best user experience.

Your website needs to contain the `smart_contract.js` file that was generated when building your smart contract. On the [how to write a zkApp](how-to-write-a-zkapp) page, we will go into more detail.

<img src="/img/8_zkApps_DeploySmartContract.jpg" width="95%" />

### How users interact with a zkApp

:::info

To use a zkApp, users must [install Auro wallet for Google Chrome](https://www.aurowallet.com). We anticipate other wallets to add support for zkapps in the future.

:::

<br />

Auro is the only wallet that supports zkApp transactions currently. However, we plan to expand support for zkApps to other types of wallets (such as mobile wallets and desktop wallets) in the future.

After a zkApp is deployed to a host (e.g. mycoolzkapp.com), users can interact with it:

1. User visits mycoolzkapp.com.
2. User interacts with the zkApp and enters any data as required. (For example, if this were an automated market maker, the user might specify to â€œbuy x amount of ABC at y priceâ€.)
3. The prover function in the zkApp will now generate a zero-knowledge proof locally given the data entered by the user. This data can be either private (which will never be seen by the blockchain) or public (which will be stored either on chain or off chain), depending on what the developer specified, as needed for a given use case. Additionally, a list of state updates to be created by this transaction is generated and is associated with this proof. (We refer to these as â€œeventsâ€ and weâ€™ll describe them in more detail further below.)
4. User clicks â€œsubmit to chainâ€ in the zkApp UI and their wallet (such as a browser extension wallet) will prompt them to confirm sending the transaction. The wallet signs the transaction containing the proof and associated description of state to update and sends it to the Mina blockchain.
5. When the Mina network receives this transaction, it will verify that the proof successfully passes the verifier method listed on the zkApp account. If the network accepts this transaction, this indicates that this proof and the requested state changes are valid and, as such, are allowed to update the zkAppâ€™s state.

Because the userâ€™s interaction occurs _locally_ within their web browser (using JavaScript on the client), the userâ€™s privacy can be maintained.

### How is state updated on chain

You may be wondering how the state on a zkApp account gets updated on chain. We glossed over that detail earlier to keep things simple.

When the prover function runs in a web browser, the smart contract outputs a proof and some associated data that we call â€œeventsâ€. This is sent as part of the transaction when sending a transaction to a zkApp address. These events are a plaintext description (in JSON) describing how to update the state on a zkApp account.

The integrity of these events is ensured by passing a hash of these events as a public input to the smart contract. They must be present and unmodified for the verification function to pass successfully when it runs on Mina. In this way, the Mina network can confirm the integrity of both the proof and the associated events which describe how to update the zkApp accountâ€™s state.

### ZkApp state

Two different types of state exist on Mina: on-chain state and off-chain state.

On-chain state describes state that lives on the Mina blockchain. Off-chain state describes state stored anywhere else--such as [IPFS](https://ipfs.io/), etc.

### On-chain state

Each zkApp account provides 8 fields of 32 bytes each of arbitrary storage. You may store anything here as long as it fits in the size provided.

If you anticipate your state to be larger than this, or if the state accumulates per user with your zkApp, then youâ€™ll want to use off-chain state instead.

### Off-chain state

:::info

Support for off-chain state will be coming soon.

:::

For larger data, you may want to consider storing the root of a [Merkle tree](https://en.wikipedia.org/wiki/Merkle_tree) (or similar data structure) within your zkAppâ€™s on-chain storage that references additional off-chain state stored elsewhere, in a location of your choosing, such as [IPFS](https://ipfs.io/).

When the zkApp runs in a userâ€™s web browser, it may insert state to an external storage, such as IPFS. When the transaction is sent to the Mina network, if it accepts this zkApp transaction (i.e. this proof & state were valid so the updates are allowed), then the zkApp transaction would update the root of the Merkle tree that is stored on chain.

<img src="/img/9_zkApps_Off-Chain_State.jpg" width="95%" />

### Keep going

On the next page, weâ€™ll dive into [how to write a zkApp](how-to-write-a-zkapp)!


---
title: Overview
hide_title: true
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

# Overview

<br />

<figure>
  <img
    src="/img/zk-cli.png"
    alt="Terminal screenshot of Minaâ€™s zkApp CLI command-line interface."
    width="70%"
  />
</figure>

<br />

### What are zkApps?

zkApps ("zero-knowledge apps") are Mina Protocolâ€™s smart contracts powered by zero-knowledge proofs, specifically using zk-SNARKs.

zkApps use an **off-chain execution** and mostly **off-chain state** model. This allows for private computation and state that can be either private or public.

zkApps can perform arbitrarily-complex computations off chain while incurring only a flat fee to send the resulting zero-knowledge proof to the chain for verification of this computation, as opposed to other blockchains that run computations on chain and use a variable gas-fee based model.

<figure>
  <img
    src="/img/1_zkApps_Off-Chain_Performance.jpg"
    width="95%"
    alt="Mina zkApp zero knowledge app architecture diagram"
  />
</figure>

<br />

You can learn more on the [How zkApps Work](./zkapps/how-zkapps-work) page.

### TypeScript

zkApps are written in [TypeScript](https://www.typescriptlang.org/).

TypeScript provides an easy, familiar language (JavaScript), but with type safety, making it easy to get started writing zkApps. If you're new to using TypeScript, check out this helpful [12-min introductory video](https://www.youtube.com/watch?v=ahCwqrYpIuM).

See [How to Write a zkApp](/zkapps/how-to-write-a-zkapp) page to learn more.

### Quickstart

Deploy a zkApp in 5-steps, to see how easy it is to get started:

1. `npm install -g zkapp-cli` (This will make the `zk` command available on your system.)
2. `zk project <name>`
3. `cd <name>`
4. `zk config`

   Enter the details below when prompted:

   - Name: `berkeley` (can be anything)
   - URL: `https://proxy.berkeley.minaexplorer.com/graphql`
   - Fee: `0.1`

   When finished, hold command (Mac) or control (Windows & Linux) and click the URL shown in your terminal to request Testnet MINA on your address from https://faucet.minaprotocol.com/?address=yourAddress. Then wait ~3min for the next block so you'll have Testnet MINA to send your deploy transaction.

5. `zk deploy berkeley`

The project you just created contains an example smart
contract named `Add.ts` that stores a number as on-chain state and adds `2` to it
whenever a transaction is received by the zkApp account.

You just deployed a zkApp!

Next, go further with [Tutorial 1: Hello World](https://docs.minaprotocol.com/zkapps/tutorials/hello-world).

### Examples of zkApps

Play around with a few example zkApps to see whatâ€™s possible:

<figure>
  <img
    src="/img/2_zkApps_Examples.jpg"
    alt="Example zkApp zero knowledge applications."
    width="85%"
  />
  <figcaption>
    zkApps are a great fit for applications that require proof that you have a
    secret without revealing it to anyone.
  </figcaption>
</figure>

### Learn more

To learn more about developing zkApps, read [how zkApps work](/zkapps/how-zkapps-work), [how to write a zkApp](/zkapps/how-to-write-a-zkapp), and [zkApps for Ethereum Developers](/zkapps/zkapps-for-ethereum-developers).

Try the [zkApps tutorials](/zkapps/tutorials/hello-world) to learn by doing!

### Get help

Join the [#zkapps-developers](https://discord.com/channels/484437221055922177/915745847692636181) channel on Mina Protocol Discord. Participate and ask questions in [zkApps Developers Office Hours](/participate/office-hours).


---
title: zkApps Roadmap
hide_title: true
sidebar_label: Roadmap
---

import Subhead from '@site/src/components/common/Subhead';

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

# zkApps Roadmap

<Subhead>High-level overview of features available now, next, or later</Subhead>

## Now

### Mina zkApp CLI

- [Scaffold projects & files](/zkapps/how-to-write-a-zkapp#option-b-start-your-own-project)
- [Example projects](/zkapps/how-to-write-a-zkapp#option-a-start-with-an-example-recommended)
- [Deployment](/zkapps/how-to-deploy-a-zkapp)
- Create a project with an accompanying UI â€” SvelteKit, NextJS, or NuxtJS

:::note

To view all commands offered by the zkApp CLI, install it via `npm install -g zkapp-cli` and then run `zk --help`.

:::

### SnarkyJS

- [Built-in data types](/zkapps/how-to-write-a-zkapp#built-in-data-types) â€” Field, Bool, UInt32, UInt64, PublicKey, PrivateKey, Signature, Group, Scalar, & CircuitString
- [Custom data types](/zkapps/how-to-write-a-zkapp#custom-data-types) â€” a.k.a. Struct
- [Composability](/zkapps/how-to-write-a-zkapp#composing-zkapps)
- [Recursion](/zkapps/advanced-snarkyjs/recursion) â€” a.k.a. ZkProgram
- [Events](/zkapps/advanced-snarkyjs/events) â€” writing events to the archive node
- [Encryption & decryption](/zkapps/snarkyjs-reference/modules/Encryption) â€” using Minaâ€™s curves
- [Actions & reducer](/zkapps/advanced-snarkyjs/actions-and-reducer)
- [Merkle tree](/zkapps/advanced-snarkyjs/merkle-tree)
- [Custom tokens](/zkapps/advanced-snarkyjs/custom-tokens)
- [Using on-chain values](/zkapps/advanced-snarkyjs/on-chain-values) â€” a.k.a. protocol & account preconditions
- [Local blockchain](/zkapps/snarkyjs-reference/modules/Mina#localblockchain)
- [And more...](/zkapps/snarkyjs-reference)

### Data Availability

- [On-chain state](/zkapps/how-to-write-a-zkapp#on-chain-state) â€” 8 x 32 bytes of arbitrary data per zkApp account
- [Off-chain storage](/zkapps/tutorials/offchain-storage) â€” for Merkle tree data; see Tutorial 6

### Other

- [Oracles](/zkapps/tutorials/oracle)

## Next

### SnarkyJS

- [Events](https://github.com/o1-labs/snarkyjs/issues/606) â€” reading events from the archive node; awaiting Archive Node API; ETA Q1 2023
- [Actions](https://github.com/o1-labs/snarkyjs/issues/688) â€” reading events from the archive node; awaiting Archive Node API; ETA Q1 2023
- [Reduce memory requirements during file import](https://github.com/o1-labs/snarkyjs/issues/609) â€” ETA H1 2023
- Remove need for a dev to use a service worker for their UI â€” ETA H1 2023
- [Reduce KB file size, for aspects needed for UIs](https://github.com/o1-labs/snarkyjs/issues/610) â€” ETA H1 2023
- Improve error messages â€” ETA H1 2023

### Data Availability

- Off-chain storage for Merkle tree data with better guarantees â€” WIP; two teams awarded grants by Mina Foundation

### Other

- Archive Node API â€” Phase I; link to RFC on Github coming; ETA Q1 2023

## Later

### Mina zkApp CLI

- [3rd-party fee payer for deployment txs](https://github.com/o1-labs/zkapp-cli/issues/129)

### SnarkyJS

- [Dynamic array access](https://github.com/o1-labs/snarkyjs/issues/90) â€” awaiting support in proof system for extended lookup tables
- [Dynamic-length strings](https://github.com/o1-labs/snarkyjs/issues/730) â€” awaiting dynamic array access
- [JSON parsing](https://github.com/o1-labs/snarkyjs/issues/91) â€” awaiting dynamic-length strings
- [secp256k1](https://github.com/o1-labs/snarkyjs/issues/61) â€” awaiting support in Kimchi
- [keccak256](https://github.com/o1-labs/snarkyjs/issues/62) â€” awaiting support in Kimchi
- [ECDSA](https://github.com/o1-labs/snarkyjs/issues/732) â€” awaiting support in Kimchi
- [sha256](https://github.com/o1-labs/snarkyjs/issues/731) â€” awaiting support in Kimchi

### Other

- Archive Node API â€” Phase II; for serverless hosts!
- zkOracles â€” with robust privacy guarantees


---
title: SnarkyJS
---

- E.g. different methods
- Link to Github.


---
title: zkApps for Ethereum Developers
hide_title: true
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

# zkApps for Ethereum Developers

Mina and Ethereum are both decentralized, programmable, layer-one blockchains,
but they are designed in fundamentally different ways. The Ethereum network
verifies transaction execution by having every node execute every transaction.
While this design solves a real problem, it also imposes some severe limitations
on privacy and scalability.

The Mina Protocol works differently. It verifies transactions (and previous
blocks) cryptographically using recursive zero-knowledge proofs. Smart contract
code is written in TypeScript and executes off chain. Mina nodes only need to
verify a small proof in order to validate the associated execution. Better
still, the proof does not reveal any information about the underlying
computation, meaning developers can choose whether their inputs and outputs
should be public or private, depending on the requirements of their application.

## At a Glance

<table style={{borderSpacing: '0px'}}>
<thead>
  <tr>
    <th style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px'}}></th>
    <th style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px', fontSize: 'larger'}}>Ethereum Smart Contracts</th>
    <th style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px', fontSize: 'larger'}}>Mina zkApps</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px', fontSize: 'larger'}}>Language</td>
    <td style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px'}}>Smart contracts are written in <span style={{color: '#7d4bbd'}}>Solidity</span>.</td>
    <td style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px'}}>zkApp smart contracts are written using <span style={{color: '#7d4bbd'}}>SnarkyJS</span> (a <span style={{color: '#7d4bbd'}}>TypeScript</span> library).</td>
  </tr>
  <tr>
    <td style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px', fontSize: 'larger'}}>Execution Environment</td>
    <td style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px'}}>Smart contracts run on <span style={{color: '#7d4bbd'}}>every Ethereum node</span>.</td>
    <td style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px'}}>zkApps run <span style={{color: '#7d4bbd'}}>client side</span> in a userâ€™s web browser, and publish only a small validity proof which is verified by the Mina nodes.</td>
  </tr>
  <tr>
    <td style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px', fontSize: 'larger'}}>Transaction Cost</td>
    <td style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px'}}>Execution costs are variable, and determined using a <span style={{color: '#7d4bbd'}}>gas model</span>.</td>
    <td style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px'}}>Execution costs are <span style={{color: '#7d4bbd'}}>small</span>, and <span style={{color: '#7d4bbd'}}>constant</span> because the Mina nodes are verifying the same size proof regardless of the amount of client-side computation.</td>
  </tr>
  <tr>
    <td style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px', fontSize: 'larger'}}>Application Storage</td>
    <td style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px'}}>Ethereum is designed around the idea that storage, and computation are inherently coupled; <span style={{color: '#7d4bbd'}}>all state must live on every Ethereum node</span>.</td>
    <td style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px'}}>Minaâ€™s design allows state, and computation to be decoupled so that <span style={{color: '#7d4bbd'}}>application state can live anywhere</span>; developers can choose a solution that fits their cost/security requirements best.</td>
  </tr>
  <tr>
    <td style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px', fontSize: 'larger'}}>Developer Tooling</td>
    <td style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px'}}>New developer tools with unusual patterns like <span style={{color: '#7d4bbd'}}>Hardhat</span>, and <span style={{color: '#7d4bbd'}}>Truffle</span> are needed in order to manage the deployment of Ethereum smart contracts.</td>
    <td style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px'}}><span style={{color: '#7d4bbd'}}>The Mina zkApp CLI</span> manages scaffolding, linting, testing, and deployment using common JavaScript/TypeScript tools you are already familiar with.</td>
  </tr>
  <tr>
    <td style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px', fontSize: 'larger'}}>Scaling</td>
    <td style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px'}}>Ethereum nodes must execute every transaction directly making <span style={{color: '#7d4bbd'}}>horizontal scaling hard</span>.</td>
    <td style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px'}}>Minaâ€™s recursive zero-knowledge proofs allow snark-workers to compress the blockchain, and developers to compress transactions using <span style={{color: '#7d4bbd'}}>native rollups</span> for <span style={{color: '#7d4bbd'}}>exponential scaling</span>.</td>
  </tr>
  <tr>
    <td style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px', fontSize: 'larger'}}>Consensus</td>
    <td style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px'}}>Ethereum nodes must download the entire block history (<span style={{color: '#7d4bbd'}}>~700GB</span>) in order to verify the current finalized chain state.</td>
    <td style={{borderColor: 'black', borderWidth: '1px', borderStyle: 'solid', padding: '10px'}}>Mina clients can verify the current finalized state using a single <span style={{color: '#7d4bbd'}}>22KB</span> recursive zero-knowledge proof.</td>
  </tr>
</tbody>
</table>

## Example Code

```ts
import { Field, SmartContract, state, State, method } from 'snarkyjs';

export class Add extends SmartContract {
  /* The state decorator tells SnarkyJS to store/retrieve num from the Mina
  blockchain */
  /* The Field type represents elements of a finite field (similar to uint256
  for practical purposes, but loops back to 1 after overflowing) */
  @state(Field) num = State<Field>();

  // Initialize the contract (similar to a constructor in Solidity)
  init() {
    super.init();
    // Set num equal to a Field element of value 1 on contract deployment
    this.num.set(Field(1));
  }

  /* The method decorator tells SnarkyJS to be ready to generate a proof of
  execution any time this method is called */
  @method update() {
    // Get the state of num from the Mina blockchain and set it to currentState
    const currentState = this.num.get();
    /* Calling add instead of using the JS infix addition operator enables
    SnarkyJS to prove that the addition is done correctly */
    const newState = currentState.add(2);
    /* Set the state of num on the Mina blockchain equal to newState (this
    state update will not happen unless the transaction is accompanied by
    a valid proof of execution) */
    this.num.set(newState);
  }
}
```

## FAQ

### How does Mina bridge to Ethereum?

Mina proofs are small and easy to verify; this means that any Turing complete
blockchain (like Ethereum) can validate the entire Mina state in a single
transaction using a bridge contract. These are a bit different from existing
bridging solutions because they don't require additional security
assumptions. Think of them as full Mina nodes that are implemented in smart
contracts on other chains. They validate the Mina state in exactly the same way
a Mina block producer would and expose Mina directly to any other contract.
The Nil Foundation is working on the [first of these bridges](https://verify.mina.nil.foundation/walkthrough/index.html) for Ethereum and other EVM-compatible networks.

### Have another question?

Reach out in the [#zkapps-developers](https://discord.com/channels/484437221055922177/915745847692636181) channel on Mina Protocol Discord. It's better when we learn together. 


---
title: Actions & Reducer
hide_title: true
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but zkApps can now be deployed to Berkeley Testnet.

:::

# Actions & Reducer

Like events, **actions** are _public_ arbitrary information passed along with a zkApp transaction. However, actions give you an additional power: you can process previous actions in a smart contract! Under the hood, this is possible because we store a commitment to the history of dispatched actions on every account -- the **actionsHash**. It allows us to prove that the actions you process are, in fact, the actions that were dispatched to the same smart contract.

Using actions and a "lagging state" pattern, you can write zkApps that can _process concurrent state updates by multiple users_ -- see the next section. Besides that, we imagine all kinds of use cases where actions act as a built-in, "append-only" off-chain storage layer.

To use actions, we first have to declare their type on the smart contract. The object we declare is called a **reducer** -- because it can take a list of actions and reduce them:

```ts
import { SmartContract, Reducer, Field } from 'snarkyjs';

class MyContract extends SmartContract {
  reducer = Reducer({ actionType: Field });
}
```

Contrary to events, for actions you only have one type per smart contract; they also don't have a name. The `actionType` in this example is `Field`.

On a `reducer`, you have two functions: `reducer.dispatch` and `reducer.reduce`. "Dispatch" is simple -- like emitting events, it will push one additional action to your account's action history:

```ts
this.reducer.dispatch(Field(1000));
```

"Reduce" is more involved, but it gives you full power to process actions however it suits your application. It might be easiest to grasp from an example. Say we have a list of actions and want to find out if one of them is equal to `1000`. In JavaScript, there's a built-in function on `Array` which does this:

```ts
let has1000 = array.some((x) => x === 1000);
```

However, as you might know, you can also implement this with `Array.reduce`:

```ts
let has1000 = array.reduce((acc, x) => acc || x === 1000, false);
```

In fact, `Array.reduce` is powerful enough to let you do pretty much all array processing you can think of. With `Reducer.reduce`, we give you an in-snark operation which is just as powerful:

```ts
// type for the "accumulated output" of reduce -- the `stateType`
let stateType = Bool;

// example actions data
let actions = [[Field(1000)], [Field(2)], [Field(100)]];

// state and actionsHash before applying actions
let initial = {
  state: Bool(false),
  actionsHash: Reducer.initialActionsHash,
};

let { state, actionsHash } = this.reducer.reduce(
  actions,
  stateType,
  (state: Bool, action: Field) => state.or(action.equals(1000)),
  initial
);
```

What we called `acc` above is now called `state`; we also have to pass in the state's type as a parameter. In addition, we have to pass in an `actionsHash` which refers to one particular point in the actions history. Like `Array.reduce`, `Reducer.reduce` takes a callback which has the signature `(state: S, action: A) => S`, where `S` is the `stateType` and `A` is the `actionType`. It returns the result of applying all the actions, in order, to the initial `state`. In this example, the returned `state` will be `Bool(true)`, because one of the actions in the list is `Field(1000)`. Reduce also returns the new actionsHash -- so you can store it for using it when you reduce the next batch of actions. One last difference to JS reduce is that this takes a _list of lists_ of actions instead of a flat list. Each of the sublists are the actions that were dispatched in one account update (e.g., while running one smart contract method).

An astute reader may have noticed that this is eerily similar to a standard "Elm architecture" -- this is because we have an instance of a scan over an implicit infinite stream of actions (though here that are aggregated in chunks) -- this is very similar to the problem that came up when processing transactions within the [Mina Protocol L1 with Snark Workers](https://minaprotocol.com/blog/fast-accumulation-on-streams). This may sound scary, but it should be familiar to web developers through its instantiation via the Redux library or more recently via the `useReducer` hook in React!

There is one interesting nuance here when compared to traditional Elm Architecture/Redux/useReducer instantiations: Because we're handling multiple actions concurrently in an undefined order, it is important that actions [commute](https://en.wikipedia.org/wiki/Commutative_property) against any possible state to prevent race conditions in your zkApp. Given any two actions a1 and a2 applying to some state s, `s * a1 * a2` means the same as `s * a2 * a1`.

### Reducer - API reference

```ts
reducer = Reducer({ actionType: AsFieldElements<A> });

this.reducer.dispatch(action: A): void;

this.reducer.reduce<S>(
  actions: A[][],
  stateType: AsFieldElements<S>,
  reduce: (state: S, action: A) => S,
  initial: { state: S, actionsHash: Field }
): { state: S, actionsHash: Field };

Reducer.initialActionsHash: Field;
```

In the near future, we want to add a function to retrieve actions from an archive node:

```ts
this.reducer.getActions({ fromActionsHash?: Field, endActionsHash?: Field }): A[][];
```

Right now, `getActions` is available for [testing with `LocalBlockchain`](/zkapps/how-to-test-a-zkapp).

### Actions for concurrent state updates

We imagine that one of the most important use cases for actions is to enable concurrent state updates. This is also why actions where originally added to the protocol.

A detailed explanation of the problem, and how actions can provide the solution, can be found here: https://github.com/o1-labs/snarkyjs/issues/265#issuecomment-1177512908

We also have a [full code example](https://github.com/o1-labs/snarkyjs/blob/main/src/examples/zkapps/reducer/reducer.ts) which demonstrates this pattern. Leveraging `Reducer.reduce`, it takes only about 30 lines of code to build a zkApp which handles concurrent state updates.

### Events vs Actions

[Events](events) and Actions are two distinct mechanisms for logging information alongside a transaction. Events are not meant for use within proofs directly as they can't be predicated on inside proofs. Events are used to signal to UIs, but can also be used for reconstructing merkle trees. Actions, on the other hand, can be accessed within provable code via Reducers as we see above. Both Events and Actions are not stored in the ledger and only exist on the transaction.


---
title: Custom Tokens
hide_title: true
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but zkApps can now be deployed to Berkeley Testnet.

:::

# Custom Token API

This section shows you how to perform common token operations, such as minting, burning, and sending tokens, using SnarkyJS.

## Minting

Minting generates new tokens whereby the zkApp updates the balance of an account by adding the newly created tokens to it. Minted tokens can be sent to any existing account in the ledger.

To mint new tokens using a zkApp, we access the `this.token` property on our `SmartContract` class. See the example below of how a zkApp can mint tokens to another account:

```ts
class MintExample extends SmartContract {
...
@method mintNewTokens(receiverAddress: PublicKey) {
    this.token.mint({
      address: receiverAddress,
      amount: 100_000,
    });
  }
}
```

In the snippet above, we define a smart contract called `MintExample` with a method called `mintNewTokens`. Using `this.token`, the smart contract specifies the address to mint new tokens for as well as the amount.

## Burning

Burning tokens is the opposite of minting. Burning tokens deducts the balance of a certain address by the specified amount. See the example below of how a zkApp can burn tokens of another account:

```ts
class BurnExample extends SmartContract {
...
@method burnTokens(addressToDecrease: PublicKey) {
    this.token.burn({
      address: addressToDecrease,
      amount: 100_000,
    });
  }
}
```

In the snippet above, we define a smart contract called `BurnExample` with a method called `burnTokens`. Similar to minting, we use the `this.token` property to call the `burn` method. This specifies the amount of tokens to burn for the specified address.

:::note

A zkApp cannot burn more tokens than the specified account has. If there is such a case, an error is thrown and no such transaction is made.

:::

## Sending

To send a custom token, use the `send()` method available on `this.token`. See the example below of how a zkApp can approve sending tokens between two accounts:

```ts
class SendExample extends SmartContract {
...
@method sendTokens(
    senderAddress: PublicKey,
    receiverAddress: PublicKey,
    amount: UInt64
  ) {
    this.token.send({
      to: receiverAddress,
      from: senderAddress,
      amount,
    });
  }
}
```

In the snippet above, we define a smart contract called `SendExample` with a method called `sendTokens`. Then, in the same fashion, as minting and burning, we use the `this.token` property to call the `send` method.

For a more comprehensive example of how to use custom tokens with a zkApp, please see this [custom token example](https://github.com/o1-labs/snarkyjs/blob/main/src/lib/token.test.ts)

## Authorization

When a zkApp interacts with a custom token that it did not originally create, the calling zkApp must get authorization from the [token owner](/zkapps/advanced-snarkyjs/custom-tokens#token-owner).

There are two ways for a token owner to approve a transaction, one being a **signature** and the other being a **proof**.

### Signature Authorization

Signature authorization is the simplest way for a token owner to approve a custom token transfer; however, it is the least flexible. If two separate accounts want to trade a specific custom token, the token owner must sign the transaction before the transaction can be broadcast.

Token zkApps should provide a `send()` method, like the one described above. By providing a `send()` method, the token zkApp can approve a transaction between two seperate accounts and sign it as the token owner.

```ts
let tx = await Mina.transaction(feePayerKey, () => {
  zkapp.sendTokens(senderAddress, receiverAddress, UInt64.from(1_000)); // Sends 1,000 tokens from `senderAddress` to `receiverAddress`
  zkapp.sign(zkappKey); // Signs the transaction with the token owner key
});
await tx.send();
```

This sort of authorization is simple and easy to use but it is not flexible. If two accounts wanted to trade a custom token, the token owner must sign the transaction before the transaction can be broadcasted. To allow zkApps to get authorization from a token owner without a signature, we can let the token owner approve with a proof.

### Proof Authorization

Proof authorization is a more flexible way for a token owner to approve a custom token transfer. If two separate accounts want to trade a specific custom token, the token owner can provide a proof that the transaction is valid. This allows the token owner to approve a transaction without signing it.

To allow for proof authorization by the token owner, the child zkApp that is requesting authorization must provide a way for the token owner to inspect the changes it wants to make and verify that they are valid. Token owner contracts have the power to inspect child account updates to enforce custom token rules. For example, a token owner contract could enforce that a child zkApp can only send tokens to a specific address.

Token owner contracts can inspect the updates that a child zkApp wants to make by using a combination of `Experimental.Callback` and `this.approve`. The first thing that a token contract must do is generate the account updates that a child zkApp wants to make. The child zkApp wraps a function around `Experimental.Callback` which contains the changes it wants to make. The token owner can then execute that function with `this.approve` and inspect the changes that the child zkApp wants to make.

See the example below of how a zkApp can approve a transaction between two accounts. In the first example, we will show how to approve a transaction by calling a specified `SmartContract` method.

```ts
/**
 * This TokenContract class is used to create a custom token
 * and acts as the token owner of the custom token
 */
class TokenContract extends SmartContract {
  ...

  /**
   * 'sendTokens()' sends tokens from `senderAddress` to `receiverAddress`.
   *
   * It does so by deducting the amount of tokens from `senderAddress` by
   * authorizing the deduction with a proof. It then creates the receiver
   * from `receiverAddress` and sends the amount.
   */
  @method sendTokens(
    senderAddress: PublicKey,
    receiverAddress: PublicKey,
    amount: UInt64,
    callback: Experimental.Callback<any>
  ) {
    // approves the callback which deductes the amount of tokens from the sender
    let senderAccountUpdate = this.approve(callback);

    // Create constraints for the sender account update and amount
    let negativeAmount = Int64.fromObject(
      senderAccountUpdate.body.balanceChange
    );
    negativeAmount.assertEquals(Int64.from(amount).neg());
    let tokenId = this.token.id;

    // Create receiver accountUpdate
    let receiverAccountUpdate = Experimental.createChildAccountUpdate(
      this.self,
      receiverAddress,
      tokenId
    );
    receiverAccountUpdate.balance.addInPlace(amount);
  }
}

class ZkAppB extends SmartContract {
  /*
  * This method is used to get authorization from the token owner. Remember,
  * the token owner is the one who created the custom token. To debit their
  * balance, we must get authorization from the token owner
  */
  @method approveSend(amount: UInt64) {
    this.balance.subInPlace(amount);
  }
}

let tx = await Local.transaction(feePayer, () => {
  let amount = UInt64.from(1_000)
  // Create a callback inside the transaction that calls the approveSend method.
  // This will be executed by the token owner to get authorization.
  let approveSendingCallback = Experimental.Callback.create(
    zkAppB,
    'approveSend',
    [amount]
  );
  // Here, we call the token contract with the callback
  tokenZkApp.sendTokens(zkAppBAddress, account1Address, amount, approveSendingCallback);
});
await tx.prove();
tx.sign([zkAppBKey]);
await tx.send();
```

The result of the example above is `zkAppB` sending tokens to `account1Address` and `account1Address` receiving tokens from `zkAppB`. The transaction is approved by the token owner without the token owner having to sign the transaction.

For more examples of how to approve a transaction with a zkApp, please see this [authorization example](https://github.com/o1-labs/snarkyjs/blob/main/src/examples/zkapps/token_with_proofs.ts).

## Understanding Important Terms

If you are writing your zkApp to interact with custom tokens, you should understand the following essential terms:

### Token Id

Token Ids are unique identifiers that are used to distinguish between different types of custom tokens. Custom token identifiers are globally unique across the entire network, meaning no two custom tokens can have the same token id.

Token Ids themeselves are derived from a zkApp. To check the token id of a zkApp, you can use the `this.token.id` property.

### Token Accounts

Token accounts are like regular accounts, but they hold a balance of a specific custom token instead of MINA. A token account is created from an existing account but is instead specified by a public key _and_ token id.
If an existing account receives a transaction that is specified by a custom token, a token account for that public key and token id will be created if it does not exist.

Token accounts are specific for each type of custom token, meaning that a single public key can have many different types of token accounts.

To create a token account for a specified custom token, a token account is automatically created for that public key whenever an existing account receives a transaction denoted with a custom token." to "A token account is automatically created for a public key whenever an existing account receives a transaction denoted with a custom token.

:::info

Suppose a token account is being created for the first time. In that case, an account creation fee must be paid similarly to creating a new standard account.

:::

Aside from sending custom tokens, custom tokens can be minted and burned by a **token owner account**. A token owner account is the governing zkApp account for a specific custom token.

### Token Owner

A token owner is an account that creates, facilitates, and governs how a custom token is to be used. Concretely, the token owner is the account that created the custom token and is the only account that can mint and burn tokens.

In addition to being the only account that can mint and burn tokens, the token owner is also the only account that can approve sending tokens between two accounts, by either using signature authorization or proof authorization.
If two accounts want to send tokens to each other, the token owner must approve the transaction. The token owner generates the changes the two accounts want to make and can then make assertions about those changes.
The token owner can approve the transaction either with a signature or proof.


---
title: Events
hide_title: true
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but zkApps can now be deployed to Berkeley Testnet.

:::

# Events

Events are _public_ arbitrary information that can be passed along with a transaction. Say, your zkApp allows users to publish a message -- those messages could be events!

Another use case for events are zkApps which keep some large internal state, and only store a commitment to that internal state on-chain. For example, a Merkle tree where only the root is stored in on-chain state. Events enable to attach the full information of state changes in transactions. In the Merkle tree example, this could mean sending any Merkle leaves that are changed by the transaction as events. This means that an observer of these transactions can follow along and keep track of the full Merkle tree on their side.

To use events, you have to declare an `events` field at the top level of your smart contract. It contains the _names_ and _types_ of your events. Here's an example:

```ts
class MyContract extends SmartContract {
  events = {
    'add-merkle-leaf': Field,
    'update-merkle-leaf': Field,
  };
}
```

In this example, we declare events called `"add-merkle-leaf"` and `"update-merkle-leaf"`, both with a type of `Field`. Instead of `Field`, you can also use other built-in SnarkyJS types as well as any `Struct`. (In fact, a custom `Struct` is probably better-suited to encode leaves of a Merkle tree -- we just use `Field` for simplicity here.)

After declaring your events, you can use `this.emitEvent(name, event)` in any smart contract method, where `event` has to have the type you declared for that `name`. Example:

```ts
class MyContract extends SmartContract {
  events = {
    "add-merkle-leaf": Field,
    "update-merkle-leaf": Field,
  }

  @method updateMerkleTree(leaf: Field, ...) {
    this.emitEvent("update-merkle-leaf", leaf);
    // ...
  }
}
```

Some other important facts about events:

- Events are not stored on-chain. Only events from the most recent couple of transactions are retained by consensus nodes. After that, they will be discarded, but are still accessible on archive nodes. In the near future, we plan to add an API to easily fetch events from an archive node.
- You can't refer to previously emitted events in a smart contract, because there is no way of proving that the events you refer to are actually the events emitted by that contract.

This is all you need to know about events! Think of them as a convenience feature -- a light-weight way of attaching information about your smart contract execution, which would otherwise get lost. Don't treat them as fully-fledged storage which can be safely accessed in smart contracts.

### Events: API reference

```ts
class SmartContract {
  static events?: Record<string, any>;

  emitEvent(name: string, event: any): void;
}
```

### Events vs Actions

Events and [Actions](actions-and-reducer) are two distinct mechanisms for logging information alongside a transaction. Events are not meant for use within proofs directly as they can't be predicated on inside proofs. Events are used to signal to UIs, but can also be used for reconstructing Merkle trees as we see above. Actions, on the other hand, can be accessed within provable code within a smart contract using a Reducer, because a commitment to the relevant actions (i.e. the "action state") is stored on the zkApp account. Neither Events nor Actions are stored directly in the Mina ledger and exist only in the transaction and on archive nodes.


---
title: Merkle Tree
hide_title: true
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but zkApps can now be deployed to Berkeley Testnet.

:::

# Merkle Tree

#### Referencing off-chain data

We already learned that zkApps can only store a small amount of data on-chain, the reason for that is we want Mina to stay succinct and not become bloated.
But some zkApps might require you to access more than what you can store on-chain in a zkApp account.
But how can we achieve that? The answer is a Merkle tree! Merkle trees (or similar structures such as Verkle trees) allow us to _reference_ off-chain data by
only storing one single hash on-chain!

#### How does that work?

Merkle trees are special binary trees in which every leaf (the nodes at the very bottom of the tree!) are cryptographic hashes of the underlying pieces of data and the internal nodes are labelled with the cryptographic hash of the concatenated labels (hashes) of its child nodes.

By following this algorithm to the very top, we end up with one single node (the root node) that stores the root hash of the tree. The root hash is a reference to all pieces of data that were included in the tree's leaves. By doing so, we achieve that we can reference large amounts of data by only using one small hash! Another thing that Merkle trees provide is something called the witness (sometimes also called Merkle proof or Merkle path) - the witness is the path from one specific leaf node to the very top of the tree - to the root! Merkle witnesses are proofs of inclusion exists, they allow us to prove that one specific piece of data(an account in the ledger or the scores on a leaderboard) exists within the entire tree.

#### How will that be useful for zkApps?

We just learned that we can reference large amounts of off-chain data and prove inclusion of very specific parts of that data only with a small hash - the root - and something called a witness.

When we want to use Merkle trees and reference off-chain data in our zkApps on Mina, we can simply store the root of the tree on-chain and voilÃ ,
we now have access to more data off-chain!

Let's imagine a zkApp that manages a game with a leaderboard. The zkApp has a method to update the score of a player, if the player guesses a number correctly.
Once a player reaches a threshold score, they can invoke another method to get a reward. Because we want many players to participate in our game,
we are drastically limited by how much data we can store on-chain - and if we want to have at least 8 or more participants, we will run out of on-chain space very fast!

A possible solution to that problem would be to utilize the power of Merkle trees and store the public keys of each player and their corresponding scores off-chain and only reference it in our smart contract.

Lets look at our data structure first. Imagine wanting to map a player's id to score points, so this:

```

0: 5 points
1: 3 points
2: 0 points
3: 8 points
... : ...
7: 2 points

```

#### Implementing the smart contract

Now it's time to look at what our leaderboard zkApp might look like. We want to have on-chain state that points to the off-chain Merkle tree - we will call this variable the `root`.

:::info

Sometimes the variable `root` is also called commitment, because we commit to something!

:::

Additionally, we want to store a variable `z` which is the hash of the value a player has to guess: `H(guess) = z`

:::info

Guessing a simple hash like in this example can easily be brute forced, especially if the preimage is something simple (like a 5 letter word or a small number with only a few digits).

Please make sure that your zkApps are always secure, especially when dealing with funds!

:::

The first method allows a player to make a guess, and if the guess is correct, the player will gain one point.
The method takes the players guess and hashes it, it then checks if the hash H(guess) equals the on-chain state z and if that's the case,
then the player gains one point on the score board.

We will also need a second method that takes care of the reward. It checks if the players score is over a threshold and pays out a reward if that's the case.
This method will also have to verify our Merkle witness and check it if it matches the on-chain stored Merkle root!

:::note

A fully working example, including all the necessary boilerplate code, can be found in the SnarkyJS repository in the examples folder [here](https://github.com/o1-labs/snarkyjs/tree/main/src/examples/zkapps/merkle_tree).

:::

```ts
class Leaderboard extends SmartContract {
  // the root is the root hash of our off-chain Merkle tree
  @state(Field) root = State<Field>();

  // z is the hashed number we want to guess!
  @state(Field) z = State<Field>();

  init() {
    super.init();

    // this is our hash we want to guess! its the hash of the preimage "22", but keep it a secret!
    this.z.set(
      Field(
        '17057234437185175411792943285768571642343179330449434169483610110583519635705'
      )
    );
  }

  @method guessPreimage(guess: Field, account: Account, path: MerkleWitness) {
    // we fetch z from the chain
    const z = this.z.get();
    this.z.assertEquals(z);

    // if our guess preimage hashes to our target, we won a point!
    Poseidon.hash([guess]).assertEquals(z);

    // we fetch the on-chain commitment/root
    const root = this.root.get();
    this.root.assertEquals(root);

    // we check that the account is within the committed Merkle Tree
    path.calculateRoot(account.hash()).assertEquals(root);

    // we update the account and grant one point!
    let newAccount = account.addPoints(1);

    // we calculate the new Merkle Root, based on the account changes
    const newRoot = path.calculateRoot(newAccount.hash());

    this.root.set(newRoot);
  }

  @method claimReward(account: Account, path: MerkleWitness) {
    // we fetch the on-chain commitment
    const root = this.root.get();
    this.root.assertEquals(root);

    // we check that the account is within the committed Merkle Tree
    path.calculateRoot(account.hash()).assertEquals(root);

    // we check that the account has at least 10 score points in order to claim the reward
    account.score.assertGte(UInt32.from(10));

    // finally, we send the player a reward
    this.send({
      to: account.address,
      amount: 100_000_000,
    });
  }
}
```

Merkle trees allow us to easily reference off-chain data by only adding a couple of lines of code.
However, it is important to mention that the developer of the zkApp must make sure that the Merkle tree that is being referenced on-chain is always in-sync with the actual off-chain data structure.

You can look at [this example in the SnarkyJS repository](https://github.com/o1-labs/snarkyjs/tree/main/src/examples/zkapps/merkle_tree) to get a better understanding of how you can utilize the power of Merkle trees.

:::info

Merkle trees are great for _referencing_ off-chain state. But just referencing our state is not enough - we also need to actually store it somewhere.

Where and how to store the data off-chain storage is left up to the developer. We will document a recommended method in time, but are currently exploring solutions and would be very interested to see and hear about approaches from others in the community.

:::

### Merkle Tree - API reference

```ts
const treeHeight = 8;

// creates a tree of height 8
const Tree = new MerkleTree(treeHeight);

// creates the corresponding MerkleWitness class that is circuit-compatible
class MyMerkleWitness extends MerkleWitness(treeHeight) {}

// sets a value at position 0n
Tree.setLeaf(0n, Field(123));

// gets the current root of the tree
const root = Tree.getRoot();

// gets a plain witness for leaf at index 0n
const witness = Tree.getWitness(0n);

// creates a circuit-compatible witness
const circuitWitness = new MyMerkleWitness(witness);

// calculates the root of the witness
const calculatedRoot = circuitWitness.calculateRoot(Field(123));

calculatedRoot.assertEquals(root);
```


---
title: On-Chain Values
hide_title: true
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but zkApps can now be deployed to Berkeley Testnet.

:::

# On-Chain Values

We already saw how you can access the current [on-chain state](/zkapps/how-to-write-a-zkapp#on-chain-state) of a zkApp account. Similarly, you can access many other on-chain values in a zkApp.

Just to give you an idea, here are two possible use cases:

- Say you want to let users vote on a proposal, but only within a specific timespan. To do that, you can make your zkApp require that the current timestamp lies in a certain range.
- In DeFi, you might need to compute amounts relative to a balance. For example, paying a yield of `0.001` times the account balance requires you to get the current on-chain balance.

We group on-chain values in two categories:

- **Network**: includes the current timestamp, block height, total Mina in circulation and other network state
- **Account**: includes fields and properties of the zkApp account, such as balance, nonce and delegate

The subfields of both categories are are accessible on `this.network` and `this.account` in your smart contract.
For example, the timestamp is on `this.network.timestamp`, and it has four methods on it:

```ts
this.network.timestamp.get();
this.network.timestamp.assertEquals(timestamp);
this.network.timestamp.assertBetween(lower, upper);
```

With two of them you are already familiar: On-chain state has the same `get()` and `assertEquals()` methods. `assertBetween()` gives you even more power: it allows you to make assert that the timestamp is between `lower` and `upper` (inclusive).

### Example: restricting timestamps

Let's see how `assertBetween()` can be used in the voting example mentioned earlier. Assume we want to allow voting throughout September 2022. Timestamps are represented as a `UInt64` in milliseconds since the [UNIX epoch](https://en.wikipedia.org/wiki/Unix_time). We can use the JS `Date` object to easily convert to this representation. In the simplest case, our zkApp could just hard-code the dates:

```ts
const startDate = UInt64.from(Date.UTC(2022, 9, 1));
const endDate = UInt64.from(Date.UTC(2022, 10, 1));

class VotingApp extends SmartContract {
  // ...

  @method vote(...) {
    this.network.timestamp.assertBetween(startDate, endDate);
    // ...
  }
}
```

A more refined example could store the current start date in an on-chain state variable, which can be reset by some process which is also encoded by the zkApp.

In addition to using a predefined range, you can also construct a range that depends on another variable, such as the current time. For example, a DEX with an order book could support orders that expire after an hour. So, the range should be `[now, now + 1h]`, such as below:

```ts
const now = this.network.timestamp.get();
this.network.timestamp.assertBetween(now, now.add(60 * 60 * 1000));
```

### Network reference

For completeness, below is the full list of network states you can use and make assertions about in your zkApp.

All of those fields have a `get()` and an `assertEquals()` method, and the subset that represent
"ordered values" (those that are `UInt32` or `UInt64`), also have `assertBetween()`.

Of course, there's no need to remember this -- just type `this.network.` and let IntelliSense guide you!

```ts
// current UNIX time in milliseconds, as measured by the block producer
this.network.timestamp.get(): UInt64;
// length of the blockchain, also known as block height
this.network.blockchainLength.get(): UInt32;
// total minted currency measured in units of 1e-9 MINA
this.network.totalCurrency.get(): UInt64;
// slots since genesis / hardfork -- a "slot" is the Mina-native time unit of 3 minutes
this.network.globalSlotSinceGenesis.get(): UInt32;
this.network.globalSlotSinceHardFork.get(): UInt32;
// hash of the snarked ledger -- i.e., the state of Mina included in the blockchain proof
this.network.snarkedLedgerHash.get(): Field;
// minimum window density in our consensus algorithm
this.network.minWindowDensity.get(): UInt32;
// consensus data relevant to the current staking epoch
this.network.stakingEpochData.ledger.hash.get(): Field;
this.network.stakingEpochData.ledger.totalCurrency.get(): UInt64;
this.network.stakingEpochData.epochLength.get(): UInt32;
this.network.stakingEpochData.seed.get(): Field;
this.network.stakingEpochData.lockCheckpoint.get(): Field;
this.network.stakingEpochData.startCheckpoint.get(): Field;
// consensus data relevant to the next, upcoming staking epoch
this.network.nextEpochData.ledger.hash.get(): Field;
this.network.nextEpochData.ledger.totalCurrency.get(): UInt64;
this.network.nextEpochData.epochLength.get(): UInt32;
this.network.nextEpochData.seed.get(): Field;
this.network.nextEpochData.lockCheckpoint.get(): Field;
this.network.nextEpochData.startCheckpoint.get(): Field;
```

### Account reference

Here's the full list of values you can access on the zkApp account. Like the network states, these have `get()` and `assertEquals()`.
Balance and nonce also have `assertBetween()`.

```ts
// the account balance; this might be nanoMINA or a custom token
this.account.balance.get(): UInt64;
// account nonce -- increases by 0 or 1 in every transaction
this.account.nonce.get(): UInt32;
// the account the zkApp delegates its stake to (default: its own address)
this.account.delegate.get(): PublicKey;
// boolean indicating whether an account is new (= didn't exist before the transaction)
this.account.isNew.get(): Bool;
// boolean indicating whether all 8 on-chain state fields where last changed by a transaction
// authorized by a zkApp proof (as opposed to a signature)
this.account.provedState.get(): Bool;
// hash receipt which includes all prior transaction to an account
this.account.receiptChainHash.get(): Field;
```

### Bailing out

In some rare cases, you might, for whatever reason, want to `get()` an on-chain value _without_ constraining it to any value.
If you try this, you'll see that SnarkyJS throws a helpful error reminding you to use `assertEquals()` and `asserBetween()`.
As an escape hatch, if you want to `get()` a value and are really sure you want to not constrain the on-chain value in any way,
there's `assertNothing()` on all of these fields (including on-chain state). **Use at your own risk.**

:::danger

`assertNothing()` should be rarely used and could cause security issues through unexpected behavior if used improperly. Be certain you know what you're doing before using this.

:::

### Setting account fields

Just like on-chain state, some account fields can be written to. Again, the API is consistent with state: `this.account.<field>.set(newValue)`.

For example, here's how you can change permissions on an account:

```ts
this.account.permissions.set({
  ...Permissions.default(),
  setVerificationKey: Permissions.impossible(),
});
```

And here's how you can set the delegate (the account that your smart contract delegates its stake to):

```ts
this.account.delegate.set(delegatePublicKey);
```

The fields that you can set are not the same as those that you can make assertions about. This is the full list that have a `.set()`, with short descriptions:

```ts
// the account that this account delegates its MINA stake to
this.account.delegate.set(value: PublicKey);
// the verification key
this.account.verificationKey.set(value: VerificationKey);
// account permissions, to control authorization for performing actions on the account
this.account.permissions.set(value: Permissions);
// currently unused - could become URL holding zkApp metadata
this.account.zkappUri.set(value: string);
// token symbol of the token owned by this account â€” only relevant for token contracts!
this.account.tokenSymbol.set(value: string);
// parameters to control a vesting schedule, used in time-locked accounts
this.account.timing.set(value: Timing);
```

### Accessing other accounts than the zkApp's

The API described in this section (get / set / assertEquals / ...) can not only be used to access the zkApp account itself, but also any other account.
To do so, just create an [account update](/zkapps/how-to-write-a-zkapp#transactions-and-account-updates) â€” you'll find the same `account` / `network` fields API on it:

```ts
let accountUpdate = AccountUpdate.create(address);

// use the balance of this account
let balance = accountUpdate.account.balance.get();
accountUpdate.account.balance.assertEquals(balance);

// assert that this account is new
accountUpdate.account.isNew.assertEquals(Bool(true));

// set permissions this account
accountUpdate.account.permissions.set(permissions);
```

:::tip
When setting fields on an account update, you have to make sure that this _same_ account update has the correct authorization to perform those actions.
For example, to initially set the verification key, the update will likely need a signature from the account owner:

```ts
// use createSigned to require a signature
let accountUpdate = AccountUpdate.createSigned(address);

// set the verification key on the account; could be used to deploy a zkApp from a zkApp
accountUpdate.account.verificationKey.set(vk);
```

:::


---
title: Permissions
hide_title: true
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

# Permissions

Permissions are an integral part of zkApp development - they determine who has the authority to interact and make changes to a specific part of a smart contract.
Naturally, it's important for every smart contract to have a set of sound permissions to prevent any attacks or security holes.
Permissions live on-chain, that means they are a part of the account representation on the network, and are checked every time an account updates tries to interact with an account.

## Types of Permissions


Currently, there are 11 different types of permissions that guard a zkApp account and a developer can access and adjust.

`editState`: The Permission corresponding to the 8 state fields associated with an account.
Every smart contract account has 8 fields of on-chain state. This permissions describes how those 8 fields can be manipulated.

`send`: The Permission corresponding to the ability to send transactions from this account.
This permission determines whether or not someone is able to send transaction (e.g. transfer MINA) from this particular account. 

`receive`: Similar to `send`, the Permission corresponding to the ability to receive transactions to this account.
Similar to send, it determines whether or not a particular account can receive transactions - for example, depositing MINA.

`setDelegate`: The Permission corresponding to the ability to set the delegate field of the account.
The delegate field is the address of another account, to whom this account is delegating its MINA to for staking.

`setPermissions`: The Permission corresponding to the ability to change the permissions of the account.
As the name might suggest, this type of permission describes how already set permissions can be changed.

`setVerificationKey`: The Permission corresponding to the ability to change the verification key of the account.
Every smart contract has a verification key stored on-chain. The verification key is used to verify off-chain proofs. This permission essentially describes if the verification key can be changed or not - we can also think of it as "upgradeability" of smart contracts.

`setZkappUri`:  The Permission corresponding to the ability to change the zkapp uri field of the account.
The `zkappUri` is a field that can be used to store some meta data about the smart contract (e.g. link to the source code). The permission determines how this field can be changed.

`editActionsState`: The Permission corresponding to the ability to change the actions state of the associated account.
Every smart contract can dispatch actions, which are committed to on-chain. This type of permission describes who can change that value.

`setTokenSymbol`: The Permission corresponding to the ability to set the token symbol for this account.
Similar to `setZkappUri` and `zkappUri`, this field stored the symbol of a token.

`incrementNonce`: The Permission that determine whether or not the nonce should be incremented with an account update.
This Permission determines who can increment the nonce on this account with a transaction.

`setVotingFor`: The permissions corresponding to the ability to set the chain hash for this account. 
The `votingFor` field is an on-chain mechanism to set the chain hash of the hard fork this account is voting for. 

`access`: This Permission is more restrictive than all the others combined! It corresponds to the ability to include any account update for this account in a transaction, even no-op account updates. Usually, this can be set to require no authorization. However, for [token manager contracts](custom-tokens), `access` should require at least proof authorization, so that token interactions must be approved by calling one of the token manager's methods.

`setTiming`: The permission corresponding to the ability to control the vesting schedule of time-locked accounts.

## Authorization

Permissions just describe who has the ability to execute an action, but they don't authorize it.
Currently, we have 5 types of authorizations: `none`, `impossible`, `signature`, `proof` and `proofOrSignature`.

We already know that a transaction consists of multiple account updates (sort of like instructions to the network) - and each account update has to be authorized in one way or another.
When you inspect an account update (either directly in SnarkyJS or using an explorer), you will notice a field `authorization` on the account update.
If this field has a proof attached, it means it's authorized by a proof, which will be checked against the verification key of the account. If it's a signature, that means the account update was authorized by a signature.

Here is an example of how this may look like: 

```json
{
    "authorization": {
        "proof": null,
        "signature": "7mXAcTFeybdZkFmYmfoRYRzVeMxQsGU5Uxq1RpRpGSkHEa5ZEraTRJ4cNKMnAS1n3NCmVqDnHUyraJs131dcdFi3sZH1Qzos"
    },
    // ...
    "body": {
        // ...
        "update": {
            "appState": [
                "1",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0",
                "0"
            ],
            // ...
        },
        // ...
    }
}
```

As you can see, this example account update has an authorization of kind `signature` provided, and you can also see it's trying to update the app state of the smart contract!
Let's consider a smart contract that has the permission `editState` set to the authorization `none`. 
This means, since the authorization is `none`, everyone can freely change the state of the smart contract as they please! Obviously, this is not something we likely want. So in order to only allow state changes when a valid proof accompanies the account update (which wants to access said state), we have to set our authorization to `proof`!
This makes sure that state is only being changed if and only if the user generated a valid proof by executing a smart contract method correctly!

Let's briefly go into detail what each authorization means:

`none`: Everyone has access to fields with permission set to `none` - and therefore can manipulate the fields as they please! 

`impossible`: If a fields permission is set to `impossible`, nothing can ever change this field!  

`signature`: Fields which have their permission set to `signature` can only be manipulated by account updates that are accompanied and authorized by a valid signature.

`proof`: Fields which have their permission set to `proof` can only be manipulated by account updates that are accompanied and authorized by a valid proof. Proofs are generated by proving the execution of a smart contract method.

`proofOrSignature`: As the name might suggest, permissions with authorization set to `proofOrSignature` accept both a valid signature or a valid proof. 

## The Default

Smart contracts, when first deployed, always start with a default set of permissions. 
Currently, the default is this:


`editState`: `proof`

`send`: `proof`

`receive`: `none`

`setDelegate`: `signature`

`setPermissions`: `signature`

`setVerificationKey`: `signature`

`setZkappUri`: `signature`

`editActionsState`: `proof`

`setTokenSymbol`: `signature`


## Example

To better understand how we can leverage permissions to make our smart contract more secure, let's look at a few examples.

### Sending MINA from smart contracts

Some smart contracts will not only manage state, but also token (such as the native MINA token). In order to prevent malicious actors from withdrawing all funds, we can use permissions to secure them.

Consider the following smart contract `UnsecureContract`, which is available [here](https://github.com/o1-labs/snarkyjs/blob/main/src/examples/zkapps/simple_zkapp_payment.ts) as well


```ts
class UnsecureContract extends SmartContract {
  init() {
    super.init();
    this.account.permissions.set({
      ...Permissions.default(),
      send: Permissions.none(),
    });
  }

  @method deposit(amount: UInt64) {
    let senderUpdate = AccountUpdate.createSigned(this.sender);
    senderUpdate.send({ to: this, amount });
  }
}
```


Our `UnsecureContract` has two methods: `withdraw` for withdrawing funds from the smart contract account and `deposit` for depositing funds into the smart contract account.
Also notice how we specify our permissions in the `init` method and set the permission for `send` to `Permissions.none()`? 
Because `none` means we don't have to provide *any* form of authorization, a malicious actor can easily drain all funds from the smart contract! Take a look at the following transaction that abuses that:


```ts
tx = await Mina.transaction(account1Address, () => {
  let withdrawal = AccountUpdate.create(zkappAddress);
  withdrawal.send({ to: account1Address, amount: 1e9 });
});
await tx.sign([account1Key]).send();
```

The transaction above creates a new account update for our smart contract address. Right after that, we tell our new account update to send 1 MINA to the address of our fee payer (account1Address).
At the end of our transaction block, we only sign the transaction with the private key of the fee payer - not the private key of the smart contract!
Because our permissions for sending funds away from a smart contract were set to `none`, this transaction will succeed and drain 1 MINA from the smart contract.

If we now change our `send` permission to something else, like `signature`,
our manual account update will fail with `Update_not_permitted_balance` which means we are not allowed to withdraw funds from the smart contract,
since our authorization does not fit the permission for `send` - which now requires a valid signature!

We can now slightly modify our withdraw-transaction to include a valid signature by adding requesting a signature on our `withdrawal` account update and providing the private key of the smart contract account to `tx.send([zkappKey]) `

```ts
tx = await Mina.transaction(account1Address, () => {
  let withdrawal = AccountUpdate.create(zkappAddress);
  withdrawal.send({ to: account1Address, amount: 1e9 });
  withdrawal.requireSignature();
});
await tx.sign([account1Key, zkappKey]).send();
```

Now that we have provided a valid signature and the smart contract requires a valid signatures for sending funds from the smart contract, our transaction will succeed!


### Upgradeability of smart contracts

Another important part of smart contract development is upgradeability.
By using permissions, we can either make our smart contract not upgradeable at all or upgradeable! 
On Mina, when we deploy a smart contract we generate a verification key from our contract source code, which will then be stored on-chain and used to verify proofs that belong to that smart contract.
We remember that one permission was called `setVerificationKey` - by modifying the authorization kind for this permission, we can make our smart contract upgradeable or not. 

#### Impossible

Let's start simple - our smart contract will not be upgradeable, and once a verification key is deployed, we will never be able to change it.


```ts
class UpgradeabilityImpossible extends SmartContract {
  init() {
    super.init();
    this.account.permissions.set({
      ...Permissions.default(),
      setVerificationKey: Permissions.impossible(),
    });
  }

  @method updateVerificationKey(vk: VerificationKey) {
    this.account.verificationKey.set(vk);
  }
}
```

The `UpgradeabilityImpossible` smart contract only has one method: `updateVerificationKey`. By invoking this method and providing a new verification key, we expect the verification key on-chain to change.
But since we also specify the `setVerificationKey` permission to be `impossible`, invoking that method will fail - essentially making our smart contract not upgradeable.

```ts
console.log('try upgrading vk');
tx = await Mina.transaction(feePayer, () => {
  zkapp.updateVerificationKey(newVerificationKey);
});
await tx.prove();
await tx.sign([feePayerKey, zkappKey]).send();
```

This transaction will try to replace the existing verification key with a new one, `newVerificationKey`, but since we can prevent that by setting the permissions for a verification key change to `impossible`,
we expect the transaction to fail.

Using the `LocalBlockchain`, we will get the following (expected) error:

`Error: Transaction verification failed: Cannot update field 'verificationKey' because permission for this field is 'Impossible'`

For the sake of security, it is important to mention that if we want to make our smart contract truly impossible to upgrade, we should also set the field `setPermissions` to `impossible`,
in order to prevent a zkApp developer from changing the permission `setVerificationKey` to, for example, `signature` - which would allow an actor to manipulate the verification key again.


#### Upgradeable with a proof

But there are situations where we might want our smart contract to be upgradeable!
Let's assume we want to modify our method `updateVerificationKey` to do some checks before we can update our verification key (this could be the result of a vote or other conditions).
For now, we just want to check that we provide a `x` which is greater than or equal to 5. If this check succeeds, we update our verification key.

```ts
@method updateVerificationKey(vk: VerificationKey, x: Field) {
    let y = Field(5);
    x.gte(y).assertTrue();

    this.account.verificationKey.set(vk);
}
```

Also, we have to update our permissions from `setVerificationKey`: `impossible` to `proof`, because we only want to change the verification key if we also provide a valid proof.

```ts
this.account.permissions.set({
    ...Permissions.default(),
    setVerificationKey: Permissions.proof(),
});
```

When we now try and invoke the `updateVerificationKey` method, our transaction will generate a valid smart contract execution proof, succeed and upgrade the verification key to a new one!

```ts
console.log('try upgrading vk');
tx = await Mina.transaction(feePayer, () => {
    zkapp.updateVerificationKey(newVerificationKey);
});
await tx.prove();
await tx.sign([feePayerKey, zkappKey]).send();
```


## Where to learn more


Our integration tests exercise the behavior of different permissions, including upgradeability. 
If you want to take a look, check out the [voting integration test](https://github.com/o1-labs/snarkyjs/blob/main/src/examples/zkapps/voting/test.ts#L50) as well as the [DEX integration test](https://github.com/o1-labs/snarkyjs/blob/main/src/examples/zkapps/dex/upgradability.ts).

---
title: Recursion
hide_title: true
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

Experimental. This API may change.

Specifically, we are looking into refactoring ZkProgram methods to explicitly return values rather than requiring them to be passed as further inputs.

:::

# Recursion

Kimchi, the proof system that backs SnarkyJS, supports arbitrary infinite recursive proof construction of circuits through integration with the Pickles recursive system. Recursion is an incredibly powerful primitive that has a wide-array of uses. Here's a few of them:

1. Mina uses linear recursive proofs to compress the blockchain, an infinitely growing structure, down to a constant size.
2. Mina also uses "rollup-like" tree-based recursive proofs to _in parallel_ compress transactions within blocks down to a constant size.
3. The [Mastermind game](link to example) uses linear recursive proofs, an example of an application-specific rollup, to progress the state-machine of the application without needing to sync back to the game.
4. App-specific rollups can use recursion to communicate to each other, sort like app chains using IBC or parachains using XCVM to send messages.

More generally, we can use recursion to verify any zero knowledge program as part of our zkApp.

## Overview

In SnarkyJS, we can use `ZkProgram()` to define the steps of our recursive program. Just like `SmartContract`s, `ZkProgram()`s have any number of methods and execute off-chain.

After performing your desired recursive steps, you'll likely want to settle the interaction on Mina's blockchain and can do this by embedding the  `ZkProgram` within a `SmartContract` method verifying the underlying proof of execution and extracting the output which can be used elsewhere in the method (like storing the output in app-state for example).

Similar to methods within the `SmartContract` class, inputs to `ZkProgram` are _private by default_ and never seen by the Mina network.  Unlike `SmartContract`s, the developer can choose the shape of the public input to all the methods within a `ZkProgram`.

## Recursively Verifying a simple program within a zkApp

Let's look at how this works with a simple example that has only one method that proves the public input it received is zero.

```typescript
import { Field, Experimental } from 'snarkyjs';

const SimpleProgram = Experimental.ZkProgram({
  publicInput: Field,

  methods: {
    run: {
      privateInputs: [],

      method(publicInput: Field) {
        publicInput.assertEquals(Field(0));
      },
    }
  }
});
```

Next, we compile this program:

```typescript
const { verificationKey } = await SimpleProgram.compile();
```

Now we can use it to create a proof:

```typescript
const proof = await SimpleProgram.run(Field(0));
```

And we can verify this proof from within any method of your `SmartContract` class:

```typescript
@method foo(proof: SimpleProgram.Proof) {
  proof.verify().assertTrue();
  const output: Field = proof.value;
  // ...the rest of our method.
  // For example, storing the output of the execution of the program we've
  // proven as on-chain state, if desired.
}
```

What we're doing in `foo` is taking the `SimpleProgram` proof as a private argument to the method, verifying that the execution was valid, and then using the output.

## Recursively Verifying a linear recursive program within a zkApp

This time we are going to write a recursive `ZkProgram` which we can use to create recursive zero-knowledge proofs. In other proof systems, this is extremely difficult to construct if it is even possible, but in SnarkyJS we can describe a recursive ZkProgram with a simple recursive function.

Here we'll write a program that describes a recursive operation of adding one repeatedly to a number. Note that we recursively depend on the older proof as a private argument to our method.

```typescript
import { SelfProof, Field, Experimental, verify } from 'snarkyjs';

const AddOne = Experimental.ZkProgram({
  publicInput: Field,

  methods: {
    baseCase: {
      privateInputs: [],

      method(publicInput: Field) {
        publicInput.assertEquals(Field(0));
      },
    },

    step: {
      privateInputs: [SelfProof],

      method(publicInput: Field, earlierProof: SelfProof<Field>) {
        earlierProof.verify();
        earlierProof.publicInput.add(1).assertEquals(publicInput);
      },
    },
  },
});
```

First we compile this program and make the base proof as before:

```typescript
const { verificationKey } = await AddOne.compile();

const proof = await AddOne.baseCase(Field(0));
```

This time we can use this proof as input to recursively add one again:

```typescript
const proof1 = await AddOne.step(Field(1), proof);
```

And we can repeat this as many times as we want:

```typescript
const proof2 = await AddOne.step(Field(2), proof1);
```

Finally we can verify the proof from within a SmartContract like we did above:

```typescript
@method foo(proof: Proof) {
  proof.verify().assertTrue();
  /* ... the rest of our method
   * For example using the total value as the fee for some other transaction. */
}
```

## Recursively Verifying a tree-based recursive program within a zkApp

Tree recursion is even more rarely seen in other proof systems and zk toolkits. This is used internally within Mina as part of its decentralized prover and sequencing mechanism for rollups, so it's supported very robustly by Kimchi.

Here we'll write a program that describes a very simple rollup for adding numbers:

```typescript
import { SelfProof, Field, Experimental, verify } from 'snarkyjs';

let RollupAdd = Experimental.ZkProgram({
  publicInput: Field,

  methods: {
    baseCase: {
      privateInputs: [],

      method(publicInput: Field) { },
    },

    step: {
      privateInputs: [SelfProof, SelfProof],

      method(
        publicInput: Field,
        left: SelfProof<Field>,
        right: SelfProof<Field>
      ) {
        left.verify();
        right.verify();
        // assert that the left and right equal this input
        left.publicInput.add(right.publicInput).assertEquals(publicInput);
      },
    },
  },
});
```

## Bonus: Using ZkPrograms outside of zkApps

You can also use ZkProgram directly to prove and verify arbitrary zero-knowledge programs (a.k.a. circuits).

```typescript
const { verificationKey } = await MyProgram.compile();

const proof = await MyProgram.base(Field(0));
```

Now we can directly verify a JSON-encoded version of the proof to get back a boolean value telling us if the proof is valid.

```typescript
import { verify } from 'snarkyjs';

const ok = await verify(proof.toJSON(), verificationKey);
```


---
title: Time-Locked Accounts
hide_title: true
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but zkApps can now be deployed to Berkeley Testnet.

:::

# Time-Locked Accounts

Time-locking allows you to pay someone in MINA or custom other tokens subject to a vesting schedule. This means that the tokens are initially locked, and only become available for withdrawal after a certain time, or gradually according to a certain schedule.

The zkApp feature that enables time-locking is the `timing` field, which is present on every account. It look like this:

```ts
type Account = {
  // ...
  timing: {
    isTimed: Bool;
    initialMinimumBalance: UInt64;
    cliffTime: UInt32;
    cliffAmount: UInt64;
    vestingPeriod: UInt32;
    vestingIncrement: UInt64;
  };
};
```

`isTimed` indicates whether this account is time locked. The other fields are parameters that allow us to define a vesting schedule in a very flexible manner. We will explain them in detail below. By default, accounts are not time locked, and `isTimed` will be `false` and all other properties will contain default values.

This graph shows how each of the timing properties affect the vesting schedule:

<figure>
  <img
    src="/img/timelocked.png"
    width="95%"
    alt="Timing parameters"
  />
</figure>

The red cross on the left marks the point in time where the `timing` field is set and `isTimed` switches from `false` to `true`. The orange line shows how the amount of unlocked tokens increases over time, until it finally reaches its maximum value and stays flat. At this point, `isTimed` flips from `true` back to `false`, because no tokens remain locked.

As you can see, the maximum amount of unlocked tokens is defined by the `initialMinimumBalance`. It is called "initialMinimumBalance" because, even though the tokens show up in the balance, they can't be withdrawn â€” in other words, the account has a a non-zero _minimum balance_. Initially, that minimum balance is equal to the amount of tokens locked (i.e. the initial minimum balance). Over time, the minimum balance decreases until it hits zero, which is the condition that makes `isTimed` false again.

The other timing-related properties are described as follows:

- `cliffTime`: the initial time period during which all tokens are locked. Note that 'time' is measured in Mina by 'slots', where 1 slot is 3min currently.
- `cliffAmount`: the quantity of tokens to be unlocked when the cliff time has elapsed. If this is greater or equal the 'initial minimum balance', all tokens will be unlocked after the cliff time elapses.
- `vestingPeriod`: After the cliff time elapses, tokens can be set to unlock periodically at a fixed interval, by a fixed quantity. The vesting period is the length of that interval.
- `vestingIncrement`: the quantity of tokens unlocked after each vesting period elapses.

:::note
Only one vesting schedule can be specified per account and it cannot be changed during the vesting period.

Because of this, when `isTimed` is set to `true`, the values of the timing fields are immutable and cannot be changed.
After all tokens are unlocked and `isTimed` flips back to `false`, the account timing will become mutable again.
:::

### Setting timing in SnarkyJS

In SnarkyJS, `timing` is one of the account fields that can be updated by using an account update:

```ts
accountUpdate.account.timing.set({ initialMinimumBalance, cliffTime, ...etc });
```

When setting this, all timing-related properties are required, except for `isTimed`, which will be set by the protocol automatically.

### Examples

Let's see how to correctly implement some simple example use cases.

#### Example 1: All tokens unlock after 1 week

If you simply want all tokens to unlock after a certain time, then the only properties you need to care about are `initialMinimumBalance`, `cliffTime`, and `cliffAmount`. We'll set `cliffAmount` equal to the `initialMinimumBalance` to ensure all tokens are unlocked when the cliff elapses. Both `vestingPeriod` and `vestingIncrement` are unused so we'll set them to their default values, 1 and 0:

```ts
// example: 10 MINA to lock
const tokensToLock = UInt64.from(10e9);

// calculate 1 week in slots
const cliffTime = UInt32.from((60 / 3) * 24 * 7);

accountUpdate.account.timing.set({
  initialMinimumBalance: tokensToLock,
  cliffTime,
  cliffAmount: tokensToLock,
  vestingPeriod: UInt32.from(1), // 0 is not allowed; default value is 1
  vestingIncrement: UInt64.from(0),
});

this.send({ to: accountUpdate, amount: tokensToLock });
```

#### Example 2: Linear vesting over 1 year

In this example, we won't use a cliff, we just want a certain number of tokens to vest linearly over 1 year. To do this, we set the `vestingPeriod` to equivalent to 1 month defined in slots, so that new tokens will be unlocked every month. The `vestingIncrement` is set to the total amount divided by 12, so that the total amount will be unlocked after 12 months. Both `cliffTime` and `cliffAmount` can just be set to 0.

```ts
// example: 100000 MINA to lock
const tokensToLock = UInt64.from(100000e9);

// calculate 1 month in slots
const vestingPeriod = UInt32.from(Math.round(((60 / 3) * 24 * 365) / 12));

// 1/12th of tokens unlocked every month
const vestingIncrement = UInt64.from(Math.round(tokensToLock / 12));

accountUpdate.account.timing.set({
  initialMinimumBalance: tokensToLock,
  cliffTime: UInt32.from(0),
  cliffAmount: UInt64.from(0),
  vestingPeriod,
  vestingIncrement,
});

this.send({ to: accountUpdate, amount: tokensToLock });
```


---
title: 'Tutorial 1: Hello World'
hide_title: true
sidebar_label: 'Tutorial 1: Hello World'
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

:::note

This tutorial was last tested with [Mina zkApp CLI](https://github.com/o1-labs/zkapp-cli) 0.6.4 and [SnarkyJS](https://www.npmjs.com/package/snarkyjs) 0.8.0.

:::

# Tutorial 1: Hello World

## Overview

In this tutorial, we will code a zkApp step by step, from start to finish.

We will write a basic smart contract that stores a number as on-chain state and contains logic to only allow this number to be replaced by its square (e.g. 2 -> 4 -> 16...). We will create this project using the [Mina zkApp CLI](https://www.npmjs.com/package/zkapp-cli), write our smart contract code, and then use a local Mina blockchain to interact with it.

Later tutorials will introduce further concepts and patterns. But we hope this helps you get started with SnarkyJS, zkApps, and programming with zero knowledge proofs. Then you can go further by reading the [zkApps docs](/zkapps) and additional tutorials.

You can find the full source code for this example [here](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/01-hello-world).

## Setup

First, install the [Mina zkApp CLI](https://github.com/o1-labs/zkapp-cli), if you havenâ€™t already.

#### Dependencies

You'll need the following installed to use the zkApp CLI:

- NodeJS 16+ (or 14 using `--experimental-wasm-threads`)
- NPM 6+
- Git 2+

If you have an older version installed, we suggest installing a newer version
using the package manager for your system: [Homebrew](https://brew.sh/) (Mac),
[Chocolatey](https://chocolatey.org/) (Windows), or apt/yum/etc (Linux). On
Linux, you may need to install a recent NodeJS version via NodeSource
([deb](https://github.com/nodesource/distributions#debinstall) or
[rpm](https://github.com/nodesource/distributions#rpminstall)), as recommended
by the NodeJS Project.

#### Installation

```sh
$ npm install -g zkapp-cli
```

To confirm it is installed, run:

```sh
$ zk --version
```

This tutorial has been tested as of Mina zkApp CLI version `0.6.4` and SnarkyJS `0.8.0`.

## Create a new project

Now that you have the tooling installed, we can start building our application.

First, create a new project using:

<!--

Configure `git` email and name, otherwise `zkapp-cli` project generation will return a non-zero exit code.

```sh
$ git config --global user.email "test@example.com"
$ git config --global user.name "Test"
```

-->

```sh
$ zk project 01-hello-world
```

This will create a directory named `01-hello-world` containing scaffolding for our project, including tools such as Prettier, ESLint, & Jest.

The zkApp CLI will ask if you would like to create an acompnanying ui project. Select none for this tutorial.

```
? Create an accompanying UI project too? â€¦
  next
  svelte
  nuxt
  empty
â¯ none
```

Let's change into this directory and list the contents to see what it created:

```sh
$ cd 01-hello-world
$ ls
LICENSE           build             jest.config.js    package-lock.json tsconfig.json
README.md         config.json       keys              package.json
babel.config.cjs  jest-resolver.cjs node_modules      src
```

We will be working mostly within the `src` directory, which will contain the TypeScript code for our smart contract. When we build or deploy (which automatically builds for us), our TypeScript will be compiled into JavaScript inside the `build` directory.

### Preparing the project

We will start by creating files for our project and deleting the default files that come with the new project.

First, delete the old files. Run:

```sh
$ rm src/Add.ts
$ rm src/Add.test.ts
$ rm src/interact.ts
```

And generate the new files for our project. Enter:

```sh
$ zk file src/Square
$ touch src/main.ts
```

The `zk file <name>` command created both `src/Square.ts` and `src/Square.test.ts` for us, but we won't worry about writing tests in this tutorial. We'll use `main.ts` as a script to interact with the smart contract and observe how it works. In later tutorials, we will see how to interact with a smart contract from the browser, like a typical end user, but for now we'll just use our `main.ts` script to do this.

Now, let's open `src/index.ts` in a text editor and change it to look like below. This file contains all exports we want to make available for consumption from outside our smart contract project, such as from a UI.

```ts src/index.ts
1 import { Square } from './Square.js';
2
3 export { Square };
```

### Building and running

:::info

The following commands are included for reference, and will fail if you run them at this point. This is because we haven't written the `Square` smart contract yet.

:::

To compile the TypeScript code into JavaScript, and run the JavaScript code, you'll type:

```
$ npm run build
$ node build/src/main.js
```

The first line creates JavaScript code in the build directory, while the second line runs the code in `src/main.ts`.

You can also combine these together into one line, such as:

```
$ npm run build && node build/src/main.js
```

This will run `main` if the build is successful.

## Write the zkApp Smart Contract

Now, the fun part! Let's write our smart contract: `src/Square.ts`. Line numbers are provided for convenience. A final version of what we're writing can be found [here](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/01-hello-world/src/Square.ts).

:::tip

This tutorial will walk through the `Square` smart contract linked above. We recommend that you copy and paste the entire file from that link, and then follow the tutorial with the finished code in place.

You can also copy and paste the code snippets into your project as you go - to avoid inserting the line numbers into your smart contract, copy these code snippets using the button provided. It will appear at the top right of the snippet box when you mouseover it.

:::

### Imports

First, open `src/Square.ts` in your editor, then add the following at the top of the file:

```ts src/Square.ts
1 import {
2   Field,
3   SmartContract,
4   state,
5   State,
6   method,
7 } from 'snarkyjs';
```

What each of these are:

- `Field`: The native "number" type in SnarkyJS. You can think of these as unsigned integers. These are the most basic type in SnarkyJS and are what all other SnarkyJS-compatible types are built on top of.
- `SmartContract`: The class that creates zkApp smart contracts.
- `state`: a convenience decorator used within zkApp smart contracts to create references to state stored on chain in a zkApp account.
- `State`: a class used within zkApp smart contracts to create state stored on chain in a zkApp account.
- `method`: a convenience decorator used within zkApp smart contracts to create new smart contract methods (i.e. functions). Methods that uses this decorator are the end user's entry points to interacting with our smart contract.

### Smart contract class

Now, we will write the smart contract. Write the following in your file:

```ts src/Square.ts
8
9 export class Square extends SmartContract {
10   @state(Field) num = State<Field>();
11
12 }
```

This creates a new smart contract called `Square` with one element of on-chain state named `num` of type `Field`. zkApps can have up to 8 fields worth of on-chain state, each storing up to 32 bytes (technically, 31.875 bytes or 255 bit) of arbitrary data. A later tutorial will discuss options for off-chain state.

Now, let's add our `init` method:

```ts src/Square.ts
8
9 export class Square extends SmartContract {
10   @state(Field) num = State<Field>();
11
12   init() {
13     super.init();
14     this.num.set(Field(3));
15   }
16
17 }
```

This method sets up the initial state of the smart contract on deployment.

Since we're extending `SmartContract`, which has its own initialization to perform, we also need to call `super.init()` to invoke this function on the base class.

Then we initialize our on-chain state, `num`, to a value of `3`.

We can also optionally [specify permissions](/zkapps/snarkyjs-reference/classes/SmartContract#setpermissions) here.

Lastly, we will add our update function:

```ts src/Square.ts
14     this.num.set(Field(3));
15   }
16
17   @method update(square: Field) {
18     const currentState = this.num.get();
19     this.num.assertEquals(currentState);
20     square.assertEquals(currentState.mul(currentState));
21     this.num.set(square);
22   }
23 }
```

The name `update` is arbitrary, but makes sense for our example. Notice that we use the `@method` decorator because we intend for this method to be invoked by end users, such as via a zkApp UI or our `main.ts` script in this case.

This method will contain our logic by which end users are allowed to update our zkApp's account state on chain. In this example, we are saying that if the user provides a number (e.g. 9) to the `update()` method that is the square of the existing on-chain state referred to as `num` (e.g. 3), then we'll update the `num` value stored on chain to the provided value (e.g. 9). If the user provides a number that does not meet these conditions, they will not be able to generate a proof or update the on-chain state.

This is accomplished through using "assertions" within our method. When a user invokes a method on a smart contract, all assertions must be true in order to generate the zero knowledge proof from that smart contract; the Mina network will only accept the transaction and update the on-chain state if the attached proof is valid. This is how we can achieve predictable behavior in an off-chain execution model.

Notice that we have `get()` and `set()` methods for retrieving and setting on-chain state. A smart contract retrieves the on-chain account state when it is first invoked if at least one `get()` exists within it. Similarly, using `set()` will change the transaction to indicate we want to change this particular on-chain state, but it will only be updated when the transaction is received by the Mina network if it contains a valid authorization (i.e. a proof usually).

Our logic also uses the `.mul()` method for multiplication of our values stored in fields. You can view all available methods in the [SnarkyJS reference](/zkapps/snarkyjs-reference). Keep in mind that _all functions used inside your smart contract must operate on SnarkyJS compatible data types (e.g. Fields and other types built on top of Fields)_. This is to say, functions from random NPM packages won't work inside our smart contract, because it's really a zero-knowledge circuit, unless the functions it provides operate on SnarkyJS-compatible data types.

**Importantly, data passed as an input to smart contract method in SnarkyJS is private and never seen by the network.** But you can also store data publicly on-chain when needed, such as we do with our `num` in this example. A later tutorial will cover an example leveraging privacy.

This completes the smart contract!

## Interacting with our smart contract

Next, we will write a script that interacts with our smart contract, so we can easily test it out, for purposes of this tutorial.

Open up `src/main.ts` in your editor. A complete version of this file can be found [here](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/01-hello-world/src/main.ts). Again, we recommend that you copy this whole file over to begin with, and then work through the tutorial steps with the complete file in place.

### Imports

Add the following:

```ts src/main.ts
1 import { Square } from './Square.js';
2 import {
3   isReady,
4   shutdown,
5   Field,
6   Mina,
7   PrivateKey,
8   AccountUpdate,
9 } from 'snarkyjs';
10
```

What each of these imports are:

- `isReady`: an asynchronous promise that tells us when SnarkyJS is loaded and ready. This is necessary because SnarkyJS contains WASM.
- `shutdown`: a function that closes our program.
- `Field`: SnarkyJS' unsigned integer type, that we've seen above.
- `Mina`: A local Mina blockchain. We will deploy our smart contract to this in order to interact with it as a user would.
- `PrivateKey`: a class with functions for manipulating private keys.
- `AccountUpdate`: a class that generates a data structure referred to as an AccountUpdate that can update zkApp accounts.

### Local Blockchain

Now add the following code to your `src/main.ts`:

```ts src/main.ts
11 await isReady;
12
13 console.log('SnarkyJS loaded')
14
15 const useProof = false;
16
17 const Local = Mina.LocalBlockchain({ proofsEnabled: useProof });
18 Mina.setActiveInstance(Local);
19 const { privateKey: deployerKey, publicKey: deployerAccount } = Local.testAccounts[0];
20 const { privateKey: senderKey, publicKey: senderAccount } = Local.testAccounts[1];
21
22 console.log('Shutting down')
23
24 await shutdown();
```

Now when you run

```sh
$ npm run build && node build/src/main.js
```

your main function should run!

In production, you'll [deploy your zkApp to Mina network](https://docs.minaprotocol.com/zkapps/how-to-deploy-a-zkapp). But this "local blockchain" allows us to speed up development and test the behavior of our smart contract locally. This local blockchain also provides pre-funded accounts (e.g. the `deployerAccount` above). Later tutorials will discuss how to deploy your zkApp to live Mina networks, such as Berkeley Testnet.

:::note

zkApp programmability is currently available on Berkeley Testnet, Mina's public testnet, which is in its final stages of testing before Mainnet.

:::

### Initializing our smart contract

Now, let's expand the `main.ts` file to initialize our smart contract. Comments are provided to break down each stage.

```ts src/main.ts
19 const { privateKey: deployerKey, publicKey: deployerAccount } = Local.testAccounts[0];
20 const { privateKey: senderKey, publicKey: senderAccount } = Local.testAccounts[1];
21
22 // ----------------------------------------------------
23
24 // Create a public/private key pair. The public key is our address and where we will deploy to
25 const zkAppPrivateKey = PrivateKey.random();
26 const zkAppAddress = zkAppPrivateKey.toPublicKey();
27
28 // create an instance of Square - and deploy it to zkAppAddress
29 const zkAppInstance = new Square(zkAppAddress);
30 const deployTxn = await Mina.transaction(deployerAccount, () => {
31   AccountUpdate.fundNewAccount(deployerAccount);
32   zkAppInstance.deploy();
33 });
34 await deployTxn.sign([deployerKey, zkAppPrivateKey]).send();
35
36 // get the initial state of Square after deployment
37 const num0 = zkAppInstance.num.get();
38 console.log('state after init:', num0.toString());
39
40 // ----------------------------------------------------
41
42 console.log('Shutting down')
43
44 await shutdown();
```

The above code will be similar for any smart contract that you create.

Try running this now with: `npm run build && node build/src/main.js`. The output should be:

```sh
$ npm run build && node build/src/main.js
...
SnarkyJS loaded
state after init: 3
Shutting down
```

### Updating our zkApp account with a transaction

Now let's try updating our local zkApp account with a transaction! Add the following:

```ts src/main.ts
38 console.log('state after init:', num0.toString());
39
40 // ----------------------------------------------------
41
42 const txn1 = await Mina.transaction(senderAccount, () => {
43   zkAppInstance.update(Field(9));
44 });
45 await txn1.prove();
46 await txn1.sign([senderKey]).send();
47
48 const num1 = zkAppInstance.num.get();
49 console.log('state after txn1:', num1.toString());
50
51 // ----------------------------------------------------
52
53 console.log('Shutting down')
54
55 await shutdown();
```

This code creates a new transaction that attempts to update the field to the value `9`. Because this follows the rules in the `update()` function that we are calling on the smart contract, this should pass. And if you run it, it should!

Use `npm run build && node build/src/main.js` again to run it:

```sh
$ npm run build && node build/src/main.js
...
SnarkyJS loaded
state after init: 3
state after txn1: 9
Shutting down
```

Now let's try adding a transaction that should fail - updating the state to `75`. Now that `num` is in state `9`, updating should only be possible with `81`.

```ts src/main.ts
49 console.log('state after txn1:', num1.toString());
50
51 // ----------------------------------------------------
52
53 try {
54   const txn2 = await Mina.transaction(senderAccount, () => {
55     zkAppInstance.update(Field(75));
56   });
57   await txn2.prove();
58   await txn2.sign([senderKey]).send();
59 } catch (ex: any) {
60   console.log(ex.message);
61 }
62 const num2 = zkAppInstance.num.get();
63 console.log('state after txn2:', num2.toString());
64
65 // ----------------------------------------------------
66
67 console.log('Shutting down')
68
69 await shutdown();
```

Run this again with `npm run build && node build/src/main.js`. The output should be:

```sh
$ npm run build && node build/src/main.js
...
SnarkyJS loaded
state after init: 3
state after txn1: 9
assert_equal: 75 != 81
state after txn2: 9
Shutting down
```

And lastly, to show the correct update:

```ts src/main.ts
63 console.log('state after txn2:', num2.toString());
64
65 // ----------------------------------------------------
66
67 const txn3 = await Mina.transaction(senderAccount, () => {
68   zkAppInstance.update(Field(81));
69 });
70 await txn3.prove();
71 await txn3.sign([senderKey]).send();
72
73 const num3 = zkAppInstance.num.get();
74 console.log('state after txn3:', num3.toString());
75
76 // ----------------------------------------------------
77
78 console.log('Shutting down');
79
80 await shutdown();
```

Run this again with `npm run build && node build/src/main.js`. The output should be:

```sh
$ npm run build && node build/src/main.js
...
SnarkyJS loaded
state after init: 3
state after txn1: 9
assert_equal: 75 != 81
state after txn2: 9
state after txn3: 81
Shutting down
```

## Conclusion

Congrats! We have finished building our first zkApp with SnarkyJS.

Checkout [Tutorial 2](private-inputs-hash-functions) to learn how to use private inputs and hash functions with SnarkyJS.


---
title: 'Tutorial 2: Private Inputs and Hash Functions'
hide_title: true
sidebar_label: 'Tutorial 2: Private Inputs and Hash Functions'
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

:::note

This tutorial was last tested with [SnarkyJS](https://www.npmjs.com/package/snarkyjs) 0.8.0.

:::

# Tutorial 2: Private Inputs and Hash Functions

## Overview

In our previous tutorial, [Hello World](hello-world), we saw how to build a basic zkApp smart contract in SnarkyJS, with a single state variable, that could be updated if a user knew the square of that number.

In this tutorial, we will discuss private inputs and hash functions.

With a zkApp, a user's local device generates one or more zero knowledge proofs, which are then verified by the Mina network. Each method in a SnarkyJS smart contract corresponds to constructing a proof.

As such, _all inputs to a smart contract are private by default_, and never seen by the blockchain, unless the developer chooses to store those values as on-chain state in the zkApp account.

We will build a smart contract with a piece of private state, that can be modified if a user knows the private state.

## Setup

The following steps assume you've installed dependencies to your machine as described in the [previous tutorial](hello-world) â€” if not, please do that first.

Now, setup a new project with:

```sh
$ zk project 02-private-inputs-and-hash-functions
```

Delete the default generated files by running:

```sh
$ rm src/Add.ts
$ rm src/Add.test.ts
$ rm src/interact.ts
```

And create new files:

```sh
$ zk file src/IncrementSecret
$ touch src/main.ts
```

And lastly, change `index.ts` to:

```ts
import { IncrementSecret } from './IncrementSecret.js';

export { IncrementSecret };
```

:::tip

You can find the complete source code of this project [here](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/02-private-inputs-and-hash-functions). We recommend that you copy the entire [main.ts](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/02-private-inputs-and-hash-functions/src/main.ts) and [IncrementSecret.ts](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/02-private-inputs-and-hash-functions/src/IncrementSecret.ts) files into your project now, and follow this tutorial with the code in place.

:::

## Writing our smart contract

Now we'll build the smart contract for our application.

Begin by writing:

```ts
  1 import { Field, SmartContract, state, State, method, Poseidon } from 'snarkyjs';
  2
  3 export class IncrementSecret extends SmartContract {
  4   @state(Field) x = State<Field>();
  5 }
```

This just adds the basic setup for our smart contract â€” see [Tutorial 01 Hello World](hello-world) for more on this.

Now, we will add an `initState()` method. This is intended to run once to set up the initial state on the zkApp account.

```ts
...
  5
  6   @method initState(salt: Field, firstSecret: Field) {
  7     this.x.set(Poseidon.hash([ salt, firstSecret ]));
  8   }
  9 }
```

Our `initState()` method accepts our secret, and a value called a "salt", which we will discuss later.

Note that these inputs to our `initState()` method are private to whomever initializes the contract. Nobody looking at the zkApp account on the chain can see or know what values `firstSecret` or `salt` actually are.

Next we will add a method to update our state:

```ts
...
  9
 10   @method incrementSecret(salt: Field, secret: Field) {
 11     const x = this.x.get();
 12     this.x.assertEquals(x);
 13
 14     Poseidon.hash([ salt, secret ]).assertEquals(x);
 15     this.x.set(Poseidon.hash([ salt, secret.add(1) ]));
 16   }
 17 }
```

Mina uses the Poseidon hash function, which has been optimized for fast performance inside zero knowledge proof systems. The Poseidon hash function takes in an array of Fields, and returns a single Field as output.

In this smart contract, we use both a secret number, and a second Field, known as a "salt".

In the `incrementSecret()` method, we check that the hash of the salt and our secret is equal to the current state `x`. If this is the case, we add `1` to the secret and set `x` to the hash of the salt and this new secret. SnarkyJS creates a proof of this fact, and a JSON description of the state updates to be made on the zkApp account, such as to store our new hash value, which together form a transaction that can be sent to the Mina network to update the zkApp account.

Because zkApp smart contracts are run off chain, our salt and secret remain private and are never transmitted anywhere. Only the result, updating `x` on-chain state to `hash([ salt, secret + 1])` is revealed. Because the salt and secret can't be deduced from their hash, they remain private.

### But why the extra `salt` argument?

The extra `salt` argument is added to avoid a possible attack on our smart contract. If we were to just use `secret`, it would be vulnerable to discovery by an attacker. To do this, our attacker could try hashing likely secrets and then check if the hash matches the hash stored in the smart contract. If the hash were to match, then the attacker would have known they had discovered the secret. This is particularly concerning if the secret is likely to be within a particular subset of possible values, say between 1 and 10,000. In that case, with just 10,000 hashes, the attacker could discover our secret.

What we can do to fix this, is add a second value as an input to our hash function, known as a "salt". The salt will be known only to us and is typically random for optimal security. Using this second value as an additional input to our hash function ensures that an attacker cannot simply brute force attack our secret by generating hashes for likely values of it, because too many possibilities exist.

## Main

Our `src/main.ts` is similar to our last tutorial â€” for a full version of `src/main.ts`, see [here](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/02-private-inputs-and-hash-functions/src/main.ts).

Key parts to discuss though, are initializing our contract, and using the poseidon hash.

Our smart contract initialization this time will be:

```ts
...
 24 const salt = Field.random();
...
 33 const deployTxn = await Mina.transaction(deployerAccount, () => {
 34   AccountUpdate.fundNewAccount(deployerAccount);
 35   zkAppInstance.deploy();
 36   zkAppInstance.initState(salt, Field(750));
 37 });
...
```

Note that the `initState()` method accepts the salt and our secret, in this case the number `750`.

And here is how one can create a user transaction to update the on-chain state:

```ts
...
 47 const txn1 = await Mina.transaction(senderAccount, () => {
 48   zkAppInstance.incrementSecret(salt, Field(750));
 49 });
...
```

We call the zkApp smart contract with both the salt and the secret itself, the number `750`. Because zkApp smart contracts are executed locally, neither the secret nor the salt will make it into the transaction.

Instead, the transaction will include only the proof that the update was called in such a way that all assertions passed and an update to the on-chain state `x` where we store the hash value. After the transaction is processed by the Mina network, `x` will be the value of `Poseidon.hash([ salt, Field(750).add(1) ])`, but the underlying salt and secret will not be revealed.

Try running `main` for yourself:

```sh
$ npm run build && node build/src/main.js
```

The output should look something like this:

```
...
SnarkyJS loaded
state after init: 3116464240601550031577632290308565252747064306168758166756574536757280262269
state after txn1: 15333363135506653312218020664441564145350761288169575380089681962972642150348
Shutting down
```

The `state` strings will be different though, because we used `Field.random()` to generate the salt.

## Conclusion

Congrats! We have finished building a smart contract that uses privacy and hash functions.

Checkout [Tutorial 3](deploying-to-a-network) to learn how to deploy zkApps to a live network.


---
title: 'Tutorial 3: Deploying to a Live Network'
hide_title: true
sidebar_label: 'Tutorial 3: Deploying to a Live Network'
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

:::note

This tutorial was last tested with [SnarkyJS](https://www.npmjs.com/package/snarkyjs) 0.8.0.

:::

# Tutorial 3: Deploying to a Live Network

## Overview

In previous tutorials, we've seen how to deploy and run transactions on a local network. In this tutorial, we will see how to deploy against a real, live network.

Mina's zkApps are currently available on Berkeley, Mina's public testnet, which is in its final stages of testing before Mainnet. In this tutorial, we will deploy our contract to the Berkeley Testnet. Berkeley is feature complete, and only minor changes and bugfixes are expected before Mainnet.

We will reuse the same smart contract from [Tutorial 1](hello-world), the `Square` contract.

## Project setup

First, as usual, setup a new project with

```sh
$ zk project 03-deploying-to-a-live-network
```

To start, delete the default generated files by running:

```sh
$ rm src/Add.ts
$ rm src/Add.test.ts
$ rm src/interact.ts
```

And create a new file for our smart contract:

```sh
$ zk file src/Square
```

Copy in `src/Square.ts` and `src/index.ts` from the first tutorial - you can find these [here](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/01-hello-world/src).

That's all for setup - let's proceed to deploying to Berkeley Testnet.

## Deploying the smart contract

A CLI tool is provided for convenience for deploying smart contracts to networks. If you need more custom account creation for your zkApp - say deploying a zkApp to a different key than the fee payer key, programmatically parameterizing a zkApp before initializing it, or creating a Smart Contract programmatically for users as part of an application - see the server-side tutorial mentioned in the [conclusion](#conclusion).

### zk config

`zk config` is a tool provided for managing CLI deployments. It will create a `config.json` in our project's directory, as well as a `keys` folder, containing private and public keys for our application.

To use, run:

```sh
$ zk config
```

It will ask you to specify a name (can be anything), URL to deploy to, and fee (in
MINA) to be used when sending your deploy transaction. The URL is the Mina GraphQL API
that will receive your deploy transaction and broadcast it to the Mina network.
Note that this URL is significant because it also determines which network you will
be deploying to (e.g. QANet, Testnet, Mainnet, etc).

For Berkeley Testnet, let's use the following values:

- **Name**: `berkeley`
- **URL**: `https://proxy.berkeley.minaexplorer.com/graphql`
- **Fee**: `0.1`

:::tip
If your project contains multiple smart contracts (e.g. `Foo` and `Bar`) that
you intend to deploy to the same network, we recommend following a naming
pattern such as `berkeley-foo` and `berkeley-bar` when naming your deploy
aliases. You can change their names at anytime within `config.json`.
:::

<br />

You will see the following output:

```sh
$ zk config

Add a new network:
âœ” Choose a name (can be anything): Â· berkeley
âœ” Set URL to deploy to: Â· https://proxy.berkeley.minaexplorer.com/graphql
âœ” Set transaction fee to use when deploying (in MINA): Â· 0.1
âœ” Create key pair at keys/berkeley.json
âœ” Add network to config.json

Success!

Next steps:

- If this is a testnet, request tMINA at:
  https://faucet.minaprotocol.com/?address=<YOUR-ADDRESS>
- To deploy, run: `zk deploy berkeley`
```

This command also generates keys, in `keys/berkeley.json`, that we will use in our application.

## Request funds from the faucet

To deploy your zkApp, you will need some funds to pay for transaction fees.

To get funds on the Berkeley Testnet, use the URL that was shown from the CLI output. Visit `https://faucet.minaprotocol.com/?address=<YOUR-ADDRESS>` and click **Request**.

You will have to wait a few minutes for the next block to include your transaction, so you'll have tMINA before proceeding to the next step.

## Deploy your smart contract

To deploy your smart contract to the network, run the following command:

```sh
$ zk deploy berkeley
```

When running the deploy command, the zkApp CLI will compute a verification key for your smart contract. Computing the verification key can take 1-2 minutes, so please be patient. The zkApp CLI will show you the details of the transaction such as the network name, the URL, and the smart contract that will be deployed.

Finally, enter `yes` or `y` when prompted, to confirm and send the transaction.

You will see the following output:

```sh
$ zk deploy berkeley

âœ” Build project
âœ” Generate build.json
âœ” Choose smart contract
  Only one smart contract exists in the project: Add
  Your config.json was updated to always use this
  smart contract when deploying to this network.
âœ” Generate verification key (takes 10-30 sec)
âœ” Build transaction
âœ” Confirm to send transaction
  Are you sure you want to send (yes/no)? Â· y
âœ” Send to network

Success! Deploy transaction sent.

Next step:
  Your smart contract will be live (or updated)
  as soon as the transaction is included in a block:
  https://berkeley.minaexplorer.com/transaction/<txn-hash>
```

After a few minutes, the transaction will be included in the next block. Visit `https://berkeley.minaexplorer.com/transaction/<txn-hash>` to see the transaction in progresss.

Once the transaction is included in a block, your smart contract is deployed!

This means, the Mina account at this public key now contains the verification key associated with this smart contract.

Because we didn't modify our smart contract's `editState` permissions when writing in Tutorial 1, a transaction must contain a valid ZK proof created by the private key associated with this zkApp account, in order to be accepted by the zkApp account. Typically, you'll only allow proof authorization. More instruction on setting permissions will come in a later tutorial.

When a user interacts with this smart contract by providing a proof, the proof is generated locally on the user's device, and included in a transaction. When the transaction is submitted to the network, Mina will check the proof, to know it is correct and matches the on-chain verification key. After it is accepted, the proof and transaction will be recursively proved, and bundled into Mina's recursive ZKP.

When we change our code, the verification key associated with it will change, and the contract should be redeployed using the same steps as our initial deployment.

## Conclusion

We have finished deploying to a live network using the zkApp CLI!

If you would like to learn how to build server-side scripts that interact with zkApps, see that tutorial [here](./interacting-with-zkapps-server-side).

Checkout [Tutorial 4](zkapp-ui-with-react) to learn how to zkApp UIs with ReactJS that run in the browser with a wallet.


---
title: 'Tutorial 4: Building a zkApp UI in the Browser with React'
hide_title: true
sidebar_label: 'Tutorial 4: Building a zkApp UI in the Browser with React'
---

# Tutorial 4: Building a zkApp UI in the Browser with React

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

## Overview

In previous tutorials, we've seen how to [write zkApps](hello-world) and [deploy them to a network](deploying-to-a-network).

In this tutorial, we will implement a browser UI using ReactJS that interacts with a smart contract running on Berkeley.

We will discuss how to setup our project, implement its functionality, and deploy it to Github Pages.

If you would like to try out the application before going through the tutorial, you can do so on an instance already deployed to a Github Pages [here](https://es92.github.io/zkApp-examples/index.html). Extra info is printed to the console as well when it is run, to give an idea of what it is doing internally.

### What we will build

The application we build will implement the following:

1. Loading a public key from an extension-based wallet (tested with [Auro](https://www.aurowallet.com/) >= 2.1.2)
2. Checking if the public key has funds, and direct the user to the faucet if not.
3. Connecting to example zkApp `Add` smart contract, already deployed on Berkeley testnet at a fixed address.
4. A button that when clicked sends a transaction.
5. A button that when clicked requests the latest state of the smart contract.

Like in tutorial 3, we will provide a couple of helper files, so we can focus on the React implementation itself. What is special about these helpers though, is that they use a webworker. This ensures the UI thread isn't blocked during long computations like compiling a smart contract or proving a transaction.

This example uses an RPC endpoint. An in-browser Mina node is in the works, which will provide full node level security to your users, in the browser.

## Project setup

First, setup a new project with

```sh
$ zk project 04-zkapp-browser-ui --ui next
```

On the prompts that appear, select:

1. Do you want your NextJS project to use TypeScript? `yes`
2. Do you want to setup your project for GitHub pages? `yes`

This will create a new project with two folders instead of just one:

- `contracts`: This stores your smart contract code
- `ui`: This is where you will write your ui

We will be using the default contract (`Add`), so all we'll be doing is building it for use from our ui.

To do this, enter the `contracts` folder, and run the build command:

```sh
$ cd contracts/
$ npm run build
```

In making your own zkApp, you will need to edit files in the `contracts` folder, and rebuild before accessing it from your UI.

## Implementing the UI

Our React UI will have a few components. First, there is the react page itself. In addition though, there is code that uses SnarkyJS.

Because SnarkyJS code is computationally intensive, running it as usual in a script would block our browser's UI thread, causing our page to become unresponsive at times. To solve this, we will put our SnarkyJS code in a web worker.

This will be implemented via 2 helper files:

- `zkappWorker.ts`: The web worker code itself
- `zkappWorkerClient.ts`: Code that we run from react to interact with the web worker.

We encourage you to read these files, to understand how they work and to extend them for your own zkApp, but we will not review them in detail here, in favor of spending time on the react code.

Download these files from [here](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/04-zkapp-browser-ui/ui/pages/zkappWorker.ts) and [here](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/04-zkapp-browser-ui/ui/pages/zkappWorkerClient.ts), and place them in your `ui/pages` folder.

### globals.css

We will be using an `<a>` link in our application - add the following to the end of `ui/styles/globals.css` to style the link:

```css
a {
  color: blue;
}
```

### Running the react app

To run the react app, open up two new terminals in the `ui` folder. In one, type:

```sh
$ npm run dev
```

And in the other,

```sh
$ npm run ts-watch
```

The first of these starts hosting your application, by default at `localhost:3000`. Your browser will refresh automatically when your page has changes.

The second shows typescript errors. You can watch this as you develop to check for type errors.

### Implementing the react app

Open up `ui/pages/_app.page.tsx` in your editor. You can find the full contents for this file [here](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/04-zkapp-browser-ui/ui/pages/_app.page.tsx) for reference.

Edit the contents so it looks like this:

```ts
  1 import '../styles/globals.css'
  2 import { useEffect, useState } from "react";
  3 import './reactCOIServiceWorker';
  4
  5 import ZkappWorkerClient from './zkappWorkerClient';
  6
  7 import { PublicKey, Field } from 'snarkyjs';
  8
  9 let transactionFee = 0.1;
 10
 11 export default function App() {
 12   return <div/>
 13 }
 14
```

This just sets up our react project, with the imports we'll need, and an empty component.

Now, we'll add state to our app:

```ts
...
 11 export default function App() {
 12   let [state, setState] = useState({
 13     zkappWorkerClient: null as null | ZkappWorkerClient,
 14     hasWallet: null as null | boolean,
 15     hasBeenSetup: false,
 16     accountExists: false,
 17     currentNum: null as null | Field,
 18     publicKey: null as null | PublicKey,
 19     zkappPublicKey: null as null | PublicKey,
 20     creatingTransaction: false,
 21   });
 22
 23   // -------------------------------------------------------
 24
 25   return <div/>
...
```

This creates mutable state that we can reference in our UI, and update as our application runs. You can learn more about react state and useState [here](https://reactjs.org/docs/hooks-state.html).

Next, we'll add a function to setup our application:

```ts
...
 23   // -------------------------------------------------------
 24   // Do Setup
 25
 26   useEffect(() => {
 27     (async () => {
 28       if (!state.hasBeenSetup) {
 29         const zkappWorkerClient = new ZkappWorkerClient();
 30
 31         console.log('Loading SnarkyJS...');
 32         await zkappWorkerClient.loadSnarkyJS();
 33         console.log('done');
 34
 35         await zkappWorkerClient.setActiveInstanceToBerkeley();
 36
 37         // TODO
 38       }
 39     })();
 40   }, []);
 41
 42   // -------------------------------------------------------
...
```

We use the react feature "useEffect", so that this is only run once. See more on useEffect [here](https://reactjs.org/docs/hooks-effect.html). We further gate running this effect by a boolean `hasBeenSetup` so we don't run this more than once.

This is also where we setup our web worker client. This will interact with our web worker running SnarkyJS code, so that that code doesn't block the UI thread.

```ts
...
 35         await zkappWorkerClient.setActiveInstanceToBerkeley();
 36
 37         const mina = (window as any).mina;
 38
 39         if (mina == null) {
 40           setState({ ...state, hasWallet: false });
 41           return;
 42         }
 43
 44         const publicKeyBase58: string = (await mina.requestAccounts())[0];
 45         const publicKey = PublicKey.fromBase58(publicKeyBase58);
 46
 47         console.log('using key', publicKey.toBase58());
 48
 49         console.log('checking if account exists...');
 50         const res = await zkappWorkerClient.fetchAccount({
 51           publicKey: publicKey!
 52         });
 53         const accountExists = res.error == null;
 54
 55         // TODO
 56       }
...
```

Continuing, we load our zkApp in the web worker. We load the contract, compile it, create a instance of it at a fixed address, and get its current state:

```ts
...
 53         const accountExists = res.error == null;
 54
 55         await zkappWorkerClient.loadContract();
 56
 57         console.log('compiling zkApp');
 58         await zkappWorkerClient.compileContract();
 59         console.log('zkApp compiled');
 60
 61         const zkappPublicKey = PublicKey.fromBase58(
 62           'B62qiqD8k9fAq94ejkvzaGEV44P1uij6vd6etGLxcR4dA8ZRZsxkwvR'
 63         );
 64
 65         await zkappWorkerClient.initZkappInstance(zkappPublicKey);
 66
 67         console.log('getting zkApp state...');
 68         await zkappWorkerClient.fetchAccount({ publicKey: zkappPublicKey })
 69         const currentNum = await zkappWorkerClient.getNum();
 70         console.log('current state:', currentNum.toString());
 71
 72         // TODO
 73       }
...
```

And lastly for this function, we update the state of the react app:

```ts
...
 70         console.log('current state:', currentNum.toString());
 71
 72         setState({
 73             ...state,
 74             zkappWorkerClient,
 75             hasWallet: true,
 76             hasBeenSetup: true,
 77             publicKey,
 78             zkappPublicKey,
 79             accountExists,
 80             currentNum
 81         });
 82       }
 83     })();
...
```

Now that we have finished setting up our UI, we write a new effect, that waits for the account to exist, if it didn't exist before.

If the account has been newly created for example, it will need to be funded from the faucet. We'll add in our UI later a link to request funds for new accounts.

```ts
...
 86   // -------------------------------------------------------
 87   // Wait for account to exist, if it didn't
 88
 89   useEffect(() => {
 90     (async () => {
 91       if (state.hasBeenSetup && !state.accountExists) {
 92         for (;;) {
 93           console.log('checking if account exists...');
 94           const res = await state.zkappWorkerClient!.fetchAccount({ 
 95             publicKey: state.publicKey!
 96           })
 97           const accountExists = res.error == null;
 98           if (accountExists) {
 99             break;
100           }
101           await new Promise((resolve) => setTimeout(resolve, 5000));
102         }
103         setState({ ...state, accountExists: true });
104       }
105     })();
106   }, [state.hasBeenSetup]);
107
108   // -------------------------------------------------------
...
```

Moving on, we'll create functions that are triggered when a button is pressed by a user.

First, a function that will send a transaction:

```ts
...
108   // -------------------------------------------------------
109   // Send a transaction
110
111   const onSendTransaction = async () => {
112     setState({ ...state, creatingTransaction: true });
113     console.log('sending a transaction...');
114
115     await state.zkappWorkerClient!.fetchAccount({
116       publicKey: state.publicKey!
117     });
118
119     await state.zkappWorkerClient!.createUpdateTransaction();
120
121     console.log('creating proof...');
122     await state.zkappWorkerClient!.proveUpdateTransaction();
123
124     console.log('getting Transaction JSON...');
125     const transactionJSON = await state.zkappWorkerClient!.getTransactionJSON()
126
127     console.log('requesting send transaction...');
128     const { hash } = await (window as any).mina.sendTransaction({
129       transaction: transactionJSON,
130       feePayer: {
131         fee: transactionFee,
132         memo: '',
133       },
134     });
135
136     console.log(
137       'See transaction at https://berkeley.minaexplorer.com/transaction/' + hash
138     );
139
140     setState({ ...state, creatingTransaction: false });
141   }
142
143   // -------------------------------------------------------
...
```

And second, a function that will get the latest zkApp state:

```ts
...
143   // -------------------------------------------------------
144   // Refresh the current state
145
146   const onRefreshCurrentNum = async () => {
147     console.log('getting zkApp state...');
148     await state.zkappWorkerClient!.fetchAccount({
149          publicKey: state.zkappPublicKey!
150     })
151     const currentNum = await state.zkappWorkerClient!.getNum();
152     console.log('current state:', currentNum.toString());
153
154     setState({ ...state, currentNum });
155   }
156
157   // -------------------------------------------------------...
```

Lastly, we will update the `return <div/>` placeholder we originally inserted, with a ui to show the user the state of our application:

```ts
...
157  // -------------------------------------------------------
158   // Create UI elements
159 
160   let hasWallet;
161   if (state.hasWallet != null && !state.hasWallet) {
162     const auroLink = 'https://www.aurowallet.com/';
163     const auroLinkElem = (
164       <a href={auroLink} target="_blank" rel="noreferrer">
165         {' '}
166         [Link]{' '}
167       </a>
168     );
169     hasWallet = (
170       <div>
171         {' '}
172         Could not find a wallet. Install Auro wallet here: {auroLinkElem}
173       </div>
174     );
175   }
176 
177   let setupText = state.hasBeenSetup
178     ? 'SnarkyJS Ready'
179     : 'Setting up SnarkyJS...';
180   let setup = (
181     <div>
182       {' '}
183       {setupText} {hasWallet}
184     </div>
185   );
186 
187   let accountDoesNotExist;
188   if (state.hasBeenSetup && !state.accountExists) {
189     const faucetLink =
190       'https://faucet.minaprotocol.com/?address=' + state.publicKey!.toBase58();
191     accountDoesNotExist = (
192       <div>
193         Account does not exist. Please visit the faucet to fund this account
194         <a href={faucetLink} target="_blank" rel="noreferrer">
195           {' '}
196           [Link]{' '}
197         </a>
198       </div>
199     );
200   }
201 
202   let mainContent;
203   if (state.hasBeenSetup && state.accountExists) {
204     mainContent = (
205       <div>
206         <button
207           onClick={onSendTransaction}
208           disabled={state.creatingTransaction}
209         >
210           {' '}
211           Send Transaction{' '}
212         </button>
213         <div> Current Number in zkApp: {state.currentNum!.toString()} </div>
214         <button onClick={onRefreshCurrentNum}> Get Latest State </button>
215       </div>
216     );
217   }
218 
219   return (
220     <div>
221       {setup}
222       {accountDoesNotExist}
223       {mainContent}
224     </div>
225   );
226 }

```

We divide our UI into 3 sections:

- `setup` lets the user know when the zkApp has finished loading.
- `accountDoesNotExist` gives the user a link to the faucet if their account hasn't been funded.
- `mainContent` shows the current state of the zkApp, and buttons to interact with it.

The buttons allow the user to create a transaction, or refresh the current state of the application, by triggering the `onSendTransaction()` and `onRefreshCurrentNum()` functions we wrote above.

And that's it! We've finished the code for our application.

If you've been using `npm run dev`, you should now be able to interact with this application on `localhost:3000`, with all the functionality we've implemented over the tutorial.

## Deploying the UI to Github Pages

To deploy our project to Github, first push it to a new Github repo. The Github repo must have the same name as the project name when we ran zk project above (in this example, `04-zkapp-browser-ui`). If not, change the existing project name strings in `next.config.js`, and `pages/reactCOIServiceWorker.ts` to your repo name.

To deploy, just run `npm run deploy` in the `ui` directory. After the script builds your application, uploads it to Github, and Github processes it, your application will be available at:

```
https://<username>.github.io/<repo-name>/index.html
```

## Conclusion

We have built a React UI for our zkApp, to allow users to interact with our smart contract and send transactions to Berkeley Testnet!

You can build a UI for your application using any UI framework, not just React. The zkApp CLI will also soon provide support for simultaneously creating SvelteKit and NuxtJS projects too - stay tuned!

Checkout [Tutorial 5](common-types-and-functions) to learn about different SnarkyJS types you can use in your application.


---
title: 'Tutorial 5: Common Types and Functions'
hide_title: true
sidebar_label: 'Tutorial 5: Common Types and Functions'
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

:::note

This tutorial was last tested with [SnarkyJS](https://www.npmjs.com/package/snarkyjs) 0.8.0.

:::

# Tutorial 5: Common Types and Functions

In previous tutorials, we've seen how to deploy smart contracts to the network, and we've interacted with them from both a React UI and NodeJS.

In this tutorial, we will talk about more types that are useful when building with SnarkyJS, so you can build more applications. So far, we've mostly been using the `Field` type. SnarkyJS provides other higher-order types built from Fields, that will be useful for your development.

You can find all of these on the [SnarkyJS Reference page](../snarkyjs-reference), for their full API documentation.

There is also a project [here](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/05-common-types-and-functions/src), with a [main.ts](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/05-common-types-and-functions/src/main.ts) demoing the concepts presented in this tutorial, along with smart contracts showing more advanced usage of some of the concepts, particularly Merkle Trees.

## Basic Types

To start, we'll discuss 5 basic types derived from the Fields:

- [Bool](../snarkyjs-reference/classes/Bool)
- [UInt32](../snarkyjs-reference/classes/UInt32)
- [UInt64](../snarkyjs-reference/classes/UInt64)
- [Int64](../snarkyjs-reference/classes/Int64)
- [Character](../snarkyjs-reference/classes/Character)

These each have their usual programming language semantics.

For example, we can have the following code:

```ts
const num1 = UInt32.from(40);
const num2 = UInt64.from(40);

const num1EqualsNum2: Bool = num1.toUInt64().equals(num2);

console.log(`num1 === num2: ${num1EqualsNum2.toString()}`);
console.log(`Fields in num1: ${num1.toFields().length}`);

// --------------------------------------

const signedNum1 = Int64.from(-3);
const signedNum2 = Int64.from(45);

const signedNumSum = signedNum1.add(signedNum2);

console.log(`signedNum1 + signedNum2: ${signedNumSum}`);
console.log(`Fields in signedNum1: ${signedNum1.toFields().length}`);

// --------------------------------------

const char1 = Character.fromString('c');
const char2 = Character.fromString('d');
const char1EqualsChar2: Bool = char1.equals(char2);

console.log(`char1: ${char1}`);
console.log(`char1 === char2: ${char1EqualsChar2.toString()}`);
console.log(`Fields in char1: ${char1.toFields().length}`);
```

And when run it'll print to the console:

```
num1 === num2: true
Fields in num1: 1
signedNum1 + signedNum2: 42
Fields in signedNum1: 2
char1: c
char1 === char2: false
Fields in char1: 1
```

## More Advanced Types

4 more advanced types are:

- [CircuitString](../snarkyjs-reference/classes/CircuitString)
- [PrivateKey](../snarkyjs-reference/classes/PrivateKey)
- [PublicKey](../snarkyjs-reference/classes/Types.PublicKey)
- [Signature](../snarkyjs-reference/classes/Signature)

All arguments passed into smart contracts need to be arguments SnarkyJS can understand. This means that we can't just pass normal strings - we need to pass in strings that have been wrapped to be compatible with circuits, which is what `Struct` accomplishes.

One special thing to note, is that the default `CircuitString` has a max length of 128 characters. This is because, under the hood, SnarkyJS types have to be fixed length. However, the `CircuitString` API abstracts this away and can be used like a dynamic length string, with the only caveat being the max length.

We'll see in the following section how to create custom types, where you could for example build your own strings, modified to whatever length you would like.

A brief example of using these:

```ts
const str1 = CircuitString.fromString('abc..xyz');
console.log(`str1: ${str1}`);
console.log(`Fields in str1: ${str1.toFields().length}`);

// --------------------------------------

const zkAppPrivateKey = PrivateKey.random();
const zkAppPublicKey = zkAppPrivateKey.toPublicKey();

const data1 = char2.toFields().concat(signedNumSum.toFields());
const data2 = char1.toFields().concat(str1.toFields());

const signature = Signature.create(zkAppPrivateKey, data2);

const verifiedData1 = signature.verify(zkAppPublicKey, data1).toString();
const verifiedData2 = signature.verify(zkAppPublicKey, data2).toString();

console.log(`private key: ${zkAppPrivateKey.toBase58()}`);
console.log(`public key: ${zkAppPublicKey.toBase58()}`);
console.log(`Fields in private key: ${zkAppPrivateKey.toFields().length}`);
console.log(`Fields in public key: ${zkAppPublicKey.toFields().length}`);

console.log(`signature verified for data1: ${verifiedData1}`);
console.log(`signature verified for data2: ${verifiedData2}`);

console.log(`Fields in signature: ${signature.toFields().length}`);
```

And the console output:

```
str1: abc..xyz
Fields in str1: 128
private key: EKEdDGiN9Zd9TaSPcNjs3nB6vs9JS3WCgdsrfyEeLcQpnXNR7j6E
public key: B62qoGDUnJGdiD8MPEs4Lo76kWXSNbJD6Dn8HzkaBSfhZQWShJC8gEe
Fields in private key: 255
Fields in public key: 2
signature verified for data1: false
signature verified for data2: true
Fields in signature: 256
```

Small but important note: Make sure that you never use the private key above (or any private key that's publicly accessible) in a real application!

If you're curious why there are 255 Fields in a private key and 256 in a signature - the reason for this is cryptographic in nature: Elliptic curve scalars are most efficiently represented in a SNARK as an array of bits, and the bit length of these scalars happens to be 255.

## Struct

A special type is [Struct](../snarkyjs-reference#struct), which lets you create your own compound data types.

Your Struct can be defined as one or more data types that SnarkyJS understands, i.e. Field, higher-order types built into SnarkyJS based on Field, or other Struct types defined by you. You can also define methods on your Struct to act upon this data type, if desired, but doing so is optional.

See the following for an example of how to use `Struct`, implementing a `Point` structure, and an array of points of length 8 structure.

SnarkyJS compiles programs into fixed sized circuits. This means that data structures it consumes must also be a fixed size, and is why we declare the array in `Points8` structure to be a static size of 8 in the example below.

```ts
class Point extends Struct({ x: Field, y: Field }) {
  static add(a: Point, b: Point) {
    return { x: a.x.add(b.x), y: a.y.add(b.y) };
  }
}

const point1 = { x: Field(10), y: Field(4) };
const point2 = { x: Field(1), y: Field(2) };

const pointSum = Point.add(point1, point2);

console.log(`pointSum Fields: ${Point.toFields(pointSum)}`);

class Points8 extends Struct({
  points: [Point, Point, Point, Point, Point, Point, Point, Point],
}) {}

const points = new Array(8)
  .fill(null)
  .map((_, i) => ({ x: Field(i), y: Field(i * 10) }));
const points8: Points8 = { points };

console.log(`points8 JSON: ${JSON.stringify(points8)}`);
```

Which prints the following to the console:

```
pointSum Fields: 11,6
points8 Fields: {"points":[{"x":"0","y":"0"},{"x":"1","y":"10"},{"x":"2","y":"20"},{"x":"3","y":"30"},{"x":"4","y":"40"},{"x":"5","y":"50"},{"x":"6","y":"60"},{"x":"7","y":"70"}]}
```

## Control flow

There are two functions which help do control flow within SnarkyJS:

- [Circuit.if](../snarkyjs-reference/classes/Circuit#if)
- [Circuit.switch](../snarkyjs-reference/classes/Circuit#switch)

`Circuit.if` is similar to a ternary in JavaScript. `Circuit.switch` is similar to a switch case statement in JavaScript.

With these, you can write conditionals inside SnarkyJS.

For example:

```ts
const input1 = Int64.from(10);
const input2 = Int64.from(-15);

const inputSum = input1.add(input2);

const inputSumAbs = Circuit.if(
  inputSum.isPositive(),
  inputSum,
  inputSum.mul(Int64.minusOne)
);

console.log(`inputSum: ${inputSum.toString()}`);
console.log(`inputSumAbs: ${inputSumAbs.toString()}`);

const input3 = Int64.from(22);

const input1largest = input1
  .sub(input2)
  .isPositive()
  .and(input1.sub(input3).isPositive());
const input2largest = input2
  .sub(input1)
  .isPositive()
  .and(input2.sub(input3).isPositive());
const input3largest = input3
  .sub(input1)
  .isPositive()
  .and(input3.sub(input2).isPositive());

const largest = Circuit.switch(
  [input1largest, input2largest, input3largest],
  Int64,
  [input1, input2, input3]
);

console.log(`largest: ${largest.toString()}`);
```

With output:

```
inputSum: -5
inputSumAbs: 5
largest: 22
```

Note that when using `Circuit.if`, like in a JS ternary, both branches are executed. Unlike normal programming, because SnarkyJS under the hood is creating a zk circuit, there is no primitive for if statements where only one branch is executed.

## Assertions and Constraints

SnarkyJS functions are compiled to generate circuits.

When a transaction is proven in SnarkyJS, SnarkyJS is proving that the program logic is computed according to the written program, and all assertions are holding true.

We've seen assertions already, with `a.assertEquals(b)`, which we've often used. There is also `.assertTrue()` available on the Bool class.

Circuits in SnarkyJS currently have a fixed maximum size. Each operation performed in a function counts towards this maximum size. This maximum size is currently equivalent to the following:

- about 5,200 hashes on two fields
- about 2,600 hashes on four fields
- about `2^17` field multiplies
- about `2^17` field additions

If a program is too large to fit into these constraints, it can be broken up into multiple recursive proof verifications. See more on how to do this in the section [here](../advanced-snarkyjs/recursion).

## Merkle Trees

Lastly, let's go over an example using [merkle trees](../snarkyjs-reference/classes/MerkleTree). Merkle trees are very powerful, since they let us manage large amounts of data within a circuit. In the [project corresponding to this tutorial](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/05-common-types-and-functions/src), you can find a full reference for the example here. The contract can be found in [BasicMerkleTreeContract.ts](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/05-common-types-and-functions/src/BasicMerkleTreeContract.ts), and the example can be found in a section of [main.ts](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/05-common-types-and-functions/src/main.ts).

Start off by importing `MerkleTree`:

```ts
import {
  ...
  MerkleTree,
  ...
} from 'snarkyjs'
```

Merkle Trees can be created in your application like so:

```ts
const height = 20;
const tree = new MerkleTree(height);
```

The height variable determines how many leaves are available to your application. A height of 20 for example will lead to a tree with `2^(20-1)`, or 524,288 leaves.

Merkle trees in smart contracts are stored as the hash of the merkle tree's root. Smart contract methods which update the merkle root can take a "witness" of the change as an argument, which represents the merkle path to the data for which inclusion is being proved.

Here is a simple example of a contract that stores the root of a merkle tree, where each leaf stores a number, and the smart contract has an `update` function that adds a number to the leaf. As an example of putting a condition on a leaf update, the `update` function checks that the number added was less than 10.

```ts
...
  @state(Field) treeRoot = State<Field>();
...
  @method initState(initialRoot: Field) {
    this.treeRoot.set(initialRoot);
  }

  @method update(
    leafWitness: MerkleWitness20,
    numberBefore: Field,
    incrementAmount: Field
  ) {
    const initialRoot = this.treeRoot.get();
    this.treeRoot.assertEquals(initialRoot);

    incrementAmount.assertLt(Field(10));

    // check the initial state matches what we expect
    const rootBefore = leafWitness.calculateRoot(numberBefore);
    rootBefore.assertEquals(initialRoot);

    // compute the root after incrementing
    const rootAfter = leafWitness.calculateRoot(
      numberBefore.add(incrementAmount)
    );

    // set the new root
    this.treeRoot.set(rootAfter);
  }
```

And code to interact with it:

```ts
// initialize the zkapp
const zkApp = new BasicMerkleTreeContract(basicTreeZkAppAddress);
await BasicMerkleTreeContract.compile();

// create a new tree
const height = 20;
const tree = new MerkleTree(height);
class MerkleWitness20 extends MerkleWitness(height) {}

// deploy the smart contract
const deployTxn = await Mina.transaction(deployerAccount, () => {
  AccountUpdate.fundNewAccount(deployerAccount);
  zkApp.deploy();
  // get the root of the new tree to use as the initial tree root
  zkApp.initState(tree.getRoot());
});
await deployTxn.prove();
deployTxn.sign([deployerKey, basicTreeZkAppPrivateKey]);

const pendingDeployTx = await deployTxn.send();
/**
 * `txn.send()` returns a pending transaction with two methods - `.wait()` and `.hash()`
 * `.hash()` returns the transaction hash
 * `.wait()` automatically resolves once the transaction has been included in a block. this is redundant for the LocalBlockchain, but very helpful for live testnets
 */
await pendingDeployTx.wait();

const incrementIndex = 522n;
const incrementAmount = Field(9);

// get the witness for the current tree
const witness = new MerkleWitness20(tree.getWitness(incrementIndex));

// update the leaf locally
tree.setLeaf(incrementIndex, incrementAmount);

// update the smart contract
const txn1 = await Mina.transaction(senderPublicKey, () => {
  zkApp.update(
    witness,
    Field(0), // leafs in new trees start at a state of 0
    incrementAmount
  );
});
await txn1.prove();
const pendingTx = await txn1.sign([senderPrivateKey, zkAppPrivateKey]).send();
await pendingTx.wait();

// compare the root of the smart contract tree to our local tree
console.log(
  `BasicMerkleTree: local tree root hash after send1: ${tree.getRoot()}`
);
console.log(
  `BasicMerkleTree: smart contract root hash after send1: ${zkApp.treeRoot.get()}`
);
```

While in this example leaves are fields, you can put more variables in a leaf by instead hashing an array of fields, and setting a leaf to that.

You can find this complete example in the [project directory](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/05-common-types-and-functions/src), as well as a more advanced example `LedgerContract`, which implements a basic ledger of tokens, including checks that the sender has signed their transaction and that the amount the sender has sent matches the amount the receiver receives.

## Merkle Map

Lastly, let's go over an example using [merkle maps](../snarkyjs-reference/classes/MerkleMap). These allow us to implement key value stores.

The API for Merkle Maps is similar to Merkle Trees, just instead of using an index to set a leaf, one uses a key:

```ts
const map = new MerkleMap();

const key = Field(100);
const value = Field(50);

map.set(key, value);

console.log('value for key', key.toString() + ':', map.get(key));
```

Which prints:

```
value for key 100: 50
```

It can be used inside smart contracts with a witness, similar to merkle trees

```ts
...
  @state(Field) mapRoot = State<Field>();
...
  @method init(initialRoot: Field) {
    this.mapRoot.set(initialRoot);
  }
  @method update(
    keyWitness: MerkleMapWitness,
    keyToChange: Field,
    valueBefore: Field,
    incrementAmount: Field,
  ) {
    const initialRoot = this.mapRoot.get();
    this.mapRoot.assertEquals(initialRoot);

    incrementAmount.assertLt(Field(10));

    // check the initial state matches what we expect
    const [ rootBefore, key ] = keyWitness.computeRootAndKey(valueBefore);
    rootBefore.assertEquals(initialRoot);

    key.assertEquals(keyToChange);

    // compute the root after incrementing
    const [ rootAfter, _ ] = keyWitness.computeRootAndKey(valueBefore.add(incrementAmount));

    // set the new root
    this.treeRoot.set(rootAfter);
  }
```

With (abbreviated) code to interact with it, similar to the merkle tree example above:

```ts
const map = new MerkleMap();

const rootBefore = map.getRoot();

const key = Field(100);

const witness = map.getWitness(key);
...
// update the smart contract
const txn1 = await Mina.transaction(deployerAccount, () => {
  zkapp.update(
    contract.update(
      witness,
      key,
      Field(50),
      Field(5)
    );
  );
});
...
```

MerkleMaps can be used to implement many useful patterns. For example:

- A key value store from public keys to booleans, of token accounts to whether they've participated in a voted yet.
- A nullifier that privately tracks if an input was used, without revealing it.

## Conclusion

Congrats! We have finished reviewing more common types and functions in SnarkyJS. With this, you should now be capable of writing many advanced smart contracts and zkApps.

Checkout [Tutorial 6](offchain-storage) to learn how to use off-chain storage, to use more data from your zkApp.


---
title: 'Tutorial 6: Off-Chain Storage'
hide_title: true
sidebar_label: 'Tutorial 6: Off-Chain Storage'
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

:::note

This tutorial was last tested with [SnarkyJS](https://www.npmjs.com/package/snarkyjs) 0.8.0.

:::

# Tutorial 6: Off-Chain Storage

## Overview

:::caution
This tutorial provides a single-server solution to data storage. This is useful for prototyping zkApps and building zkApps where some trust guarantees are reasonable, but should not be used for zkApps that require trustlessness. It is intended as one of several options for data availability on Mina.

If you are interested in improving this library to make it more decentralized and useful in production, see the [further development](#further-development-of-single-server-off-chain-storage) section below.
:::

In [Tutorial 5, Common Types and Functions](common-types-and-functions), we ended by learning about merkle trees, and how we can use them to refer to large amounts of data stored off chain, by storing only the tree's root hash on chain

In this tutorial, we will share a library and pattern for working with storing merkle trees off-chain, with only the root of the merkle tree stored on chain.

We intend for this tutorial to be useful towards unlocking a larger set of applications that require off-chain storage. Other solutions are intended to follow that provide more decentralized options for zkApps that need more trustless solutions.

Feel free to skip ahead to the [implementation section](#implementing-a-project-using-off-chain-storage) If you want to jump into how to use single server off-chain storage for prototyping applications. Otherwise, read on to understand more about the different options for off-chain storage, their tradeoffs, and how the single-server solution shared here fits in.

## Why Off-Chain Storage?

When building an application we'll just use locally and for testing, its fine to just build and store a merkle root locally.

However, when building a production-ready, distributed zkApp, we need more than this. All users interacting with our zkApp need to be able to retrieve the latest state, and modify it.

If this isn't the case, and someone were able to modify the tree without sharing their modification, the lack of data availability for the new version means that further writes, by other parties that don't have access to the new tree, become impossible. This requires that any data that modifies a zkApp, must be available somewhere for others users to access.

### Off-Chain Storage and Decentralization

Solutions to storage can be on a spectrum from cheap and more centralized, to more expensive and more decentralized. More decentralized solutions will likely be more expensive due to replicating and proving stored data.

Given that, we expect there to be different solutions on a continuum, offering multiple options for developers to choose depending on the zkApp they are building and the guarantees they want that zkApp to have.

Some likely things to expect on this spectrum and are under exploration:

1. A single-server storage solution (this is what is presented here).
2. A multi-server storage solution that can be run by multiple parties for stronger trust guarantees.
3. A solution leveraging storage on modular blockchains.
4. A future hard fork to add purchasable on-chain data storage to Mina.
5. A future hard fork to add data-storage committees to Mina for horizontally scalable storage.

### Single-Server Off-Chain Storage

This tutorial shares and explains an implementation of the single-server off-chain storage solution mentioned as the first option above. The library provides a REST server that anyone can run to store data for one or multiple zkApps, as well as a zkApp library to check on-chain if changes have been backed by the server.

This implementation requires a trust assumption for zkApps using it, that both developers and users can trust whoever is running the server.

This makes it useful for both prototyping applications that need off-chain storage, and putting applications into production where these trust assumptions are reasonable, but not for zkApps where a trustless solution is needed.

See the library [here](https://github.com/es92/zkApp-offchain-storage) if you'd like to learn more about this implementation and see how it works.

### Further Development of Single-Server Off-Chain Storage

We're looking for a developer to run with the library presented here, improve it, make it more decentralized, and run instances for the community. There is a grant opportunity for taking this on. If interested, please reach out [here](mailto:build@minaprotocol.com).

Some suggested improvements:

- Eliminate DDOS vulnerability by adding a token that limits storage requests.
- Do not store trees for a smart contract if that contract is misconfigured in a way to prevent cleaning up old data.
- Add support to the client library for connecting to multiple storage servers, enabling correctness under a majority-honest assumption.
- Switch the project to a more scalable database implementation (e.g. Redis).
- Write an implementation for an automatically scalable service (e.g. Cloudflare).

## Implementing a Project Using Off-Chain Storage

As usual, there is sample code for this project, which you can find [here](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/06-offchain-storage/contracts).

We will be writing and discussing the [src/main.ts](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/06-offchain-storage/contracts/src/main.ts) and [src/NumberTreeContract.ts](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/06-offchain-storage/contracts/src/NumberTreeContract.ts) files in this project.

This project implements a tree, where each leaf is either empty or stores a number, which will be our data. Updates to the tree can update a leaf, if the new number in the leaf is greater than the old number. The root of the tree is stored on chain, while the tree itself is stored on an off-chain storage server.

## Project Setup

To start, create a new project with:

```sh
$ zk project 06-off-chain-storage
```

Now let enter the project, delete the existing files, and create a new smart contract and a main file:

```sh
$ cd 06-off-chain-storage
$ rm src/Add.ts
$ rm src/Add.test.ts
$ rm src/interact.ts
$ zk file src/NumberTreeContract
$ touch src/main.ts
```

Edit `index.ts` to import and export our new smart contract:

```ts
import { NumberTreeContract } from './NumberTreeContract.js';

export { NumberTreeContract };
```

Now, add the library for the off-chain storage server we'll be using:

```sh
$ npm install experimental-zkapp-offchain-storage --save
```

Also install `xmlhttprequest-ts`, which we will use to make network requests when running from nodejs, where the browser's XMLHttpRequest is not available by default:

```sh
$ npm install --save xmlhttprequest-ts
```

With that, setup is complete!

### Running our project

As in previous tutorials, you can run `main.ts` with

```sh
$ npm run build && node build/src/main.js
```

This will fail when first run, but once we start adding code to `main.ts` and `NumberTreeContract.ts`, it should run successfully.

Also for this project, we will need to run our storage server. To do this, in a new terminal window, change into the root of your project and run:

```sh
$ node node_modules/experimental-zkapp-offchain-storage/build/src/storageServer.js
```

This will start a storage server and create a `database.json` file in the current directory to store our data for this tutorial.

## Implementing the Smart Contract

To start, open `NumberTreeContract.ts` in your editor. You can find a full copy of this file [here](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/05-common-types-and-functions/src) for reference.

Start by adding our imports:

```ts
  1 import {
  2   SmartContract,
  3   Field,
  4   MerkleTree,
  5   state,
  6   State,
  7   method,
  8   DeployArgs,
  9   Signature,
 10   PublicKey,
 11   Permissions,
 12   Bool,
 13 } from 'snarkyjs';
 14
 15 import {
 16   OffChainStorage,
 17   Update,
 18   MerkleWitness8,
 19 } from 'experimental-zkapp-offchain-storage';
...
```

Notice we import some items from `zkapp-offchain-storage`:

- `OffChainStorage` is object containing functions for interacting with off-chain storage. These are:
  - `getPublicKey`: A function to get the storage server's public key. This is also stored in smart contracts to identify what storage server is storing the smart contract's off-chain data.
  - `get`: A function for fetching the data for a merkle tree from the storage server, given the root of the tree.
  - `requestStore`: A function to request storing a tree on the storage server. Returns a proof that the storage server has stored this tree.
  - `assertRootUpdateValid`: A function used in smart contracts, to prove updates to the smart contract's currently stored tree root result in a tree root that is being stored by the storage server.
  - `mapToTree`: A storage function to convert maps to trees. Internally the storage server is using maps from tree indices to leafs.
- `Update`: A type for updates to merkle trees. We'll be using this below in the smart contract.
- `MerkleWitness8`: The type of our merkle tree witness. Others are available for input, such as `MerkleWitness32` and `MerkleWitness256`. This is necessary for SnarkyJS to use the same instances of the witness cross-library.

Continuing, let's setup our smart contract:

```ts
...
 21 export class NumberTreeContract extends SmartContract {
 22   @state(PublicKey) storageServerPublicKey = State<PublicKey>();
 23   @state(Field) storageNumber = State<Field>();
 24   @state(Field) storageTreeRoot = State<Field>();
 25
 26
 27
 28   deploy(args: DeployArgs) {
 29     super.deploy(args);
 30     this.account.permissions.set({
 31       ...Permissions.default(),
 32       editState: Permissions.proofOrSignature(),
 33     });
 34   }
 35
 36   @method initState(storageServerPublicKey: PublicKey) {
 37     this.storageServerPublicKey.set(storageServerPublicKey);
 38     this.storageNumber.set(Field(0));
 39
 40     const emptyTreeRoot = new MerkleTree(8).getRoot();
 41     this.storageTreeRoot.set(emptyTreeRoot);
 42   }
...
```

Here we add 3 pieces of state to our contract: the public key of the storage server, the "storageNumber"â€”which is used to ensure the storage server is actively storing states, and the root of the merkle tree.

We also initialize our zkApp's initialize for these three values, by setting them to the public key of our storage server, setting storage number to 0, and storing the root of an empty tree.

Continuing, here is our update function:

```ts
...
 42   @method update(
 43     leafIsEmpty: Bool,
 44     oldNum: Field,
 45     num: Field,
 46     path: MerkleWitness8,
 47     storedNewRootNumber: Field,
 48     storedNewRootSignature: Signature
 49   ) {
 50     const storedRoot = this.storageTreeRoot.get();
 51     this.storageTreeRoot.assertEquals(storedRoot);
 52
 53     let storedNumber = this.storageNumber.get();
 54     this.storageNumber.assertEquals(storedNumber);
 55
 56     let storageServerPublicKey = this.storageServerPublicKey.get();
 57     this.storageServerPublicKey.assertEquals(storageServerPublicKey);
 58
 59     let leaf = [oldNum];
 60     let newLeaf = [num];
 61
 62     // newLeaf can be a function of the existing leaf
 63     newLeaf[0].assertGt(leaf[0]);
 64
 65     const updates = [
 66       {
 67         leaf,
 68         leafIsEmpty,
 69         newLeaf,
 70         newLeafIsEmpty: Bool(false),
 71         leafWitness: path,
 72       },
 73     ];
 74
 75     const storedNewRoot = OffChainStorage.assertRootUpdateValid(
 76       storageServerPublicKey,
 77       storedNumber,
 78       storedRoot,
 79       updates,
 80       storedNewRootNumber,
 81       storedNewRootSignature
 82     );
 83
 84     this.storageTreeRoot.set(storedNewRoot);
 85     this.storageNumber.set(storedNewRootNumber);
 86   }
 87 }
```

We get and assert the current state of the contract - and then we perform the update.

First, we check that the new leaf is greater than the old leaf.

Then, we check the update itself. In this example, we perform a single update to the tree, however with multiple witnesses, you can chain updates together to change the tree more than once in a single call to the storage server.

To assert the update is valid, we use a `assertRootUpdateValid` call from the `OffChainStorage` library. This checks that when the update is applied to the tree represented by the existing on-chain tree root, the data for the new tree is being stored by the storage server.

That completes the smart contract!

## Implementing `main.ts`

You can find a full copy of this file [here](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/06-offchain-storage/contracts/src/main.ts) for reference.

We will not be implementing this full file, instead just discussing a few parts of it, since much is repeated from earlier tutorials. So download it from the above link, place it in your src folder, and then open it in your editor.

Note that it contains logic for both running the contract locally and for deploying and interacting with it on Berkeley. This is a useful pattern when developing a new contract. If you would like to try it on Berkeley, deploy our contract as usual with `zk deploy`, set `useLocal` to false in `main.ts`, and add the name of your config to the end of your call to `node main.js`.

To start, we will connect to the off-chain storage server:

```ts
...
 73   const storageServerAddress = 'http://localhost:3001';
 74   const serverPublicKey = await OffChainStorage.getPublicKey(
 75     storageServerAddress,
 76     NodeXMLHttpRequest
 77   );
...
```

Here, we connect to the storage server, and get its public key. Running the storage server as described above starts it by default on port 3001, and so this code is configured to connect to it there. In a real application, you would run the storage server on an externally exposed machine, and change this address from localhost to match.

Next we will describe the `updateTree` function, starting on line `120`.

Our goal in this function is to:

1. Get the currently stored tree from the storage server
2. Select a random leaf
3. Change the value at that leaf to a bigger nubmer
4. Create a transaction that performs this update.

To start, let's get the existing tree:

```ts
...
109   async function updateTree() {
110     const index = BigInt(Math.floor(Math.random() * 4));
111
112     // get the existing tree
113     const treeRoot = await zkapp.storageTreeRoot.get();
114     const idx2fields = await OffChainStorage.get(
115       storageServerAddress,
116       zkappPublicKey,
117       treeHeight,
118       treeRoot,
119       NodeXMLHttpRequest
120     );
121
122     const tree = OffChainStorage.mapToTree(treeHeight, idx2fields);
123     const leafWitness = new MerkleWitness8(tree.getWitness(index));
...
```

Here, we get the current root stored in the contract - and request the data for that root from the storage server.

Then, we convert that data from a map to a MerkleTree - and we get a witness for a random index of the merkle tree.

Continuing:

```ts
...
125     // get the prior leaf
126     const priorLeafIsEmpty = !idx2fields.has(index);
127     let priorLeafNumber: Field;
128     let newLeafNumber: Field;
129     if (!priorLeafIsEmpty) {
130       priorLeafNumber = idx2fields.get(index)![0];
131       newLeafNumber = priorLeafNumber.add(3);
132     } else {
133       priorLeafNumber = Field(0);
134       newLeafNumber = Field(1);
135     }
...
```

Here, we check if the leaf is empty, and shape our update accordingly. If the leaf was empty, we set it to one. Otherwise, we set the leaf to whatever used to be there, plus 3.

```ts
...
140     const [storedNewStorageNumber, storedNewStorageSignature] =
141       await OffChainStorage.requestStore(
142         storageServerAddress,
143         zkappPublicKey,
144         treeHeight,
145         idx2fields,
146         NodeXMLHttpRequest
147       );
...
```

And lastly, we request that the storage server stores our data. If successful, we are returned a new storage number and a signature, which we will use for updating the smart contract.

We call our smart contract as follows:

```ts
...
160     const doUpdate = () => {
161       zkapp.update(
162         Bool(priorLeafIsEmpty),
163         priorLeafNumber,
164         newLeafNumber,
165         leafWitness,
166         storedNewStorageNumber,
167         storedNewStorageSignature
168       );
169     }
170
171     if (useLocal) {
172       const updateTransaction = await Mina.transaction(
173         { sender: feePayerKey.toPublicKey(), fee: transactionFee },
174         () => {
175           doUpdate();
176         }
177       );
178
179       updateTransaction.sign([zkappPrivateKey, feePayerKey])
180       await updateTransaction.prove();
181       await updateTransaction.send();
...
```

That completes our review of the code to interact with the off-chain storage server! As mentioned previously, you can find the full copy of this file [here](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/06-offchain-storage/contracts/src/main.ts) for review.

## Conclusion

Congrats! We have finished building a smart contract that leverages off-chain storage

Checkout [Tutorial 7](oracle) to learn how to use Oracles, to pull in data from the outside world into your zkApp.


---
title: 'Tutorial 7: Oracles'
hide_title: true
sidebar_label: 'Tutorial 7: Oracles'
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

# Tutorial 7: Oracles

## Overview

If your smart contract needs to consume data from the outside world, you can use an oracle.

In this tutorial, weâ€™ll build an oracle that retrieves data from a REST API. Weâ€™ll also write a smart contract that consumes information from this oracle.

Specifically, our oracle will retrieve data from a REST API that provides mock credit score information for two usersâ€“one with a high credit score and one with a low credit score. Our smart contract will consume this information and allow the user to prove their credit score is above a certain threshold (e.g. >700).

Using our smart contract, an end user will be able to generate an attestation that their credit score is above a certain value, which they can present to a third party to prove this fact without needing to share the exact credit score or other personal info with this 3rd party, maintaining their privacy.

Although weâ€™re using a mock credit score API as our data source, you can easily swap out the oracleâ€™s HTTP request to use any REST API or GraphQL API source of your choice, to create an oracle for any type of data.

## Oracle

### How it works

Letâ€™s start by understanding how an oracle works.

Mina smart contracts run off-chain and make it possible to prove that the expected computation was run on private data without revealing the data itself. But if the smart contract consumes data from a 3rd party source, we need a way to verify that this data is authenticâ€“i.e. that it was provided by the expected source.

In the future, Minaâ€™s zkOracles will allow a zkApp to consume data trustlessly from any HTTPS data source. But for now, the oracle design described in this tutorial will typically be operated by the zkApp developer, it will fetch and sign the desired data, and then a zkApp can consume this data and will verify the signature to ensure that the data was provided by the expected source.

:::note

Data providers can also operate response signers (like the one described above) to provide users with an oracle that does not require them to trust an intermediary. In other words, if a credit score or other data provider chooses to sign response data themselves, users can consume data from that source without trusting anybody besides the data provider (who users are already trusting to provide correct data).

:::

### Design

Our oracle design will be quite simple.

We will fetch data from the desired source, sign it using a Mina-compatible private key, and return the data, signature, and public key associated with our private key, so that our signature can be verified by the zkApp.

### Code

You can view the complete oracle code [here](https://github.com/jackryanservia/mina-credit-score-signer/blob/main/index.js) and can generate a Mina-compatible public/private key pair for your oracle by running `npm run keygen` (which will run the code in [this file](https://github.com/jackryanservia/mina-credit-score-signer/blob/main/scripts/keygen.js)).

For our oracle, weâ€™re using a Koa server hosted on DigitalOcean. Itâ€™s short, but you donâ€™t have to dive into the code now. Itâ€™s commented to explain each step so you can build something similar for yourself!

You can easily adapt this code to create oracles for other API sources. For example, if you wanted your smart contract to ingest price feed data from an exchange, you could simply query the exchange API, sign the results, and return a response formatted as described below.

### Response Format

The oracle returns its response in JSON with three, top-level properties: `data`, `signature`, & `publicKey`.

- `data` is an object of the information we are interested in and can have any form.
- `signature` is a signature for the `data` created using the oracle operatorâ€™s private key. Smart contracts will use this to verify that data was provided by the expected source.
- `publicKey` is the public key of the oracle. This will be the same for all requests to this oracle.

For example, below is a response from our oracle for the user with an `id` of `1`. In the real world, this `id` might be a social security number or a similar identifier. Notice that the data property contains their credit score and user id.

```json
{
  "data": { "id": "1", "creditScore": "787" },
  "signature": {
    "r": "6879645159505819706680368079573694250155734132188077159564484773379936889926",
    "s": "25770716061409035848137554965765890473013735453379104563619678415983125445906"
  },
  "publicKey": "B62qoAE4rBRuTgC42vqvEyUqCGhaZsW58SKVW4Ht8aYqP9UTvxFWBgy"
}
```

Our demo oracle also provides a response for a user id of `2`, who has a credit score that will be below our specified threshold when we write our smart contract further below.

```json
{
  "data": { "id": "2", "creditScore": "536" },
  "signature": {
    "r": "17330964553212655684849406067090021752962217822408913431446690101683066224611",
    "s": "26366190712354094401916556126787229546643001327044048354949322240615669643867"
  },
  "publicKey": "B62qoAE4rBRuTgC42vqvEyUqCGhaZsW58SKVW4Ht8aYqP9UTvxFWBgy"
}
```

While the first user has a credit score of `787`, the second user only has a credit score of `536`. We can also see that the `signature` has changed. This makes sense because the payload is different from what we received in the first response. Finally, notice that the `publicKey` is the same because in each case we are querying data from the same provider.

For purposes of this tutorial below, you can access our demo oracle at https://mina-credit-score-signer-pe3eh.ondigitalocean.app/user/1 and https://mina-credit-score-signer-pe3eh.ondigitalocean.app/user/2, if you donâ€™t want to set up your own oracle right now.

## Smart Contract

Now that we have an oracle that returns signed data, we will write a smart contract that uses this data.

### Setup

The following steps assume you've installed dependencies to your machine as described in [Tutorial 1: Hello World](hello-world) â€” if not, please do that first.

Now, set up a new project with:

```sh
$ zk project oracle
```

Delete the default generated files by running:

```sh
$ rm src/Add.ts
$ rm src/Add.test.ts
$ rm src/interact.ts
```

And create new files:

```sh
$ zk file CreditScoreOracle
```

And lastly, change `index.ts` to:

```ts
import { CreditScoreOracle } from './CreditScoreOracle.js';

export { CreditScoreOracle };
```

### Writing our Smart Contract

Open up `/src/CreditScoreOracle.ts` and paste in the following:

<!-- prettier-ignore -->
```ts
import {
  Field,
  SmartContract,
  state,
  State,
  method,
  DeployArgs,
  Permissions,
  PublicKey,
  Signature,
  PrivateKey,
} from 'snarkyjs';

// The public key of our trusted data provider
const ORACLE_PUBLIC_KEY =
  'B62qoAE4rBRuTgC42vqvEyUqCGhaZsW58SKVW4Ht8aYqP9UTvxFWBgy';

export class OracleExample extends SmartContract {
  // Define contract state

  // Define contract events

  deploy(args: DeployArgs) {
    super.deploy(args);
    this.setPermissions({
      ...Permissions.default(),
      editState: Permissions.proofOrSignature(),
    });
  }

  @method init(zkappKey: PrivateKey) {
    super.init(zkappKey);
    // Initialize contract state

    // Specify that caller should include signature with tx instead of proof
    this.requireSignature();
  }

  @method verify(id: Field, creditScore: Field, signature: Signature) {
    // Get the oracle public key from the contract state

    // Evaluate whether the signature is valid for the provided data

    // Check that the signature is valid

    // Check that the provided credit score is greater than 700

    // Emit an event containing the verified users id

  }
}
```

This just adds the basic setup for our smart contract. For more details on the `deploy()` method â€” see [Tutorial 1: Hello World](hello-world).

## On-Chain State

Our smart contract will store the public key for the oracle that we choose to retrieve data from as on-chain state so that it is available when end users run the smart contract. The smart contract will then use this to verify the signature of the data to confirm it came from the expected source.

```ts
  // Define contract state
  @state(PublicKey) oraclePublicKey = State<PublicKey>();
```

Weâ€™ll use the `init` method to initialize `oraclePublicKey` to the credit score oracleâ€™s public key.

```ts
  @method init(zkappKey: PrivateKey) {
    super.init(zkappKey);
    // Initialize contract state
    this.oraclePublicKey.set(PublicKey.fromBase58(ORACLE_PUBLIC_KEY));
    // Specify that caller should include signature with tx instead of proof
    this.requireSignature();
  }
```

`init` is a method that the contract developer can run after the contract is deployed, but before users have the chance to interact with it, to set the initial on-chain state and other configuration. You can think of it like a constructor in a Solidity contract.

## Emitting Events

Our smart contract will check that a user has a credit score above a certain threshold, but how can we expose the result to the outside world? We can emit events! Events allow smart contracts to publish arbitrary messages that anybody can verify without requiring that we store them in the state of a zkApp account. This property makes them ideal for communication with other parts of your application that donâ€™t live on-chain (like your UI, or even an external service).

Letâ€™s add an `events` object to our Smart Contract class to define the names and types of the events it will emit.

```ts
// Define contract events
events = {
  verified: Field,
};
```

## Defining our `verify()` Method

Now, letâ€™s add a method to verify a userâ€™s credit score is above 700.

This is defined the same as any other TypeScript method, except that it must have the `@method` decorator in front of it, which tells SnarkyJS that this method can be invoked by users when they interact with the smart contract.

```ts
  @method verify(id: Field, creditScore: Field, signature: Signature) {
```

We will pass in a few arguments.

- `userId`: The id of the users whose credit score we requested. Necessary to prevent bad actors from querying somebody else data and claiming it as their own.
- `creditScore`: The (fake) credit score of the user (a number between 350 and 800).
- `signature`: A cryptographic signature of our `userId` and `creditScore`. This is what our smart contract will use in order to verify that the data was provided by the expected source.

The `verify()` method will not return any values or change any contract state, instead it will emit an `id` event with the userâ€™s id if their credit score is above 700.

### Fetching the Oracleâ€™s Public Key

Now letâ€™s get the oracleâ€™s public key from the on-chain state. We will need this to verify the signature of data from the oracle.

```ts
// Get the oracle public key from the contract state
const oraclePublicKey = this.oraclePublicKey.get();
this.oraclePublicKey.assertEquals(oraclePublicKey);
```

We use `assertEquals()` to ensure that the public key we retrieved at execution time is the same as the public key that exists within the zkApp account on the Mina network when the transaction is processed by the network.

### Verify the Signature

Next, weâ€™ll verify that the signature on the data (`id` and `creditScore`) is valid for the expected public key, to ensure it was from our expected source. This will return true if the signature is valid, and false if it is not.

```ts
// Evaluate whether the signature is valid for the provided data
const validSignature = signature.verify(oraclePublicKey, [id, creditScore]);
```

We also want it to make it impossible to generate a valid zero-knowledge proof if `validSignature` is false. We can do this with `assertTrue()`. If the signature is invalid, this will throw an exception and make it impossible to generate a valid ZKP and transaction.

```ts
// Check that the signature is valid
validSignature.assertTrue();
```

### Check that the Users Credit Score Is Above 700

We want our `verify()` method to only emit an event if the userâ€™s credit score is above 700. We can ensure that this condition is met by calling the `assertGte()` (i.e. assert greater than or equal to) on the `creditScore`.

```ts
// Check that the provided credit score is greater than 700
creditScore.assertGte(Field(700));
```

These assert methods create a constraint that makes it impossible for users to generate a valid zero-knowledge proof unless their condition is met. Without a valid zero-knowledge proof (or a signature) itâ€™s impossible to generate a valid Mina transaction. So, we can now rest assured that users can only call our smart contract method and send a valid transaction if they have a valid signature from our expected oracle and a credit score above 700.

### Emitting our `verified` Event

Now that we are sure everything checks out, we can emit an event to indicate this. The first argument to `emitEvent()` is an arbitrary string name chosen by the developer (because a smart contract could emit more than one type of event) and the second argument can be any value, as long as it matches the type defined for our event earlier. In this case, our event is `Field`, but it could be a more complicated type built on Fields, if the situation called for it. Emitted events are stored and available on archive nodes in the Mina network.

```ts
// Emit an event containing the verified users id
this.emitEvent('verified', id);
```

## Testing it Out

The zkApp CLI automatically generated a file called `CreditScoreOracle.test.ts` for us when we ran `zk file CreditScoreOracle`. Letâ€™s add some tests. Open it and paste in the following:

```ts
import { OracleExample } from './CreditScoreOracle';
import {
  isReady,
  shutdown,
  Field,
  Mina,
  PrivateKey,
  PublicKey,
  AccountUpdate,
  Signature,
} from 'snarkyjs';

// The public key of our trusted data provider
const ORACLE_PUBLIC_KEY =
  'B62qoAE4rBRuTgC42vqvEyUqCGhaZsW58SKVW4Ht8aYqP9UTvxFWBgy';

let proofsEnabled = false;
function createLocalBlockchain() {
  const Local = Mina.LocalBlockchain({ proofsEnabled });
  Mina.setActiveInstance(Local);
  return Local.testAccounts[0].privateKey;
}

async function localDeploy(
  zkAppInstance: OracleExample,
  zkAppPrivatekey: PrivateKey,
  deployerAccount: PrivateKey
) {
  const txn = await Mina.transaction(deployerAccount, () => {
    AccountUpdate.fundNewAccount(deployerAccount);
    zkAppInstance.deploy({ zkappKey: zkAppPrivatekey });
    zkAppInstance.init(zkAppPrivatekey);
  });
  await txn.prove();
  txn.sign([zkAppPrivatekey]);
  await txn.send();
}

describe('CreditScoreOracle', () => {
  let deployerAccount: PrivateKey,
    zkAppAddress: PublicKey,
    zkAppPrivateKey: PrivateKey;

  beforeAll(async () => {
    await isReady;
    if (proofsEnabled) OracleExample.compile();
  });

  beforeEach(async () => {
    deployerAccount = createLocalBlockchain();
    zkAppPrivateKey = PrivateKey.random();
    zkAppAddress = zkAppPrivateKey.toPublicKey();
  });

  afterAll(async () => {
    // `shutdown()` internally calls `process.exit()` which will exit the running Jest process early.
    // Specifying a timeout of 0 is a workaround to defer `shutdown()` until Jest is done running all tests.
    // This should be fixed with https://github.com/MinaProtocol/mina/issues/10943
    setTimeout(shutdown, 0);
  });

  it('generates and deploys the `CreditScoreOracle` smart contract', async () => {
    const zkAppInstance = new OracleExample(zkAppAddress);
    await localDeploy(zkAppInstance, zkAppPrivateKey, deployerAccount);
    const oraclePublicKey = zkAppInstance.oraclePublicKey.get();
    expect(oraclePublicKey).toEqual(PublicKey.fromBase58(ORACLE_PUBLIC_KEY));
  });

  describe('actual API requests', () => {
    it('emits an `id` event containing the users id if their credit score is above 700 and the provided signature is valid', async () => {
      const zkAppInstance = new OracleExample(zkAppAddress);
      await localDeploy(zkAppInstance, zkAppPrivateKey, deployerAccount);

      const response = await fetch(
        'https://mina-credit-score-signer-pe3eh.ondigitalocean.app/user/1'
      );
      const data = await response.json();

      const id = Field(data.data.id);
      const creditScore = Field(data.data.creditScore);
      const signature = Signature.fromJSON(data.signature);

      const txn = await Mina.transaction(deployerAccount, () => {
        zkAppInstance.verify(
          id,
          creditScore,
          signature ?? fail('something is wrong with the signature')
        );
      });
      await txn.prove();
      await txn.send();

      const events = await zkAppInstance.fetchEvents();
      const verifiedEventValue = events[0].event.toFields(null)[0];
      expect(verifiedEventValue).toEqual(id);
    });

    it('throws an error if the credit score is below 700 even if the provided signature is valid', async () => {
      const zkAppInstance = new OracleExample(zkAppAddress);
      await localDeploy(zkAppInstance, zkAppPrivateKey, deployerAccount);

      const response = await fetch(
        'https://mina-credit-score-signer-pe3eh.ondigitalocean.app/user/2'
      );
      const data = await response.json();

      const id = Field(data.data.id);
      const creditScore = Field(data.data.creditScore);
      const signature = Signature.fromJSON(data.signature);

      expect(async () => {
        await Mina.transaction(deployerAccount, () => {
          zkAppInstance.verify(
            id,
            creditScore,
            signature ?? fail('something is wrong with the signature')
          );
        });
      }).rejects;
    });
  });

  describe('hardcoded values', () => {
    it('emits an `id` event containing the users id if their credit score is above 700 and the provided signature is valid', async () => {
      const zkAppInstance = new OracleExample(zkAppAddress);
      await localDeploy(zkAppInstance, zkAppPrivateKey, deployerAccount);

      const id = Field(1);
      const creditScore = Field(787);
      const signature = Signature.fromJSON({
        r:
          '13209474117923890467777795933147746532722569254037337512677934549675287266861',
        s:
          '12079365427851031707052269572324263778234360478121821973603368912000793139475',
      });

      const txn = await Mina.transaction(deployerAccount, () => {
        zkAppInstance.verify(
          id,
          creditScore,
          signature ?? fail('something is wrong with the signature')
        );
      });
      await txn.prove();
      await txn.send();

      const events = await zkAppInstance.fetchEvents();
      const verifiedEventValue = events[0].event.toFields(null)[0];
      expect(verifiedEventValue).toEqual(id);
    });

    it('throws an error if the credit score is below 700 even if the provided signature is valid', async () => {
      const zkAppInstance = new OracleExample(zkAppAddress);
      await localDeploy(zkAppInstance, zkAppPrivateKey, deployerAccount);

      const id = Field(2);
      const creditScore = Field(536);
      const signature = Signature.fromJSON({
        r:
          '25163915754510418213153704426580201164374923273432613331381672085201550827220',
        s:
          '20455871399885835832436646442230538178588318835839502912889034210314761124870',
      });

      expect(async () => {
        await Mina.transaction(deployerAccount, () => {
          zkAppInstance.verify(
            id,
            creditScore,
            signature ?? fail('something is wrong with the signature')
          );
        });
      }).rejects;
    });

    it('throws an error if the credit score is above 700 and the provided signature is invalid', async () => {
      const zkAppInstance = new OracleExample(zkAppAddress);
      await localDeploy(zkAppInstance, zkAppPrivateKey, deployerAccount);

      const id = Field(1);
      const creditScore = Field(787);
      const signature = Signature.fromJSON({
        r:
          '26545513748775911233424851469484096799413741017006352456100547880447752952428',
        s:
          '7381406986124079327199694038222605261248869991738054485116460354242251864564',
      });

      expect(async () => {
        await Mina.transaction(deployerAccount, () => {
          zkAppInstance.verify(
            id,
            creditScore,
            signature ?? fail('something is wrong with the signature')
          );
        });
      }).rejects;
    });
  });
});
```

Now save it and run `npm run test`.

You might have to try it twice in order for all the tests to pass because we're calling our live API directly. Note that writing a test that calls an API is generally not a best practice, but itâ€™s convenient for the sake of this tutorial. You can also mock your HTTP requests.

Congratulations! You have just built a simple oracle using SnarkyJS and the Mina Protocol. You can find the complete code for this example [here](https://github.com/jackryanservia/oracle-example).

Checkout [Tutorial 8](custom-tokens) to learn how to launch and use custom tokens.


---
title: 'Tutorial 8: Custom Tokens'
hide_title: true
sidebar_label: 'Tutorial 8: Custom Tokens'
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

:::note

This tutorial was last tested with [SnarkyJS](https://www.npmjs.com/package/snarkyjs) 0.8.0.

:::

# Tutorial 8: Custom Tokens

## Overview

In this tutorial, we will discuss how to create custom tokens.

Mina comes with native support for custom tokens. Each account on Mina can also have tokens associated with it.

To create a new token, one creates a smart contract, which becomes the manager for the token, and uses that contract to set the rules around how the token can be mint, burned, and sent.

The manager account may also set a token symbol for its token, such as in this example, `MYTKN`. Uniqueness is not enforced for token names. Instead the public key of the manager account is used to identify tokens.

In this tutorial, we will review smart contract code that creates and manages new tokens. You can find the full code of what we'll be building in this tutorial [here](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/08-custom-tokens/src).

You can also find a more extensive example, including all the ways to interact with token smart contracts, [here](https://github.com/o1-labs/snarkyjs/blob/main/src/lib/token.test.ts) for reference.

## Basic Token Example

To create a token manager smart contract, we will create a normal smart contract, whose methods call special functions that manipulate tokens.

You can find a full copy of this file [here](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/08-custom-tokens/src/BasicTokenContract.ts).

First, we will bring in imports and setup the structure for our smart contract:

```ts
  1 import {
  2  SmartContract,
  3  state,
  4  State,
  5  method,
  6  DeployArgs,
  7  Permissions,
  8  UInt64,
  9  PublicKey,
 10  Signature,
 11 } from 'snarkyjs';
 12
 13 const tokenSymbol = 'MYTKN';
 14
 15 export class BasicTokenContract extends SmartContract {
 16   @state(UInt64) totalAmountInCirculation = State<UInt64>();
 17
 18   deploy(args: DeployArgs) {
 19     super.deploy(args);
 20
 21     const permissionToEdit = Permissions.proof();
 22
 23     this.account.permissions.set({
 24       ...Permissions.default(),
 25       editState: permissionToEdit,
 26       setTokenSymbol: permissionToEdit,
 27       send: permissionToEdit,
 28       receive: permissionToEdit,
 29     });
 30   }
 31 }
```

We include a single state variable, `totalAmountInCirculation`, which we will use to track how many tokens exist.

Next we will add an init method, and a method that mints tokens:

```ts
 32   @method init() {
 33     super.init();
 34     this.account.tokenSymbol.set(tokenSymbol);
 35     this.totalAmountInCirculation.set(UInt64.from(0));
 36   }
 37
 38   @method mint(
 39     receiverAddress: PublicKey,
 40     amount: UInt64,
 41     adminSignature: Signature
 42   ) {
 43     let totalAmountInCirculation = this.totalAmountInCirculation.get();
 44     this.totalAmountInCirculation.assertEquals(totalAmountInCirculation);
 45
 46     let newTotalAmountInCirculation = totalAmountInCirculation.add(amount);
 47
 48     adminSignature
 49       .verify(
 50         this.address,
 51         amount.toFields().concat(receiverAddress.toFields())
 52       )
 53       .assertTrue();
 54
 55     this.token.mint({
 56       address: receiverAddress,
 57       amount,
 58     });
 59
 60     this.totalAmountInCirculation.set(newTotalAmountInCirculation);
 61   }
```

In `init`, we set our token symbol (in this case, MYTKN), and start tracking the amount in circulation by setting it to zero.

We also write a function to mint new tokens, and send them to a recipient. We check in this function that a signature has been provided by the zkApp account, so that not just anybody can call mint.

In mint, we also track how many tokens are in existence.

Lastly, we will write a send function:

```ts
 63   @method sendTokens(
 64     senderAddress: PublicKey,
 65     receiverAddress: PublicKey,
 66     amount: UInt64
 67   ) {
 68     this.token.send({
 69       from: senderAddress,
 70       to: receiverAddress,
 71       amount,
 72     });
 73   }
```

Holders of our token will call this method to send tokens to other Mina accounts.

That completes a basic token! To see an example of interacting with this contract, see [here](https://github.com/es92/zkApp-examples/blob/f65d61e8884691d2cd62b59e1e21568bd6f119a7/08-custom-tokens/src/main.ts).

And, to see an example of putting rules around a token, see this example of a token with a whitelist gating which public keys can interact with it [here](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/08-custom-tokens/src/WhitelistedTokenContract.ts).

## Building zkApps that interact with Tokens.

With zkApps, you can also build smart contracts that interact with tokens - say, swapping one token for another, or taking deposits of Mina tokens, etc.

This will come in a future part of this tutorial. For now, see this example [here](https://github.com/o1-labs/snarkyjs/blob/main/src/examples/zkapps/dex/dex.ts) of a zkApp implementing an AMM-based DEX.

## Conclusion

We have finished building a smart contract to manage a token, and shown how to build a smart contract that places custom rules over tokens!

To learn more on tokens, see [the token docs](/zkapps/advanced-snarkyjs/custom-tokens).

Checkout [Tutorial 9](recursion) to learn how to use recursive ZKPs with SnarkyJS, to implement zkRollups, large computations, and more.


---
title: 'Tutorial 9: Recursion'
hide_title: true
sidebar_label: 'Tutorial 9: Recursion'
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

# Tutorial 9: Recursion

## Overview

One of the most powerful features of zkApps is recursion.

With recursion, you can realize composability between zero knowledge proofs. This unlocks many powerful technical abilities, such as creating high-throughput applications, creating proofs of large computations, and constructing multi-party proofs.

### Scaling Throughput - zkRollups & App Chains

Verifying large amounts of information is usually challenging for blockchains. But with zero knowledge proofs, and particularly recursive ZKPs, this becomes far easier.

By leveraging recursive verification, it is possible to easily construct both zkRollups and app chains. Weâ€™ll give an example of a simple zkRollup near the end of this tutorial.

Recursive composition even gives us flexibility to handle live demand. Recursive composition gives you flexibility to choose between a high tree height (higher throughput, but logarithmically slower latency), and lower tree height (lower throughput, but faster latency). The depth of the tree can be modified live to handle whatever traffic actually present on the network, while still offering optimal latency to commit transactions back to the chain.

For an example of an â€˜app chainâ€™, one could imagine an on-chain trading pair that uses an orderbook. Rolling up the transactions for the application with zero knowledge proofs can allow our app to handle the expensive computations of keeping buy and sell orders sorted, while still posting full verification to the chain.

At the end of this tutorial, weâ€™ll review a simple zkRollup example that can be used for implementing a zkRollup or an app chain.

### Scaling Proof Size

Recursive ZKPs also give you the ability to construct very large transactions that wouldnâ€™t otherwise be possible.

For example, recursive ZKPs could be used to prove the output of a machine learning (ML) model. This could be used to prove an inference is truly generated by a model, or for a more computationally intensive case, to verify a model has been trained on a particular dataset.

### Off-chain, multi-party proof construction

Recursive zero knowledge proofs also make it easy to allow multiple parties to construct transactions. To accomplish off-chain proof construction, one or more parties can recursively update a ZKP and its associated public state.When the mulit-party stage is completed, that state and its proof can then be sent as part of a transaction on-chain, or used as part of an off-chain application leveraging ZKPs.

## ZkProgram

Recursive zkApps are built using [ZkProgram](../../zkapps/snarkyjs-reference/modules/Experimental#zkprogram). ZkProgram is similar to the zkApp smart contracts weâ€™ve seen before, but arenâ€™t tied to an on-chain account.

Proofs generated via ZkProgram can be passed into zkApp smart contracts (for them to verify recursively), and can even be passed recursively into their own functions for off-chain recursive composition.

To see an example of this, letâ€™s build a simple ZkProgram that uses recursion. You can find the code for this example [here](https://github.com/es92/zkApp-examples/blob/main/09-recursion/src/main.ts).

This example will be in a single file, `main.ts`. Weâ€™ll create our ZkProgram as follows:

```typescript
const Add = Experimental.ZkProgram({
  publicInput: Field,

    methods: {
      init: {
        privateInputs: [],
        method(state: Field) {
          state.assertEquals(Field(0));
      },
    }
  }
}
```

We start with one method, `init`. Note that for each method, we need to declare what inputs it will receive. The first argument of a ZkProgram method is always the state of the ZkProgram, named â€œpublicInputâ€ since it will be public.

Letâ€™s add another method to this:


```typescript
  addNumber: {
  	privateInputs: [SelfProof, Field ],

  	method(
      newState: Field,
      earlierProof: SelfProof<Field>, 
      numberToAdd: Field
    ) {
      earlierProof.verify();
      newState.assertEquals(earlierProof.publicInput.add(numberToAdd));
    },
  },
```

Here, we take an existing proof, and add a new number to it, and produce a new proof.

We can also use recursion to combine two proofs:

```typescript
  add: {
    privateInputs: [ SelfProof, SelfProof ],

    method(
      newState: Field,
      earlierProof1: SelfProof<Field>,
      earlierProof2: SelfProof<Field>,
    ) {
      earlierProof1.verify();
      earlierProof2.verify();    	
      newState.assertEquals(earlierProof1.publicInput.add(earlierProof2.publicInput));
    },
  },
```

To use ZkProgram, we need to compile it, and then call methods on it:

```typescript
  console.log('compiling...');
 
  const { verificationKey } = await Add.compile();
 
  console.log('making proof 0')
 
  const proof0 = await Add.init(Field(0));
 
  console.log('making proof 1')
 
  const proof1 = await Add.addNumber(Field(4), proof0, Field(4));
 
  console.log('making proof 2')
 
  const proof2 = await Add.add(Field(4), proof1, proof0);
 
  console.log('verifying proof 2');
  console.log('proof 2 data', proof2.publicInput.toString());
 
  const ok = await verify(proof2.toJSON(), verificationKey);
  console.log('ok', ok);
```

Note that verification of the proof can occur off-chain using the `verify()` method. This is useful for applications where you want to prove something to an off-chain entity.

For another example of off-chain multi-party proof construction, see the code [here](https://github.com/es92/zkApp-examples/blob/main/09-recursion/src/vote.ts) - showing how to do Private Off-Chain voting with Recursive ZKPs.

## Using ZkProgram in SmartContracts

Once we have a recursive ZKP, we may want or need to settle this to the Mina blockchain. We can accomplish this using a method on a SmartContract. To show how to use ZkProgram from a SmartContract, letâ€™s build a zkRollup.

Our zkRollup will operate over a MerkleMap of â€œaccountsâ€, which each store a number. Our update rule will be to increment the value stored at an account - though you could imagine using more substantial rules to implement a particular application.

The zkApp will store the Merkle root of this Merkle map of accounts on chain. We will allow this to be updated when authorized by a recursive zero knowledge proof generated by our ZkProgram.

This both allows it to be flexible to how much compute is being demanded of it (for latency), and allows it to scale to arbitrary numbers of proofs (for throughput).

Letâ€™s discuss the code for the ZkProgram part of a rollup. You can find the full example [here](https://github.com/es92/zkApp-examples/blob/main/09-recursion/src/rollup.ts).

On one machine, the below code doesnâ€™t offer a high throughput, but by switching the mapreduce used for a mapreduce that runs over tens or hundreds of machines, very high throughputs can be achieved. In fact, any level of throughput can be achieved as long as youâ€™re willing to incur `log(N)` latency when constructing the proof of N transactions. You can find an implementation that distributes compute over AWS instances [here](https://github.com/Trivo25/proof_aggregator).

To start, letâ€™s set up our ZkProgram:

```typescript
class RollupState extends Struct({
  initialRoot: Field,
  latestRoot: Field,
}) {
  static createOneStep(...)

  static createMerged(state1: RollupState, state2: RollupState) {
	  return new RollupState({
      initialRoot: state1.initialRoot,
      latestRoot: state2.latestRoot
    });
  }

  static assertEquals(state1: RollupState, state2: RollupState) {
    state1.initialRoot.assertEquals(state2.initialRoot);
    state1.latestRoot.assertEquals(state2.latestRoot);
  }
}

const Rollup = Experimental.ZkProgram({
  publicInput: RollupState,

  methods: {
	oneStep: {
		...
	},

  merge: {
  	privateInputs: [ SelfProof, SelfProof ],

  	method(
    	newState: RollupState,
    	rollup1proof: SelfProof<RollupState>,
    	rollup2proof: SelfProof<RollupState>,
  	) {
      rollup1proof.verify(); // A -> B
      rollup2proof.verify(); // B -> C

      rollup1proof.publicInput.initialRoot.assertEquals(newState.initialRoot);

      rollup1proof.publicInput.latestRoot.assertEquals(rollup2proof.publicInput.initialRoot);

      rollup2proof.publicInput.latestRoot.assertEquals(newState.latestRoot);
  	}
}
```

A proof generated by our `merge` method will indicate there is a valid sequence of transactions (i.e. applications of â€œoneStepâ€) that get from an â€œinitialRootâ€ (the root of a MerkleMap) to a â€œlatestRootâ€ (root of the Merkle map after transactions are applied).

We will consume these in a SmartContract, which will use the recursive proof to update its internal state:

```typescript
class RollupContract extends SmartContract {
  @state(Field) state = State<Field>();

  deploy(args: DeployArgs) {
    super.deploy(args);
    this.setPermissions({
      ...Permissions.default(),
      editState: Permissions.proofOrSignature(),
    });
  }

  @method initStateRoot(stateRoot: Field) {
    this.state.set(stateRoot);
  }

  @method update(rollupStateProof: RollupProof) {
    const currentState = this.state.get();
    this.state.assertEquals(currentState);

    rollupStateProof.publicInput.initialRoot.assertEquals(currentState);

    rollupStateProof.verify();

    this.state.set(rollupStateProof.publicInput.latestRoot);
  }
}
```

Last, is just to fill in the methods above, particularly, `oneStep()`, and `createOneStep()`. This single â€œstepâ€ of the rollup will check the value at an â€œaccountâ€ was incremented by a particular amount.

To check that the value at an account was incremented by a particular amount, our code computes an updated state - inside the recursive snark - by calling `RollupState.createOneStep()`. And then, asserting that the new state of the recursive snark, is equivalent to the computed state. Inside `createOneStep()`, a single step of the rollup is created.

```typescript
class RollupState extends Struct({
...
}) {
  static createOneStep(
    initialRoot: Field,
    latestRoot: Field,
    key: Field,
    currentValue: Field,
    incrementAmount: Field,
    merkleMapWitness: MerkleMapWitness,
  ) {
    const [ witnessRootBefore, witnessKey ] = 
      merkleMapWitness.computeRootAndKey(currentValue);
    initialRoot.assertEquals(witnessRootBefore);
    witnessKey.assertEquals(key);
    const [ witnessRootAfter, _ ] = 
      merkleMapWitness.computeRootAndKey(currentValue.add(incrementAmount));
    latestRoot.assertEquals(witnessRootAfter);

    return new RollupState({
      initialRoot,
      latestRoot
    });
  }
...
}

const Rollup = Experimental.ZkProgram({
  publicInput: RollupState,

  methods: {
	oneStep: {
  	privateInputs: [ Field, Field, Field, Field, Field, MerkleMapWitness ],

  	method(
      state: RollupState,
      initialRoot: Field,
      latestRoot: Field,
      key: Field,
      currentValue: Field,
      incrementAmount: Field,
      merkleMapWitness: MerkleMapWitness
  	) {
      const computedState = RollupState.createOneStep(
        initialRoot,
        latestRoot,
        key,
        currentValue,
        incrementAmount,
        merkleMapWitness
      );
      RollupState.assertEquals(computedState, state);
  	}
},

```

`createOneStep()` returns a proof, that acts as the â€œleafâ€ in a tree of recursive proofs. To use this rollup, we would first construct all of the leafs in parallel. Then, we would recursively merge these leafs, until we get a proof for the entire sequence. This parallel merging gives the high throughput properties weâ€™re looking for in a rollup.

And with that last function, we have completed the code for a zkRollup!

Hopefully itâ€™s clear how one could re-implement the above for more substantial functionality, just by changing `createOneStep()`. For example, to implement a DEX zkRollup that uses an orderbook we could change this to:
* Updating buy/sell orders on an orderbook
* Executing those buy/sell orders
* Adding a â€œqueueâ€ of tokens to move to the app chain in the SmartContract
* Adding a â€œqueueâ€ of tokens to move out of the app chain in the ZkProgram

## Conclusion

We have finished showing how to use recursion with zkApps, both on and off chain, and discussed their use cases to create high-throughput applications, use larger proof sizes, and create multi-party proof constructions We hope this helps show how  recursive zero knowledge proofs can help you build powerful zkApps.

Check out our other tutorials and documentation to learn more about SnarkyJS and zkApps.


---
title: 'Example: Anonymous Message Board Tutorial'
hide_title: true
sidebar_label: 'Example: Anonymous Message Board'
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

# Anonymous Message Board Tutorial

[How to write a zkApp](/zkapps/how-to-write-a-zkapp) provides a high-level overview of everything you need to know to build applications
on Mina. This tutorial will put these ideas into practice as we walk through the
design and implementation of a semi-anonymous messaging protocol.

## Overview

Weâ€™ll build a smart contract that allows users to publish messages semi-anonymously. Our contract will allow a specific set of users to create new messages but will not disclose which user within the set has done so. This way, people can leverage one aspect of their identity without revealing exactly who they are. So, for example, a DAO member could make credible statements on behalf of their DAO without revealing their specific individual identity.

## Setup

First, install the [Mina zkApp CLI](https://github.com/o1-labs/zkapp-cli) if you havenâ€™t already done so.

#### Dependencies

You'll need the following installed to use the zkApp CLI:

- NodeJS 16+ (or 14 using `--experimental-wasm-threads`)
- NPM 6+
- Git 2+

If you have an older version installed, we suggest installing a newer version
using the package manager for your system: [Homebrew](https://brew.sh/) (Mac),
[Chocolatey](https://chocolatey.org/) (Windows), or apt/yum/etc (Linux). On
Linux, you may need to install a recent NodeJS version via NodeSource
([deb](https://github.com/nodesource/distributions#debinstall) or
[rpm](https://github.com/nodesource/distributions#rpminstall)), as recommended
by the NodeJS Project.

#### Installation

```sh
$ npm install -g zkapp-cli
```

#### Usage

```sh
$ zk --help
```

##### Create a new project

```sh
$ zk project message-board  # or path/to/message-board

âœ” Fetch project template
âœ” Initialize Git repo
âœ” NPM install
âœ” Set project name
âœ” Git init commit

Success!

Next steps:
  cd message-board
  git remote add origin <your-repo-url>
  git push -u origin main
```

This command creates a directory containing a new project template, fully set up
& ready for local development.

- See the included [README](https://github.com/o1-labs/zkapp-cli/tree/main/templates/project-ts#readme) for usage instructions.
  All usual commands will be available: `npm run build`, `npm run test`,
  `npm run coverage`, etc.
- A Git repo will be initialized in the project directory automatically. For
  consistency, we use `main` as the default Git branch, by convention.
- A [Github Actions CI workflow](https://github.com/o1-labs/zkapp-cli/tree/main/templates/project-ts/.github/workflows/ci.yml) is
  also included. If you push your project to Github, Github Actions will run
  your tests (named as `*.test.js`) automatically, whenever you push a commit or
  open a pull request.
- Code style consistency (via Prettier) and linting (via ES Lint) are
  automatically enforced using Git pre-commit hooks. This requires no
  configuration and occurs automatically when you commit to Git--e.g. `git commit -m 'feat: add awesome feature'`.
- To skip all checks in the Git pre-commit hook (not recommended), you can pass
  the `-n` flag to Git--e.g. `git commit -m 'a bad commit' -n`. But we'd
  recommend avoiding this and resolving any errors which exist in your project
  until the pre-commit hook passes.

### Scaffolding

Now that your project is set up, you can open it in your IDE or `cd zk-message` if you work from the command line.

There should be an example smart contract in `./src` called `Add.ts` and tests for it in `Add.test.ts`. These are just example code, and you can delete them if they bother you.

Letâ€™s create a new contract by running:

```sh
$ zk file message
```

Now open it (`message.ts`) up and paste in the following:

```ts
import {
  Field,
  SmartContract,
  state,
  State,
  method,
  DeployArgs,
  Permissions,
  PrivateKey,
  PublicKey,
  isReady,
  Poseidon,
  Encoding,
} from 'snarkyjs';

export { isReady, Field, Encoding };

// Wait till our SnarkyJS instance is ready
await isReady;

// These private keys are exported so that experimenting with the contract is
// easy. Three of them (the Bobs) are used when the contract is deployed to
// generate the public keys that are allowed to post new messages. Jack's key
// is never added to the contract. So he won't be able to add new messages. In
// real life, we would only use the Bobs' public keys to configure the contract,
// and only they would know their private keys.

export const users = {
  Bob: PrivateKey.fromBase58(
    'EKFAdBGSSXrBbaCVqy4YjwWHoGEnsqYRQTqz227Eb5bzMx2bWu3F'
  ),
  SuperBob: PrivateKey.fromBase58(
    'EKEitxmNYYMCyumtKr8xi1yPpY3Bq6RZTEQsozu2gGf44cNxowmg'
  ),
  MegaBob: PrivateKey.fromBase58(
    'EKE9qUDcfqf6Gx9z6CNuuDYPe4XQQPzFBCfduck2X4PeFQJkhXtt'
  ), // This one says duck in it :)
  Jack: PrivateKey.fromBase58(
    'EKFS9v8wxyrrEGfec4HXycCC2nH7xf79PtQorLXXsut9WUrav4Nw'
  ),
};

export class Add extends SmartContract {
  // On-chain state definitions

  @method init() {
    // Define initial values of on-chain state
  }

  @method publishMessage(message: Field, signerPrivateKey: PrivateKey) {
    // Compute signerPublicKey from signerPrivateKey argument
    // Get approved public keys
    // Assert that signerPublicKey is one of the approved public keys
    // Update on-chain message variable
    // Computer new messageHistoryHash
    // Update on-chain messageHistoryHash
  }
}
```

This will serve as the scaffolding for the rest of the tutorial and contains a smart contract called `Message` with two methods: `init()` and `publishMessage()`. The `init()` method is similar to the `constructor` in Solidity. Itâ€™s a place for you to define any setup that needs to happen before users begin interacting with the contract. `publishMessage()` is the method that users will invoke when they want to create a new message. The `@method` decorator tells SnarkyJS that users should be allowed to call this method and that it should generate a zero-knowledge proof of its execution.

## Writing the Smart Contract

### Defining On-Chain State

Every Mina smart contract includes eight on-chain state variables that each store almost 256 bits of information. In more complex smart contracts, these can store commitments (i.e. the hash of a file, the root of a Merkle tree, etc.) to off-chain storage, but in this case, weâ€™ll store everything on-chain for the sake of simplicity.

:::note
General purpose off-chain storage libraries are planned, but you can always
roll your own solution if desired.
:::

In this smart contract, one state variable will store the last message. Another will store the hash of all the previous messages (so a frontend can validate message history), and three more will store user public keys (we could store additional public keys by Merkelizing them, but weâ€™ll keep it to three here for the sake of brevity).

```ts
export class Add extends SmartContract {
  // On-chain state definitions
  @state(Field) message = State<Field>();
  @state(Field) messageHistoryHash = State<Field>();
  @state(PublicKey) user1 = State<PublicKey>();
  @state(PublicKey) user2 = State<PublicKey>();
  @state(PublicKey) user3 = State<PublicKey>();
```

The `@state(Field)` decorator tells SnarkyJS that the variable should be stored on-chain as a `Field` type.

For practical purposes, the `Field` type is similar to the `uint256` type in Solidity. It can store large integers, and addition, subtraction, and multiplication all work as expected. The only caveats are division and what happens in the event of an overflow. You can learn a little more about finite fields [here](https://en.wikipedia.org/wiki/Finite_field_arithmetic), but itâ€™s not necessary to understand exactly how field arithmetic works for this tutorial. SnarkyJS also provides `UInt32`, `UInt64`, and `Int64` types, but under the hood, all SnarkyJS types are composed of the Field type (including `PublicKey`, as you see above).

### Defining the `init()` method

The `init` method is similar to the `constructor` in Solidity. Itâ€™s a place for you to define any setup that needs to happen before users begin interacting with the contract. In this case, weâ€™ll set the public keys of users who can post, and initialize `message` and `messageHistoryHash` as zero (our front end will interpret the zero value to mean that no messages have been posted yet).

```ts
@method init() {
  // Define initial values of on-chain state
  this.user1.set(users['Bob'].toPublicKey());
  this.user2.set(users['SuperBob'].toPublicKey());
  this.user3.set(users['MegaBob'].toPublicKey());
  this.message.set(Field(0));
  this.messageHistoryHash.set(Field(0));
}
```

### Defining `publishMessage()`

The `publishMessage` method will allow an approved user to publish a message. Note the `@method` decorator mentioned earlier. It makes this method callable by users so that they can interact with the smart contract.

For our example, weâ€™ll pass in `message` and `signerPrivateKey` arguments to check that the user holds a private key associated with one of the three on-chain public keys before allowing them to update the message.

```ts
  @method publishMessage(message: Field, signerPrivateKey: PrivateKey) {
    // Compute signerPublicKey from signerPrivateKey argument
    // Get approved public keys
    // Assert that signerPublicKey is one of the approved public keys
    // Update on-chain message state
    // Computer new messageHistoryHash
    // Update on-chain messageHistoryHash
  }
```

Note that all inputs are private by default and will only exist on the userâ€™s local machine when the smart contract runs; the Mina network will never see them. Our smart contract will only send values that are stored as state to the Mina blockchain. This means that even though the value of the `message` argument will eventually be public, the value of `signerPrivateKey` will never leave the user's machine (as a result of interacting with the smart contract).

### Computing `signerPublicKey` from `signerPrivateKey`

Now that we have the userâ€™s private key, weâ€™ll need to derive the associated public key to check it against the list of approved publishers. Luckily the `PrivateKey` type in SnarkyJS includes a `toPublicKey()` method.

```ts
// Compute signerPublicKey from signerPrivateKey argument
const signerPublicKey = signerPrivateKey.toPublicKey();
```

Weâ€™ll have to check if this public key matches one of the ones stored on-chain. So letâ€™s grab those as well.

```ts
// Get approved public keys
const user1 = this.user1.get();
const user2 = this.user2.get();
const user3 = this.user3.get();
```

Calling the `get()` method tells SnarkyJS to retrieve these values from the zkApp accountâ€™s on-chain state. (Note that SnarkyJS uses a single network request to retrieve all on-chain state values simultaneously.)

Finally, we check if `signerPublicKey` is equal to one of the allowed public keys contained in our `user` variables.

```ts
// Assert that signerPublicKey is one of the approved public keys
signerPublicKey
  .equals(user1)
  .or(signerPublicKey.equals(user2))
  .or(signerPublicKey.equals(user3))
  .assertEquals(true);
```

Notice that we call the SnarkyJS `equals()` and `or()` methods instead of using the JavaScript operators (`===`, and `||`). The built-in SnarkyJS methods have the same effect, but they work with SnarkyJS types, and their execution can be verified using a zero-knowledge proof.

`assertEquals(true)` at the end means that it will be impossible to generate a valid proof unless `signerPublicKey` is equal to one of the pre-approved users. The Mina network will reject any transaction sent to a zkApp account that doesnâ€™t include a valid zero-knowledge proof for that account. So it will be impossible for users to post new messages unless they have a private key associated with one of the three pre-approved public keys.

### Updating `message`

Until now, we have worked to ensure that only approved users can call `publishMessage()`. When they do, the contract should update the on-chain `message` variable to their new message.

```ts
// Update on-chain message state
this.message.set(message);
```

The `set()` method will ask the Mina nodes to update the value of their on-chain state, but only if the associated proof is valid.

### Updating `messageHistoryHash`

Thereâ€™s one more thing we should do. If we want users to be able to keep track of what has been said, then we need to store a commitment to the message history on-chain. There are a few ways to do this, but the simplest is to store a hash of our new `message` and our old `messageHistoryHash` every time we call `publishMessage`.

```ts
// Compute new messageHistoryHash
const oldHash = this.messageHistoryHash.get();
const newHash = Poseidon.hash([message, oldHash]);

// Update on-chain state
this.messageHistoryHash.set(newHash);
```

Thatâ€™s it! Save the file, and letâ€™s make sure everything compiles.

```sh
$ npm run build
```

If everything is correct, you should see a new `./build` directory. This is where the compiled version of your project lives that you can import into a user interface.

## Integrating with a User Interface (Coming Soon)

<!--
One of the benefits of writing smart contracts in TypeScript, is that the compiled JavaScript and WASM smart contract is easy to [integrate into your website UI](./zkapps/how-to-write-a-zkapp-ui).

We wonâ€™t make you write a UI for this tutorial, but we have created a simple command-line interface so you can interact with your smart contract as a user to get a sense of how it works, and experiment with what you have just built. You can clone it from [this](https://github.com/) repository.

```sh
git clone https://placeholder.com
cd ./placeholder
```

Now install your smart contract:

```sh
npm install ../zk-message
```

And start the front end:

```sh
npm run start

Who are you? (Bob, SuperBob, MegaBob, Jack): Bob

What would you like to say? (should only work if you are one of the Bobs): Snarky is a nice sharky.

Message history:
Snarky is a nice sharky.

Who are you? (Bob, SuperBob, MegaBob, Jack): Jack

What would you like to say? (should only work if you are one of the Bobs): Hello World!

** GNARLY ERROR **
```
-->

## Wrapping up

Hopefully you enjoyed this tutorial, and it gave you a sense of what's possible with SnarkyJS. The messaging protocol we built is quite simple but also very powerful. This basic pattern could be used to create a whistleblower system, an anonymous NFT project, or even anonymous DAO voting. SnarkyJS makes it easy for developers to build things that donâ€™t intuitively seem possible, and this is really the point.

Zero-knowledge proofs open the door to an entirely different way of thinking about the internet, and we are so excited to see what people like you will build. 

- Make sure to join the [#zkapps-developers](https://discord.com/channels/484437221055922177/915745847692636181) channel on Mina Protocol Discord.  
- If you are interested in building something more complex with the guidance of our team at O(1) Labs, you can watch for future zkApp Builders Programs. 
- To suggest tutorials, submit your ideas in the [SnarkyJS/zkApp Tutorial Request Form](https://docs.google.com/forms/d/e/1FAIpQLSctM8rq5B7teYhGl8hi2mk8NoSs6YiCDqjOnUfzpAAymU6Uug/viewform?usp=sf_link). 

Here are the logical next steps to extend this project.

1. Allow users to pass signers into the `publishMessage()` method directly so that many different organizations can use a single contract. (Hint: Youâ€™ll have to store a commitment to the signers on-chain.)
2. Allow users to pass an arbitrarily large number of signers into the `publishMessage()` method.
3. Store the message history in a Merkle tree so a user interface can quickly check a subset of the messages without evaluating the entire history.
4. Build a shiny front end!


---
title: 'Interacting with zkApps Server-Side'
hide_title: true
sidebar_label: 'Interacting with zkApps Server-Side'
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

:::note

This tutorial was last tested with [SnarkyJS](https://www.npmjs.com/package/snarkyjs) 0.8.0.

:::

# Interacting with zkApps server-side

## Overview

While user-facing zkApps can be written for the browser, sometimes it is useful to interact with a zkApp server-side, or from a developer's machine.

This tutorial shows how to do this. This can be useful when initializing a zkApp using programmatically generated information, deploying a zkApp in custom ways, or writing scripts that create transactions depending on real world or on-chain events.

To start this tutorial, read and complete [Tutorial 3](deploying-to-a-network), to see how to deploy a smart contract. We will use the same project used in Tutorial 3.

Note Tutorial 3, and this tutorial, reuse the smart contract `Square` from [Tutorial 1](hello-world).

## Interacting with our deployed Smart Contract

Once you've created your project and deployed it following Tutorial 3, we can write a script to interact with our smart contract.

### utils.ts

We will be using a helper function to make this more convenient to write, in a `utils.ts` file. You can find this file [here](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/interacting-with-zkApps-server-side/src/utils.ts). Please download this and place it in your project's `src` folder. It contains two functions:

- `loopUntilAccountExists()` which waits until an account exists on Berkeley
- `deploy()` which programmatically deploys your zkApp

We recommend reading through this code, to understand what it is doing to implement its functionality.

### Imports, main, and Mina.Network

Open up `main.ts` in a text editor. You can find the complete source for this [here](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/interacting-with-zkApps-server-side/src/main.ts).

To start, let's add the imports and SnarkyJS setup:

```ts
  1 import { Square } from './Square.js';
  2 import { isReady, shutdown, Mina, PrivateKey } from 'snarkyjs';
  3
  4 await isReady;
  5
  6 console.log('SnarkyJS loaded');
  7
  8 // ----------------------------------------------------
  9
 10 // ----------------------------------------------------
 11
 12 console.log('Shutting down');
 13
 14 await shutdown();
```

So far nothing new - but now, let's add connecting to Berkeley:

```ts
...
 8 // ----------------------------------------------------
 9
10 const Berkeley = Mina.Network(
11   'https://proxy.berkeley.minaexplorer.com/graphql'
12 );
13 Mina.setActiveInstance(Berkeley);
14
15 const transactionFee = 100_000_000;
16
16 // ----------------------------------------------------...
```

In past tutorials, we set the active instance to a local blockchain, which is fast for development, but only available on one's local machine, and not decentralized.

We are now setting the active instance to the remote Berkeley network. We are connecting to Berkeley through a GraphQL proxy, which is running a Mina node connected to the Berkeley network. By connecting to Berkeley, we can provide smart contracts that are globally accessible, and provide strong guarantees around state due to both Mina's decentralization and its succinct state proof.

With the Ethereum Bridge (to be included in a future tutorial), states and proofs from smart contracts deployed on Mina networks can also be available on Ethereum and other EVM chains.

We also set a transaction fee, which we'll use to pay for access to sending transactions and deploying smart contracts on Mina. Transaction fees in code are declared as nanomina. We will use a 0.1 Mina fee as default (100,000,000 nanomina) here.

:::note

While in this case we are connecting to a remote RPC (run by `minaexplorer.com`), you can also run a Mina node locally, and instead use its GraphQL endpoint. While in other blockchains this would be very heavyweight, because Mina is succinct this is actually a reasonable option. See [here](/node-operators/getting-started) to see how to do this.

A version of the Mina node is in the works that runs directly in the browser and within the local node process, so client side users can connect directly to Mina with low resource requirements, while keeping full decentralization guarantees, with no intermediaries that can go down, censor, or otherwise impact you or your users' connection to the network.

:::

Now, to finish setting up our code, let's add to our `main.ts`:

```ts
...
  2 import { isReady, shutdown, Mina, PrivateKey } from 'snarkyjs';
  3
  4 import fs from 'fs';
  5
...
 17 const transactionFee = 100_000_000;
 18
 19 const deployAlias = process.argv[2];
 20 const deployerKeysFileContents = fs.readFileSync(
 21   'keys/' + deployAlias + '.json',
 22   'utf8'
 23 );
 24 const deployerPrivateKeyBase58 = JSON.parse(
 25   deployerKeysFileContents
 26 ).privateKey;
 27 const deployerPrivateKey = PrivateKey.fromBase58(deployerPrivateKeyBase58);
 28 const deployerPublicKey = deployerPrivateKey.toPublicKey();
 29
 30 const zkAppPrivateKey = deployerPrivateKey;
 31
 32 // ----------------------------------------------------
...
```

This uses the key generated by the `zk config` command, stored in `keys/`. The name of the key file will be provided through an argument on the command line (`process.argv[2]`).

You can run this now with:

```sh
$ npm run build && node build/src/main.js berkeley
```

Which will read keys from `keys/berkeley.json`. Public and private keys in Mina are commonly stored in `base58` for easily readability. In Mina, public keys start with `B62`, and private keys start with `EKE` for easy differentiability.

Our SmartContract is also deployed to the same account we deployed from. So we set `zkAppPrivateKey = deployerPrivateKey`. Depending on the application, it can also be useful to have separate keys for the zkApp and deployer accounts!

### Waiting for accounts to be ready

Next, we will wait for the deployer account to be ready.

In main, we will import and use the `loopUntilAccountExists()` function from `utils.ts`:

```ts
...
  4 import fs from 'fs';
  5 import { loopUntilAccountExists } from './utils.js';
  6
  7 await isReady;
...
 33 // ----------------------------------------------------
 34
 35 let account = await loopUntilAccountExists({
 36   account: deployerPublicKey,
 37   eachTimeNotExist: () => {
 38     console.log(
 39       'Deployer account does not exist. ' +
 40         'Request funds at faucet ' +
 41         'https://faucet.minaprotocol.com/?address=' +
 42         deployerPublicKey.toBase58()
 43     );
 44   },
 45   isZkAppAccount: false,
 46 });
 47
 48 console.log(
 49   `Using fee payer account with nonce ${account.nonce}, balance ${account.balance}`
 50 );
 51
 52 // ----------------------------------------------------
...
```

We wait until our new deployment account exist - if it does not, we share a link with the user to go to the faucet and request funds.

If the key created from the `zk deploy` command earlier in this tutorial has already been funded, then this should find the account and move on. If that transaction hasn't finished yet, then this will wait until that has completed.

Once we find the account, we print out its nonce, and its balance.

Moving on, we compile the smart contract, and wait for it to have been deployed:

```ts
...
 52 // ----------------------------------------------------
 53
 54 console.log('Compiling smart contract...');
 55 let { verificationKey } = await Square.compile();
 56
 57 const zkAppPublicKey = zkAppPrivateKey.toPublicKey();
 58 let zkapp = new Square(zkAppPublicKey);
 59
 60 // Programmatic deploy:
 61 //   Besides the CLI, you can also create accounts programmatically. This is useful if you need
 62 //   more custom account creation - say deploying a zkApp to a different key than the deployer
 63 //   key, programmatically parameterizing a zkApp before initializing it, or creating Smart
 64 //   Contracts programmatically for users as part of an application.
 65 // await deploy(deployerPrivateKey, zkAppPrivateKey, zkapp, verificationKey);
 66
 67 await loopUntilAccountExists({
 68   account: zkAppPublicKey,
 69   eachTimeNotExist: () =>
 70     console.log('waiting for zkApp account to be deployed...'),
 71   isZkAppAccount: true
 72 });
 73
 74 let num = (await zkapp.num.fetch())!;
 75 console.log(`current value of num is ${num}`);
 76
 77 // ----------------------------------------------------
...
```

To do this, we reuse the helper function `loopUntilAccountExists()` from `utils.js`. This time, we pass in `isZkappAccount: true` which makes it not only check if the account exists, but also whether there is a verification key on the account. An existing verification key indicates that the zkApp has been successfully deployed.

Note as we deployed our smart contract already with `zk deploy`, programmatic deploy is not needed, and is commented out here. If you would like to see how this works, or it's useful for your application, see code for this [here](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/interacting-with-zkApps-server-side/src/utils.ts).

After being certain that our zkApp has been deployed, we fetch the current value of `zkapp.num` (the on-chain we defined on the `SmartContract`) and log it. If this is the first time you run this script, the value should be `3` because that's how we set it in our smart contract's `init()` function. The `init()` function is called automatically during the first deploy (not during re-deploys).

<!-- note: I'm commenting this out since setting `provedState` with `init()` doesn't work yet anyway because of the missing verification key protocol bug.

:::info

There is a `provedState` property on accounts present in the protocol, but yet to be exposed in SnarkyJS, that can be used to assert in a proof that the smart contract has been initialized.

This `provedState` property starts out `false` when a contract is deployed. It is set to true whenever the _entire state_ of the smart contract is overwritten by a proof. TODO. More details will be released as this feature is made available.

::: -->

### Calling update on our transaction

And lastly, let's now send an update to our transaction. If the zkApp was just initialized, this will call update on the newly initialized account. Otherwise, it will call update on whatever the current account state happens to be.

```ts
...
 77 // ----------------------------------------------------
 78
 79 let transaction = await Mina.transaction(
 80   { sender: deployerPublicKey, fee: transactionFee },
 81   () => {
 82     zkapp.update(num.mul(num));
 83   }
 84 );
 85
 86 // fill in the proof - this can take a while...
 87 console.log('Creating an execution proof...');
 88 let time0 = performance.now();
 89 await transaction.prove();
 90 let time1 = performance.now();
 91 console.log(`creating proof took ${(time1 - time0) / 1e3} seconds`);
 92
 93 // sign transaction with the deployer account
 94 transaction.sign([deployerPrivateKey]);
 95
 96 console.log('Sending the transaction...');
 97 let pendingTransaction = await transaction.send();
 98
 99 // ----------------------------------------------------
...
```

To send an update transaction, we perform the following steps:

1. Construct the transaction with `Mina.transaction`. This is where we call `zkapp.update()`, which is the custom method defined on our smart contract.
2. Create a proof of the transaction. This can take up to a minute.
3. Sign the transaction, and send it to the network.

When sending the transaction using `transaction.send()`, we get back an object called `pendingTransaction`. This gives us info about how the transaction went and lets us wait for inclusion in a block:

```ts
 99 // ----------------------------------------------------
100
101 if (!pendingTransaction.isSuccess) {
102   console.log('error sending transaction (see above)');
103   process.exit(0);
104 }
105
106 console.log(
107   `See transaction at https://berkeley.minaexplorer.com/transaction/${pendingTransaction.hash()}
108 Waiting for transaction to be included...`
109 );
110 await pendingTransaction.wait();
111
112 console.log(`updated state! ${await zkapp.num.fetch()}`);
113
114 // ----------------------------------------------------
```

Here we use several functionalities of the pending transaction:

- `pendingTransaction.isSuccess` is a boolean that tells us whether the transaction was successful. Most invalid transactions will be rejected by the GraphQL endpoint immediately and will have `isSuccess === false`.
- `pendingTransaction.hash()` tells us the transaction hash, which you can use to look up the transaction in a block explorer. (If the transaction failed, this will return `undefined`).
- `pendingTransaction.wait()` is especially useful: it returns a promise that only resolves after the transaction is included in the latest block on the network. This takes several minutes, so you might not want to block the main thread on this in a real application.

Finally, after the transaction was successfully applied on the Mina blockchain, we can double-check that our state was updated by fetching it again with `zkapp.num.fetch()`.

## Conclusion

We have finished writing a script to initialize the state and interact with it! You can also run this script multiple times, and it should each time, update `x` to its square.

Check out out our other tutorials and documentation to keep going!


